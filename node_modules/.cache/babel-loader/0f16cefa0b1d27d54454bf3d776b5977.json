{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapUriDefaultScheme = exports.getDefaultAuthority = exports.createResolver = exports.registerDefaultScheme = exports.registerResolver = void 0;\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst registeredResolvers = {};\nlet defaultScheme = null;\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\n\nfunction registerResolver(scheme, resolverClass) {\n  registeredResolvers[scheme] = resolverClass;\n}\n\nexports.registerResolver = registerResolver;\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\n\nfunction registerDefaultScheme(scheme) {\n  defaultScheme = scheme;\n}\n\nexports.registerDefaultScheme = registerDefaultScheme;\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\n\nfunction createResolver(target, listener, options) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(`No resolver could be created for target ${uri_parser_1.uriToString(target)}`);\n  }\n}\n\nexports.createResolver = createResolver;\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\n\nfunction getDefaultAuthority(target) {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${uri_parser_1.uriToString(target)}`);\n  }\n}\n\nexports.getDefaultAuthority = getDefaultAuthority;\n\nfunction mapUriDefaultScheme(target) {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: uri_parser_1.uriToString(target)\n      };\n    } else {\n      return null;\n    }\n  }\n\n  return target;\n}\n\nexports.mapUriDefaultScheme = mapUriDefaultScheme;","map":{"version":3,"sources":["C:\\react\\quiz\\node_modules\\@grpc\\grpc-js\\src\\resolver.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;AAeG;;;;;;;AAKH,MAAA,YAAA,GAAA,OAAA,CAAA,cAAA,CAAA;;AAoFA,MAAM,mBAAmB,GAA8C,EAAvE;AACA,IAAI,aAAa,GAAkB,IAAnC;AAEA;;;;;;AAMG;;AACH,SAAgB,gBAAhB,CACE,MADF,EAEE,aAFF,EAEoC;AAElC,EAAA,mBAAmB,CAAC,MAAD,CAAnB,GAA8B,aAA9B;AACD;;AALD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAOA;;;;AAIG;;AACH,SAAgB,qBAAhB,CAAsC,MAAtC,EAAoD;AAClD,EAAA,aAAa,GAAG,MAAhB;AACD;;AAFD,OAAA,CAAA,qBAAA,GAAA,qBAAA;AAIA;;;;;AAKG;;AACH,SAAgB,cAAhB,CACE,MADF,EAEE,QAFF,EAGE,OAHF,EAGyB;AAEvB,MAAI,MAAM,CAAC,MAAP,KAAkB,SAAlB,IAA+B,MAAM,CAAC,MAAP,IAAiB,mBAApD,EAAyE;AACvE,WAAO,IAAI,mBAAmB,CAAC,MAAM,CAAC,MAAR,CAAvB,CAAuC,MAAvC,EAA+C,QAA/C,EAAyD,OAAzD,CAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAI,KAAJ,CACJ,2CAA2C,YAAA,CAAA,WAAA,CAAY,MAAZ,CAAmB,EAD1D,CAAN;AAGD;AACF;;AAZD,OAAA,CAAA,cAAA,GAAA,cAAA;AAcA;;;;AAIG;;AACH,SAAgB,mBAAhB,CAAoC,MAApC,EAAmD;AACjD,MAAI,MAAM,CAAC,MAAP,KAAkB,SAAlB,IAA+B,MAAM,CAAC,MAAP,IAAiB,mBAApD,EAAyE;AACvE,WAAO,mBAAmB,CAAC,MAAM,CAAC,MAAR,CAAnB,CAAmC,mBAAnC,CAAuD,MAAvD,CAAP;AACD,GAFD,MAEO;AACL,UAAM,IAAI,KAAJ,CAAU,kBAAkB,YAAA,CAAA,WAAA,CAAY,MAAZ,CAAmB,EAA/C,CAAN;AACD;AACF;;AAND,OAAA,CAAA,mBAAA,GAAA,mBAAA;;AAQA,SAAgB,mBAAhB,CAAoC,MAApC,EAAmD;AACjD,MAAI,MAAM,CAAC,MAAP,KAAkB,SAAlB,IAA+B,EAAE,MAAM,CAAC,MAAP,IAAiB,mBAAnB,CAAnC,EAA4E;AAC1E,QAAI,aAAa,KAAK,IAAtB,EAA4B;AAC1B,aAAO;AACL,QAAA,MAAM,EAAE,aADH;AAEL,QAAA,SAAS,EAAE,SAFN;AAGL,QAAA,IAAI,EAAE,YAAA,CAAA,WAAA,CAAY,MAAZ;AAHD,OAAP;AAKD,KAND,MAMO;AACL,aAAO,IAAP;AACD;AACF;;AACD,SAAO,MAAP;AACD;;AAbD,OAAA,CAAA,mBAAA,GAAA,mBAAA","sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { MethodConfig, ServiceConfig } from './service-config';\nimport { StatusObject } from './call-stream';\nimport { SubchannelAddress } from './subchannel-address';\nimport { GrpcUri, uriToString } from './uri-parser';\nimport { ChannelOptions } from './channel-options';\nimport { Metadata } from './metadata';\nimport { Status } from './constants';\nimport { Filter, FilterFactory } from './filter';\n\nexport interface CallConfig {\n  methodConfig: MethodConfig;\n  onCommitted?: () => void;\n  pickInformation: { [key: string]: string };\n  status: Status;\n  dynamicFilterFactories: FilterFactory<Filter>[];\n}\n\n/**\n * Selects a configuration for a method given the name and metadata. Defined in\n * https://github.com/grpc/proposal/blob/master/A31-xds-timeout-support-and-config-selector.md#new-functionality-in-grpc\n */\nexport interface ConfigSelector {\n  (methodName: string, metadata: Metadata): CallConfig;\n}\n\n/**\n * A listener object passed to the resolver's constructor that provides name\n * resolution updates back to the resolver's owner.\n */\nexport interface ResolverListener {\n  /**\n   * Called whenever the resolver has new name resolution results to report\n   * @param addressList The new list of backend addresses\n   * @param serviceConfig The new service configuration corresponding to the\n   *     `addressList`. Will be `null` if no service configuration was\n   *     retrieved or if the service configuration was invalid\n   * @param serviceConfigError If non-`null`, indicates that the retrieved\n   *     service configuration was invalid\n   */\n  onSuccessfulResolution(\n    addressList: SubchannelAddress[],\n    serviceConfig: ServiceConfig | null,\n    serviceConfigError: StatusObject | null,\n    configSelector: ConfigSelector | null,\n    attributes: { [key: string]: unknown }\n  ): void;\n  /**\n   * Called whenever a name resolution attempt fails.\n   * @param error Describes how resolution failed\n   */\n  onError(error: StatusObject): void;\n}\n\n/**\n * A resolver class that handles one or more of the name syntax schemes defined\n * in the [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n */\nexport interface Resolver {\n  /**\n   * Indicates that the caller wants new name resolution data. Calling this\n   * function may eventually result in calling one of the `ResolverListener`\n   * functions, but that is not guaranteed. Those functions will never be\n   * called synchronously with the constructor or updateResolution.\n   */\n  updateResolution(): void;\n\n  /**\n   * Destroy the resolver. Should be called when the owning channel shuts down.\n   */\n  destroy(): void;\n}\n\nexport interface ResolverConstructor {\n  new (\n    target: GrpcUri,\n    listener: ResolverListener,\n    channelOptions: ChannelOptions\n  ): Resolver;\n  /**\n   * Get the default authority for a target. This loosely corresponds to that\n   * target's hostname. Throws an error if this resolver class cannot parse the\n   * `target`.\n   * @param target\n   */\n  getDefaultAuthority(target: GrpcUri): string;\n}\n\nconst registeredResolvers: { [scheme: string]: ResolverConstructor } = {};\nlet defaultScheme: string | null = null;\n\n/**\n * Register a resolver class to handle target names prefixed with the `prefix`\n * string. This prefix should correspond to a URI scheme name listed in the\n * [gRPC Name Resolution document](https://github.com/grpc/grpc/blob/master/doc/naming.md)\n * @param prefix\n * @param resolverClass\n */\nexport function registerResolver(\n  scheme: string,\n  resolverClass: ResolverConstructor\n) {\n  registeredResolvers[scheme] = resolverClass;\n}\n\n/**\n * Register a default resolver to handle target names that do not start with\n * any registered prefix.\n * @param resolverClass\n */\nexport function registerDefaultScheme(scheme: string) {\n  defaultScheme = scheme;\n}\n\n/**\n * Create a name resolver for the specified target, if possible. Throws an\n * error if no such name resolver can be created.\n * @param target\n * @param listener\n */\nexport function createResolver(\n  target: GrpcUri,\n  listener: ResolverListener,\n  options: ChannelOptions\n): Resolver {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return new registeredResolvers[target.scheme](target, listener, options);\n  } else {\n    throw new Error(\n      `No resolver could be created for target ${uriToString(target)}`\n    );\n  }\n}\n\n/**\n * Get the default authority for the specified target, if possible. Throws an\n * error if no registered name resolver can parse that target string.\n * @param target\n */\nexport function getDefaultAuthority(target: GrpcUri): string {\n  if (target.scheme !== undefined && target.scheme in registeredResolvers) {\n    return registeredResolvers[target.scheme].getDefaultAuthority(target);\n  } else {\n    throw new Error(`Invalid target ${uriToString(target)}`);\n  }\n}\n\nexport function mapUriDefaultScheme(target: GrpcUri): GrpcUri | null {\n  if (target.scheme === undefined || !(target.scheme in registeredResolvers)) {\n    if (defaultScheme !== null) {\n      return {\n        scheme: defaultScheme,\n        authority: undefined,\n        path: uriToString(target),\n      };\n    } else {\n      return null;\n    }\n  }\n  return target;\n}\n"]},"metadata":{},"sourceType":"script"}