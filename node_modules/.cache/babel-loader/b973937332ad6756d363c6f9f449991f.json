{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Test displaying DNS records\nvar util = require('util');\n\nvar parse = require('./parse');\n\nvar encode = require('./encode');\n\nvar constants = require('./constants');\n\nmodule.exports = DNSMessage;\nvar SECTIONS = ['question', 'answer', 'authority', 'additional']; // A DNS message.  This is an easy-to-understand object representation of\n// standard DNS queries and responses.\n//\n// Attributes:\n// * id                  - a number representing the unique query ID\n// * type                - \"request\" or \"response\"\n// * response            - Number (server response code)\n// * opcode              - \"query\", \"iquery\", \"status\", \"unassigned\", \"notify\", \"update\"\n// * authoritative       - Boolean\n// * truncated           - Boolean\n// * recursion_desired   - Boolean\n// * recursion_available - Boolean\n// * authenticated       - Boolean\n// * checking_disabled   - Boolean\n//\n// Optional attributes:\n// * question (optional) - Array of the question section\n// * answer (optional) - Array of the answer section\n// * authority (optional) - Array of the authority section\n// * additional (optional) - Array of the additional section\n//\n// Methods:\n// * toString() - return a human-readable representation of this message\n// * toJSON() - Return a JSON-friendly represenation of this message\n// * toBinary() - Return a buffer of the encoded message\n\nfunction DNSMessage(body) {\n  var self = this;\n  this.id = null;\n  this.type = null;\n  this.responseCode = null;\n  this.opcode = null;\n  this.authoritative = null;\n  this.truncated = null;\n  this.recursion_desired = null;\n  this.recursion_available = null;\n  this.authenticated = null;\n  this.checking_disabled = null;\n  if (Buffer.isBuffer(body)) this.parse(body);else if (typeof body != 'object') throw new Error('Must provide a buffer or object argument with message contents');else {\n    Object.keys(body).forEach(function (key) {\n      self[key] = body[key];\n    });\n    SECTIONS.forEach(function (section) {\n      if (self[section]) self[section].forEach(function (record, i) {\n        self[section][i] = new DNSRecord(record);\n      });\n    });\n  } // EDNS processing. For now, just remove those records.\n\n  SECTIONS.forEach(function (section) {\n    if (self[section]) {\n      self[section] = self[section].filter(function (record) {\n        return !record.edns;\n      });\n      if (self[section].length == 0) delete self[section];\n    }\n  });\n}\n\nDNSMessage.prototype.parse = function (body) {\n  var self = this;\n  self.id = parse.id(body);\n  var qr = parse.qr(body);\n  self.type = qr == 0 ? 'request' : 'response';\n  self.responseCode = parse.rcode(body);\n  var opcode_names = ['query', 'iquery', 'status', null, 'notify', 'update'];\n  var opcode = parse.opcode(body);\n  self.opcode = opcode_names[opcode] || null;\n  self.authoritative = !!parse.aa(body);\n  self.truncated = !!parse.tc(body);\n  self.recursion_desired = !!parse.rd(body);\n  self.recursion_available = !!parse.ra(body);\n  self.authenticated = !!parse.ad(body);\n  self.checking_disabled = !!parse.cd(body);\n  var sections_cache = parse.sections(body);\n  SECTIONS.forEach(function (section) {\n    var count = parse.record_count(body, section);\n\n    if (count) {\n      self[section] = [];\n\n      for (var i = 0; i < count; i++) self[section].push(new DNSRecord(body, section, i, sections_cache));\n    }\n  });\n};\n\nDNSMessage.prototype.toBinary = function () {\n  // The encoder is picky, so make sure it gets a valid message.\n  var msg = JSON.parse(JSON.stringify(this));\n  SECTIONS.forEach(function (section) {\n    if (section == 'question') return;\n    msg[section] = msg[section] || [];\n    msg[section].forEach(function (record) {\n      if (record.class != 'IN') return; // Make sure records promising data have data.\n\n      if (record.class == 'IN' && record.type == 'A') record.data = record.data || '0.0.0.0'; // Convert SOA email addresses back to the dotted notation.\n\n      if (record.class == 'IN' && record.type == 'SOA') record.data.rname = record.data.rname.replace(/@/g, '.'); // Normalize TXT records.\n\n      if (record.type == 'TXT' && typeof record.data == 'string') record.data = [record.data];\n    });\n  });\n  var state = new encode.State();\n  state.message(msg);\n  return state.toBinary();\n};\n\nDNSMessage.prototype.toString = function () {\n  var self = this;\n  var info = [util.format('ID                 : %d', self.id), util.format(\"Type               : %s\", self.type), util.format(\"Opcode             : %s\", self.opcode), util.format(\"Authoritative      : %s\", self.authoritative), util.format(\"Truncated          : %s\", self.truncated), util.format(\"Recursion Desired  : %s\", self.recursion_desired), util.format(\"Recursion Available: %s\", self.recursion_available), util.format(\"Response Code      : %d\", self.responseCode)];\n  SECTIONS.forEach(function (section) {\n    if (self[section]) {\n      info.push(util.format(';; %s SECTION:', section.toUpperCase()));\n      self[section].forEach(function (record) {\n        info.push(record.toString());\n      });\n    }\n  });\n  return info.join('\\n');\n}; // An individual record from a DNS message\n//\n// Attributes:\n// * name  - Host name\n// * type  - Query type ('A', 'NS', 'CNAME', etc. or 'Unknown')\n// * class - Network class ('IN', 'None' 'Unknown')\n// * ttl   - Time to live for the data in the record\n// * data  - The record data value, or null if not applicable\n\n\nfunction DNSRecord(body, section_name, record_num, sections_cache) {\n  var self = this;\n  this.name = null;\n  this.type = null;\n  this.class = null; // Leave these undefined for more consice and clear JSON serialization.\n  //this.ttl  = null\n  //this.data = null\n\n  if (Buffer.isBuffer(body)) this.parse(body, section_name, record_num, sections_cache || body);else if (typeof body != 'object') throw new Error('Must provide a buffer or object argument with message contents');else Object.keys(body).forEach(function (key) {\n    self[key] = body[key];\n  });\n}\n\nDNSRecord.prototype.parse = function (body, section_name, record_num, sections) {\n  var self = this;\n  self.name = parse.record_name(sections, section_name, record_num);\n  var type = parse.record_type(sections, section_name, record_num);\n  self.type = constants.type_to_label(type);\n  if (!self.type) throw new Error('Record ' + record_num + ' in section \"' + section_name + '\" has unknown type: ' + type);\n\n  if (section_name != 'additional' || self.type != 'OPT' || self.name != '') {\n    // Normal record\n    var clas = parse.record_class(sections, section_name, record_num);\n    self.class = constants.class_to_label(clas);\n    if (!self.class) throw new Error('Record ' + record_num + ' in section \"' + section_name + '\" has unknown class: ' + type);\n    if (section_name == 'question') return;else self.ttl = parse.record_ttl(sections, section_name, record_num);\n  } else {\n    // EDNS record\n    self.edns = true;\n    delete self.name;\n    delete self.class; //self.edns = parse.record_edns(sections, section_name, record_num)\n  }\n\n  var rdata = parse.record_data(sections, section_name, record_num);\n\n  switch (self.kind()) {\n    case 'IN A':\n      if (rdata.length != 4) throw new Error('Bad IN A data: ' + JSON.stringify(self));\n      self.data = inet_ntoa(rdata);\n      break;\n\n    case 'IN AAAA':\n      if (rdata.length != 16) throw new Error('Bad IN AAAA data: ' + JSON.stringify(self));\n      self.data = inet_ntoa6(rdata);\n      break;\n\n    case 'IN NS':\n    case 'IN CNAME':\n    case 'IN PTR':\n      self.data = parse.uncompress(body, rdata);\n      break;\n\n    case 'IN TXT':\n      self.data = parse.txt(body, rdata);\n      if (self.data.length === 0) self.data = '';else if (self.data.length === 1) self.data = self.data[0];\n      break;\n\n    case 'IN MX':\n      self.data = parse.mx(body, rdata);\n      break;\n\n    case 'IN SRV':\n      self.data = parse.srv(body, rdata);\n      break;\n\n    case 'IN SOA':\n      self.data = parse.soa(body, rdata);\n      self.data.rname = self.data.rname.replace(/\\./, '@');\n      break;\n\n    case 'IN DS':\n      self.data = {\n        'key_tag': rdata[0] << 8 | rdata[1],\n        'algorithm': rdata[2],\n        'digest_type': rdata[3],\n        'digest': rdata.slice(4).toJSON() // Convert to a list of numbers.\n\n      };\n      break;\n\n    case 'NONE A':\n      self.data = [];\n      break;\n\n    case 'EDNS':\n      self.data = rdata;\n      break;\n\n    default:\n      throw new Error('Unknown record ' + self.kind() + ': ' + JSON.stringify(self));\n  }\n};\n\nDNSRecord.prototype.kind = function () {\n  return this.edns ? 'EDNS' : this.class + ' ' + this.type;\n};\n\nDNSRecord.prototype.toString = function () {\n  var self = this;\n  return [width(23, self.name), width(7, self.ttl || ''), width(7, self.class), width(7, self.type), self.type == 'MX' && self.data ? width(3, self.data[0]) + ' ' + self.data[1] : Buffer.isBuffer(self.data) ? self.data.toString('hex') : self.data || ''].join(' ');\n}; //\n// Utilities\n//\n\n\nfunction width(str_len, str) {\n  str = '' + str;\n\n  do {\n    var needed = str_len - str.length;\n    if (needed > 0) str = ' ' + str;\n  } while (needed > 0);\n\n  return str;\n}\n\nfunction inet_ntoa(buf) {\n  return buf[0] + '.' + buf[1] + '.' + buf[2] + '.' + buf[3];\n}\n\nfunction inet_ntoa6(buf) {\n  var result = [];\n\n  for (var i = 0; i < 16; i += 2) result.push(buf.slice(i, i + 2).toString('hex'));\n\n  return result.join(':');\n}","map":{"version":3,"sources":["C:/react/quiz/node_modules/hbo-dnsd/message.js"],"names":["util","require","parse","encode","constants","module","exports","DNSMessage","SECTIONS","body","self","id","type","responseCode","opcode","authoritative","truncated","recursion_desired","recursion_available","authenticated","checking_disabled","Buffer","isBuffer","Error","Object","keys","forEach","key","section","record","i","DNSRecord","filter","edns","length","prototype","qr","rcode","opcode_names","aa","tc","rd","ra","ad","cd","sections_cache","sections","count","record_count","push","toBinary","msg","JSON","stringify","class","data","rname","replace","state","State","message","toString","info","format","toUpperCase","join","section_name","record_num","name","record_name","record_type","type_to_label","clas","record_class","class_to_label","ttl","record_ttl","rdata","record_data","kind","inet_ntoa","inet_ntoa6","uncompress","txt","mx","srv","soa","slice","toJSON","width","str_len","str","needed","buf","result"],"mappings":"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","sourcesContent":["// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Test displaying DNS records\n\nvar util = require('util')\n\nvar parse = require('./parse')\nvar encode = require('./encode')\nvar constants = require('./constants')\n\nmodule.exports = DNSMessage\n\nvar SECTIONS = ['question', 'answer', 'authority', 'additional']\n\n// A DNS message.  This is an easy-to-understand object representation of\n// standard DNS queries and responses.\n//\n// Attributes:\n// * id                  - a number representing the unique query ID\n// * type                - \"request\" or \"response\"\n// * response            - Number (server response code)\n// * opcode              - \"query\", \"iquery\", \"status\", \"unassigned\", \"notify\", \"update\"\n// * authoritative       - Boolean\n// * truncated           - Boolean\n// * recursion_desired   - Boolean\n// * recursion_available - Boolean\n// * authenticated       - Boolean\n// * checking_disabled   - Boolean\n//\n// Optional attributes:\n// * question (optional) - Array of the question section\n// * answer (optional) - Array of the answer section\n// * authority (optional) - Array of the authority section\n// * additional (optional) - Array of the additional section\n//\n// Methods:\n// * toString() - return a human-readable representation of this message\n// * toJSON() - Return a JSON-friendly represenation of this message\n// * toBinary() - Return a buffer of the encoded message\nfunction DNSMessage (body) {\n  var self = this\n\n  this.id = null\n  this.type                = null\n  this.responseCode        = null\n  this.opcode              = null\n  this.authoritative       = null\n  this.truncated           = null\n  this.recursion_desired   = null\n  this.recursion_available = null\n  this.authenticated       = null\n  this.checking_disabled   = null\n\n  if(Buffer.isBuffer(body))\n    this.parse(body)\n  else if(typeof body != 'object')\n    throw new Error('Must provide a buffer or object argument with message contents')\n  else {\n    Object.keys(body).forEach(function(key) { self[key] = body[key] })\n    SECTIONS.forEach(function(section) {\n      if(self[section])\n        self[section].forEach(function(record, i) {\n          self[section][i] = new DNSRecord(record)\n        })\n    })\n  }\n\n  // EDNS processing. For now, just remove those records.\n  SECTIONS.forEach(function(section) {\n    if(self[section]) {\n      self[section] = self[section].filter(function(record) { return ! record.edns })\n      if(self[section].length == 0)\n        delete self[section]\n    }\n  })\n}\n\nDNSMessage.prototype.parse = function(body) {\n  var self = this\n\n  self.id = parse.id(body)\n\n  var qr = parse.qr(body)\n  self.type = (qr == 0) ? 'request' : 'response'\n\n  self.responseCode = parse.rcode(body)\n\n  var opcode_names = ['query', 'iquery', 'status', null, 'notify', 'update']\n  var opcode = parse.opcode(body)\n  self.opcode = opcode_names[opcode] || null\n\n  self.authoritative       = !! parse.aa(body)\n  self.truncated           = !! parse.tc(body)\n  self.recursion_desired   = !! parse.rd(body)\n  self.recursion_available = !! parse.ra(body)\n  self.authenticated       = !! parse.ad(body)\n  self.checking_disabled   = !! parse.cd(body)\n\n  var sections_cache = parse.sections(body)\n\n  SECTIONS.forEach(function(section) {\n    var count = parse.record_count(body, section)\n    if(count) {\n      self[section] = []\n      for(var i = 0; i < count; i++)\n        self[section].push(new DNSRecord(body, section, i, sections_cache))\n    }\n  })\n}\n\nDNSMessage.prototype.toBinary = function() {\n  // The encoder is picky, so make sure it gets a valid message.\n  var msg = JSON.parse(JSON.stringify(this))\n\n  SECTIONS.forEach(function(section) {\n    if(section == 'question')\n      return\n\n    msg[section] = msg[section] || []\n    msg[section].forEach(function(record) {\n      if(record.class != 'IN')\n        return\n\n      // Make sure records promising data have data.\n      if(record.class == 'IN' && record.type == 'A')\n        record.data = record.data || '0.0.0.0'\n\n      // Convert SOA email addresses back to the dotted notation.\n      if(record.class == 'IN' && record.type == 'SOA')\n        record.data.rname = record.data.rname.replace(/@/g, '.')\n\n      // Normalize TXT records.\n      if(record.type == 'TXT' && typeof record.data == 'string')\n        record.data = [record.data]\n    })\n  })\n\n  var state = new encode.State\n  state.message(msg)\n  return state.toBinary()\n}\n\nDNSMessage.prototype.toString = function() {\n  var self = this\n\n  var info = [ util.format('ID                 : %d', self.id)\n             , util.format(\"Type               : %s\", self.type)\n             , util.format(\"Opcode             : %s\", self.opcode)\n             , util.format(\"Authoritative      : %s\", self.authoritative)\n             , util.format(\"Truncated          : %s\", self.truncated)\n             , util.format(\"Recursion Desired  : %s\", self.recursion_desired)\n             , util.format(\"Recursion Available: %s\", self.recursion_available)\n             , util.format(\"Response Code      : %d\", self.responseCode)\n             ]\n\n  SECTIONS.forEach(function(section) {\n    if(self[section]) {\n      info.push(util.format(';; %s SECTION:', section.toUpperCase()))\n      self[section].forEach(function(record) {\n        info.push(record.toString())\n      })\n    }\n  })\n\n  return info.join('\\n')\n}\n\n\n// An individual record from a DNS message\n//\n// Attributes:\n// * name  - Host name\n// * type  - Query type ('A', 'NS', 'CNAME', etc. or 'Unknown')\n// * class - Network class ('IN', 'None' 'Unknown')\n// * ttl   - Time to live for the data in the record\n// * data  - The record data value, or null if not applicable\nfunction DNSRecord (body, section_name, record_num, sections_cache) {\n  var self = this\n\n  this.name = null\n  this.type = null\n  this.class = null\n\n  // Leave these undefined for more consice and clear JSON serialization.\n  //this.ttl  = null\n  //this.data = null\n\n  if(Buffer.isBuffer(body))\n    this.parse(body, section_name, record_num, sections_cache || body)\n  else if(typeof body != 'object')\n    throw new Error('Must provide a buffer or object argument with message contents')\n  else\n    Object.keys(body).forEach(function(key) { self[key] = body[key] })\n}\n\nDNSRecord.prototype.parse = function(body, section_name, record_num, sections) {\n  var self = this\n\n  self.name = parse.record_name(sections, section_name, record_num)\n\n  var type = parse.record_type(sections, section_name, record_num)\n  self.type = constants.type_to_label(type)\n  if(! self.type)\n    throw new Error('Record '+record_num+' in section \"'+section_name+'\" has unknown type: ' + type)\n\n  if(section_name != 'additional' || self.type != 'OPT' || self.name != '') {\n    // Normal record\n    var clas = parse.record_class(sections, section_name, record_num)\n    self.class = constants.class_to_label(clas)\n    if(! self.class)\n      throw new Error('Record '+record_num+' in section \"'+section_name+'\" has unknown class: ' + type)\n\n    if(section_name == 'question')\n      return\n    else\n      self.ttl  = parse.record_ttl(sections, section_name, record_num)\n  } else {\n    // EDNS record\n    self.edns = true\n    delete self.name\n    delete self.class\n    //self.edns = parse.record_edns(sections, section_name, record_num)\n  }\n\n  var rdata = parse.record_data(sections, section_name, record_num)\n  switch (self.kind()) {\n    case 'IN A':\n      if(rdata.length != 4)\n        throw new Error('Bad IN A data: ' + JSON.stringify(self))\n      self.data = inet_ntoa(rdata)\n      break\n    case 'IN AAAA':\n      if(rdata.length != 16)\n        throw new Error('Bad IN AAAA data: ' + JSON.stringify(self))\n      self.data = inet_ntoa6(rdata)\n      break\n    case 'IN NS':\n    case 'IN CNAME':\n    case 'IN PTR':\n      self.data = parse.uncompress(body, rdata)\n      break\n    case 'IN TXT':\n      self.data = parse.txt(body, rdata)\n      if(self.data.length === 0)\n        self.data = ''\n      else if(self.data.length === 1)\n        self.data = self.data[0]\n      break\n    case 'IN MX':\n      self.data = parse.mx(body, rdata)\n      break\n    case 'IN SRV':\n      self.data = parse.srv(body, rdata)\n      break\n    case 'IN SOA':\n      self.data = parse.soa(body, rdata)\n      self.data.rname = self.data.rname.replace(/\\./, '@')\n      break\n    case 'IN DS':\n      self.data = { 'key_tag'    : rdata[0] << 8 | rdata[1]\n                  , 'algorithm'  : rdata[2]\n                  , 'digest_type': rdata[3]\n                  , 'digest'     : rdata.slice(4).toJSON() // Convert to a list of numbers.\n                  }\n      break\n    case 'NONE A':\n      self.data = []\n      break\n    case 'EDNS':\n      self.data = rdata\n      break\n    default:\n      throw new Error('Unknown record '+self.kind()+': ' + JSON.stringify(self))\n  }\n}\n\nDNSRecord.prototype.kind = function() {\n  return this.edns\n          ? 'EDNS'\n          : this.class + ' ' + this.type\n}\n\nDNSRecord.prototype.toString = function() {\n  var self = this\n  return [ width(23, self.name)\n         , width( 7, self.ttl || '')\n         , width( 7, self.class)\n         , width( 7, self.type)\n         , self.type == 'MX' && self.data\n            ? (width(3, self.data[0]) + ' ' + self.data[1])\n           : Buffer.isBuffer(self.data)\n            ? self.data.toString('hex')\n            : self.data || ''\n         ].join(' ')\n}\n\n//\n// Utilities\n//\n\nfunction width(str_len, str) {\n  str = '' + str\n  do {\n    var needed = str_len - str.length\n    if(needed > 0)\n      str = ' ' + str\n  } while(needed > 0)\n\n  return str\n}\n\nfunction inet_ntoa(buf) {\n  return buf[0] + '.' + buf[1] + '.' + buf[2] + '.' + buf[3]\n}\n\nfunction inet_ntoa6(buf) {\n  var result = []\n  for(var i = 0; i < 16; i += 2)\n    result.push(buf.slice(i, i+2).toString('hex'))\n  return result.join(':')\n}\n"]},"metadata":{},"sourceType":"script"}