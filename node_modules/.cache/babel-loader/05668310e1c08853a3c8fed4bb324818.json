{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getInterceptingCall = exports.InterceptingCall = exports.RequesterBuilder = exports.ListenerBuilder = exports.InterceptorConfigurationError = void 0;\n\nconst metadata_1 = require(\"./metadata\");\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst constants_1 = require(\"./constants\");\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\n\n\nclass InterceptorConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n\n}\n\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\n\nclass ListenerBuilder {\n  constructor() {\n    this.metadata = undefined;\n    this.message = undefined;\n    this.status = undefined;\n  }\n\n  withOnReceiveMetadata(onReceiveMetadata) {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage) {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus) {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build() {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status\n    };\n  }\n\n}\n\nexports.ListenerBuilder = ListenerBuilder;\n\nclass RequesterBuilder {\n  constructor() {\n    this.start = undefined;\n    this.message = undefined;\n    this.halfClose = undefined;\n    this.cancel = undefined;\n  }\n\n  withStart(start) {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage) {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose) {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel) {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build() {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel\n    };\n  }\n\n}\n\nexports.RequesterBuilder = RequesterBuilder;\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\n\nconst defaultListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  }\n};\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\n\nconst defaultRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: next => {\n    next();\n  },\n  cancel: next => {\n    next();\n  }\n};\n\nclass InterceptingCall {\n  constructor(nextCall, requester) {\n    var _a, _b, _c, _d;\n\n    this.nextCall = nextCall;\n    /**\n     * Indicates that metadata has been passed to the requester's start\n     * method but it has not been passed to the corresponding next callback\n     */\n\n    this.processingMetadata = false;\n    /**\n     * Message context for a pending message that is waiting for\n     */\n\n    this.pendingMessageContext = null;\n    /**\n     * Indicates that a message has been passed to the requester's sendMessage\n     * method but it has not been passed to the corresponding next callback\n     */\n\n    this.processingMessage = false;\n    /**\n     * Indicates that a status was received but could not be propagated because\n     * a message was still being processed.\n     */\n\n    this.pendingHalfClose = false;\n\n    if (requester) {\n      this.requester = {\n        start: (_a = requester.start) !== null && _a !== void 0 ? _a : defaultRequester.start,\n        sendMessage: (_b = requester.sendMessage) !== null && _b !== void 0 ? _b : defaultRequester.sendMessage,\n        halfClose: (_c = requester.halfClose) !== null && _c !== void 0 ? _c : defaultRequester.halfClose,\n        cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status, details) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n\n  processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n\n  start(metadata, interceptingListener) {\n    var _a, _b, _c, _d, _e, _f;\n\n    const fullInterceptingListener = {\n      onReceiveMetadata: (_b = (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(interceptingListener)) !== null && _b !== void 0 ? _b : metadata => {},\n      onReceiveMessage: (_d = (_c = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c === void 0 ? void 0 : _c.bind(interceptingListener)) !== null && _d !== void 0 ? _d : message => {},\n      onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : status => {}\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      var _a, _b, _c;\n\n      this.processingMetadata = false;\n      let finalInterceptingListener;\n\n      if (call_stream_1.isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener = {\n          onReceiveMetadata: (_a = listener.onReceiveMetadata) !== null && _a !== void 0 ? _a : defaultListener.onReceiveMetadata,\n          onReceiveMessage: (_b = listener.onReceiveMessage) !== null && _b !== void 0 ? _b : defaultListener.onReceiveMessage,\n          onReceiveStatus: (_c = listener.onReceiveStatus) !== null && _c !== void 0 ? _c : defaultListener.onReceiveStatus\n        };\n        finalInterceptingListener = new call_stream_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);\n      }\n\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  sendMessageWithContext(context, message) {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, finalMessage => {\n      this.processingMessage = false;\n\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n\n  startRead() {\n    this.nextCall.startRead();\n  }\n\n  halfClose() {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n\n  setCredentials(credentials) {\n    this.nextCall.setCredentials(credentials);\n  }\n\n}\n\nexports.InterceptingCall = InterceptingCall;\n\nfunction getCall(channel, path, options) {\n  var _a, _b;\n\n  const deadline = (_a = options.deadline) !== null && _a !== void 0 ? _a : Infinity;\n  const host = options.host;\n  const parent = (_b = options.parent) !== null && _b !== void 0 ? _b : null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n\n  return call;\n}\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\n\n\nclass BaseInterceptingCall {\n  constructor(call, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition) {\n    this.call = call;\n    this.methodDefinition = methodDefinition;\n  }\n\n  cancelWithStatus(status, details) {\n    this.call.cancelWithStatus(status, details);\n  }\n\n  getPeer() {\n    return this.call.getPeer();\n  }\n\n  setCredentials(credentials) {\n    this.call.setCredentials(credentials);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  sendMessageWithContext(context, message) {\n    let serialized;\n\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${e.message}`);\n      return;\n    }\n\n    this.call.sendMessageWithContext(context, serialized);\n  } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  sendMessage(message) {\n    this.sendMessageWithContext({}, message);\n  }\n\n  start(metadata, interceptingListener) {\n    let readError = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: metadata => {\n        var _a;\n\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, metadata);\n      },\n      onReceiveMessage: message => {\n        var _a; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n        let deserialized;\n\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: constants_1.Status.INTERNAL,\n            details: `Response message parsing error: ${e.message}`,\n            metadata: new metadata_1.Metadata()\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n\n        (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, deserialized);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n\n        if (readError) {\n          (_a = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a === void 0 ? void 0 : _a.call(interceptingListener, readError);\n        } else {\n          (_b = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(interceptingListener, status);\n        }\n      }\n    });\n  }\n\n  startRead() {\n    this.call.startRead();\n  }\n\n  halfClose() {\n    this.call.halfClose();\n  }\n\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\n\n\nclass BaseUnaryInterceptingCall extends BaseInterceptingCall {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call, methodDefinition) {\n    super(call, methodDefinition);\n  }\n\n  start(metadata, listener) {\n    var _a, _b;\n\n    let receivedMessage = false;\n    const wrapperListener = {\n      onReceiveMetadata: (_b = (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a === void 0 ? void 0 : _a.bind(listener)) !== null && _b !== void 0 ? _b : metadata => {},\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: message => {\n        var _a;\n\n        receivedMessage = true;\n        (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, message);\n      },\n      onReceiveStatus: status => {\n        var _a, _b;\n\n        if (!receivedMessage) {\n          (_a = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a === void 0 ? void 0 : _a.call(listener, null);\n        }\n\n        (_b = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b === void 0 ? void 0 : _b.call(listener, status);\n      }\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n\n}\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\n\n\nclass BaseStreamingInterceptingCall extends BaseInterceptingCall {}\n\nfunction getBottomInterceptingCall(channel, options, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition) {\n  const call = getCall(channel, methodDefinition.path, options);\n\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nfunction getInterceptingCall(interceptorArgs, // eslint-disable-next-line @typescript-eslint/no-explicit-any\nmethodDefinition, options, channel) {\n  if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n\n  if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {\n    throw new InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n\n  let interceptors = []; // Interceptors passed to the call override interceptors passed to the client constructor\n\n  if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {\n    interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor); // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map(provider => provider(methodDefinition))).filter(interceptor => interceptor); // Filter out falsy values when providers return nothing\n  }\n\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n\n  const getCall = interceptors.reduceRight((nextCall, nextInterceptor) => {\n    return currentOptions => nextInterceptor(currentOptions, nextCall);\n  }, finalOptions => getBottomInterceptingCall(channel, finalOptions, methodDefinition));\n  return getCall(interceptorOptions);\n}\n\nexports.getInterceptingCall = getInterceptingCall;","map":{"version":3,"sources":["C:\\react\\quiz\\node_modules\\@grpc\\grpc-js\\src\\client-interceptors.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport { Metadata } from './metadata';\nimport {\n  StatusObject,\n  Listener,\n  MetadataListener,\n  MessageListener,\n  StatusListener,\n  FullListener,\n  InterceptingListener,\n  InterceptingListenerImpl,\n  isInterceptingListener,\n  MessageContext,\n  Call,\n} from './call-stream';\nimport { Status } from './constants';\nimport { Channel } from './channel';\nimport { CallOptions } from './client';\nimport { CallCredentials } from './call-credentials';\nimport { ClientMethodDefinition } from './make-client';\n\n/**\n * Error class associated with passing both interceptors and interceptor\n * providers to a client constructor or as call options.\n */\nexport class InterceptorConfigurationError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'InterceptorConfigurationError';\n    Error.captureStackTrace(this, InterceptorConfigurationError);\n  }\n}\n\nexport interface MetadataRequester {\n  (\n    metadata: Metadata,\n    listener: InterceptingListener,\n    next: (\n      metadata: Metadata,\n      listener: InterceptingListener | Listener\n    ) => void\n  ): void;\n}\n\nexport interface MessageRequester {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (message: any, next: (message: any) => void): void;\n}\n\nexport interface CloseRequester {\n  (next: () => void): void;\n}\n\nexport interface CancelRequester {\n  (next: () => void): void;\n}\n\n/**\n * An object with methods for intercepting and modifying outgoing call operations.\n */\nexport interface FullRequester {\n  start: MetadataRequester;\n  sendMessage: MessageRequester;\n  halfClose: CloseRequester;\n  cancel: CancelRequester;\n}\n\nexport type Requester = Partial<FullRequester>;\n\nexport class ListenerBuilder {\n  private metadata: MetadataListener | undefined = undefined;\n  private message: MessageListener | undefined = undefined;\n  private status: StatusListener | undefined = undefined;\n\n  withOnReceiveMetadata(onReceiveMetadata: MetadataListener): this {\n    this.metadata = onReceiveMetadata;\n    return this;\n  }\n\n  withOnReceiveMessage(onReceiveMessage: MessageListener): this {\n    this.message = onReceiveMessage;\n    return this;\n  }\n\n  withOnReceiveStatus(onReceiveStatus: StatusListener): this {\n    this.status = onReceiveStatus;\n    return this;\n  }\n\n  build(): Listener {\n    return {\n      onReceiveMetadata: this.metadata,\n      onReceiveMessage: this.message,\n      onReceiveStatus: this.status,\n    };\n  }\n}\n\nexport class RequesterBuilder {\n  private start: MetadataRequester | undefined = undefined;\n  private message: MessageRequester | undefined = undefined;\n  private halfClose: CloseRequester | undefined = undefined;\n  private cancel: CancelRequester | undefined = undefined;\n\n  withStart(start: MetadataRequester): this {\n    this.start = start;\n    return this;\n  }\n\n  withSendMessage(sendMessage: MessageRequester): this {\n    this.message = sendMessage;\n    return this;\n  }\n\n  withHalfClose(halfClose: CloseRequester): this {\n    this.halfClose = halfClose;\n    return this;\n  }\n\n  withCancel(cancel: CancelRequester): this {\n    this.cancel = cancel;\n    return this;\n  }\n\n  build(): Requester {\n    return {\n      start: this.start,\n      sendMessage: this.message,\n      halfClose: this.halfClose,\n      cancel: this.cancel,\n    };\n  }\n}\n\n/**\n * A Listener with a default pass-through implementation of each method. Used\n * for filling out Listeners with some methods omitted.\n */\nconst defaultListener: FullListener = {\n  onReceiveMetadata: (metadata, next) => {\n    next(metadata);\n  },\n  onReceiveMessage: (message, next) => {\n    next(message);\n  },\n  onReceiveStatus: (status, next) => {\n    next(status);\n  },\n};\n\n/**\n * A Requester with a default pass-through implementation of each method. Used\n * for filling out Requesters with some methods omitted.\n */\nconst defaultRequester: FullRequester = {\n  start: (metadata, listener, next) => {\n    next(metadata, listener);\n  },\n  sendMessage: (message, next) => {\n    next(message);\n  },\n  halfClose: (next) => {\n    next();\n  },\n  cancel: (next) => {\n    next();\n  },\n};\n\nexport interface InterceptorOptions extends CallOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  method_definition: ClientMethodDefinition<any, any>;\n}\n\nexport interface InterceptingCallInterface {\n  cancelWithStatus(status: Status, details: string): void;\n  getPeer(): string;\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void;\n  startRead(): void;\n  halfClose(): void;\n\n  setCredentials(credentials: CallCredentials): void;\n}\n\nexport class InterceptingCall implements InterceptingCallInterface {\n  /**\n   * The requester that this InterceptingCall uses to modify outgoing operations\n   */\n  private requester: FullRequester;\n  /**\n   * Indicates that metadata has been passed to the requester's start\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMetadata = false;\n  /**\n   * Message context for a pending message that is waiting for\n   */\n  private pendingMessageContext: MessageContext | null = null;\n  private pendingMessage: any;\n  /**\n   * Indicates that a message has been passed to the requester's sendMessage\n   * method but it has not been passed to the corresponding next callback\n   */\n  private processingMessage = false;\n  /**\n   * Indicates that a status was received but could not be propagated because\n   * a message was still being processed.\n   */\n  private pendingHalfClose = false;\n  constructor(\n    private nextCall: InterceptingCallInterface,\n    requester?: Requester\n  ) {\n    if (requester) {\n      this.requester = {\n        start: requester.start ?? defaultRequester.start,\n        sendMessage: requester.sendMessage ?? defaultRequester.sendMessage,\n        halfClose: requester.halfClose ?? defaultRequester.halfClose,\n        cancel: requester.cancel ?? defaultRequester.cancel,\n      };\n    } else {\n      this.requester = defaultRequester;\n    }\n  }\n\n  cancelWithStatus(status: Status, details: string) {\n    this.requester.cancel(() => {\n      this.nextCall.cancelWithStatus(status, details);\n    });\n  }\n\n  getPeer() {\n    return this.nextCall.getPeer();\n  }\n\n  private processPendingMessage() {\n    if (this.pendingMessageContext) {\n      this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);\n      this.pendingMessageContext = null;\n      this.pendingMessage = null;\n    }\n  }\n\n  private processPendingHalfClose() {\n    if (this.pendingHalfClose) {\n      this.nextCall.halfClose();\n    }\n  }\n\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    const fullInterceptingListener: InterceptingListener = {\n      onReceiveMetadata:\n        interceptingListener?.onReceiveMetadata?.bind(interceptingListener) ??\n        ((metadata) => {}),\n      onReceiveMessage:\n        interceptingListener?.onReceiveMessage?.bind(interceptingListener) ??\n        ((message) => {}),\n      onReceiveStatus:\n        interceptingListener?.onReceiveStatus?.bind(interceptingListener) ??\n        ((status) => {}),\n    };\n    this.processingMetadata = true;\n    this.requester.start(metadata, fullInterceptingListener, (md, listener) => {\n      this.processingMetadata = false;\n      let finalInterceptingListener: InterceptingListener;\n      if (isInterceptingListener(listener)) {\n        finalInterceptingListener = listener;\n      } else {\n        const fullListener: FullListener = {\n          onReceiveMetadata:\n            listener.onReceiveMetadata ?? defaultListener.onReceiveMetadata,\n          onReceiveMessage:\n            listener.onReceiveMessage ?? defaultListener.onReceiveMessage,\n          onReceiveStatus:\n            listener.onReceiveStatus ?? defaultListener.onReceiveStatus,\n        };\n        finalInterceptingListener = new InterceptingListenerImpl(\n          fullListener,\n          fullInterceptingListener\n        );\n      }\n      this.nextCall.start(md, finalInterceptingListener);\n      this.processPendingMessage();\n      this.processPendingHalfClose();\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    this.processingMessage = true;\n    this.requester.sendMessage(message, (finalMessage) => {\n      this.processingMessage = false;\n      if (this.processingMetadata) {\n        this.pendingMessageContext = context;\n        this.pendingMessage = message;\n      } else {\n        this.nextCall.sendMessageWithContext(context, finalMessage);\n        this.processPendingHalfClose();\n      }\n    });\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any): void {\n    this.sendMessageWithContext({}, message);\n  }\n  startRead(): void {\n    this.nextCall.startRead();\n  }\n  halfClose(): void {\n    this.requester.halfClose(() => {\n      if (this.processingMetadata || this.processingMessage) {\n        this.pendingHalfClose = true;\n      } else {\n        this.nextCall.halfClose();\n      }\n    });\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.nextCall.setCredentials(credentials);\n  }\n}\n\nfunction getCall(channel: Channel, path: string, options: CallOptions): Call {\n  const deadline = options.deadline ?? Infinity;\n  const host = options.host;\n  const parent = options.parent ?? null;\n  const propagateFlags = options.propagate_flags;\n  const credentials = options.credentials;\n  const call = channel.createCall(path, deadline, host, parent, propagateFlags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\n/**\n * InterceptingCall implementation that directly owns the underlying Call\n * object and handles serialization and deseraizliation.\n */\nclass BaseInterceptingCall implements InterceptingCallInterface {\n  constructor(\n    protected call: Call,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    protected methodDefinition: ClientMethodDefinition<any, any>\n  ) {}\n  cancelWithStatus(status: Status, details: string): void {\n    this.call.cancelWithStatus(status, details);\n  }\n  getPeer(): string {\n    return this.call.getPeer();\n  }\n  setCredentials(credentials: CallCredentials): void {\n    this.call.setCredentials(credentials);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessageWithContext(context: MessageContext, message: any): void {\n    let serialized: Buffer;\n    try {\n      serialized = this.methodDefinition.requestSerialize(message);\n    } catch (e) {\n      this.call.cancelWithStatus(\n        Status.INTERNAL,\n        `Request message serialization failure: ${e.message}`\n      );\n      return;\n    }\n    this.call.sendMessageWithContext(context, serialized);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  sendMessage(message: any) {\n    this.sendMessageWithContext({}, message);\n  }\n  start(\n    metadata: Metadata,\n    interceptingListener?: Partial<InterceptingListener>\n  ): void {\n    let readError: StatusObject | null = null;\n    this.call.start(metadata, {\n      onReceiveMetadata: (metadata) => {\n        interceptingListener?.onReceiveMetadata?.(metadata);\n      },\n      onReceiveMessage: (message) => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let deserialized: any;\n        try {\n          deserialized = this.methodDefinition.responseDeserialize(message);\n        } catch (e) {\n          readError = {\n            code: Status.INTERNAL,\n            details: `Response message parsing error: ${e.message}`,\n            metadata: new Metadata(),\n          };\n          this.call.cancelWithStatus(readError.code, readError.details);\n          return;\n        }\n        interceptingListener?.onReceiveMessage?.(deserialized);\n      },\n      onReceiveStatus: (status) => {\n        if (readError) {\n          interceptingListener?.onReceiveStatus?.(readError);\n        } else {\n          interceptingListener?.onReceiveStatus?.(status);\n        }\n      },\n    });\n  }\n  startRead() {\n    this.call.startRead();\n  }\n  halfClose(): void {\n    this.call.halfClose();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with unary\n * responses.\n */\nclass BaseUnaryInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(call: Call, methodDefinition: ClientMethodDefinition<any, any>) {\n    super(call, methodDefinition);\n  }\n  start(metadata: Metadata, listener?: Partial<InterceptingListener>): void {\n    let receivedMessage = false;\n    const wrapperListener: InterceptingListener = {\n      onReceiveMetadata:\n        listener?.onReceiveMetadata?.bind(listener) ?? ((metadata) => {}),\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      onReceiveMessage: (message: any) => {\n        receivedMessage = true;\n        listener?.onReceiveMessage?.(message);\n      },\n      onReceiveStatus: (status: StatusObject) => {\n        if (!receivedMessage) {\n          listener?.onReceiveMessage?.(null);\n        }\n        listener?.onReceiveStatus?.(status);\n      },\n    };\n    super.start(metadata, wrapperListener);\n    this.call.startRead();\n  }\n}\n\n/**\n * BaseInterceptingCall with special-cased behavior for methods with streaming\n * responses.\n */\nclass BaseStreamingInterceptingCall\n  extends BaseInterceptingCall\n  implements InterceptingCallInterface {}\n\nfunction getBottomInterceptingCall(\n  channel: Channel,\n  options: InterceptorOptions,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>\n) {\n  const call = getCall(channel, methodDefinition.path, options);\n  if (methodDefinition.responseStream) {\n    return new BaseStreamingInterceptingCall(call, methodDefinition);\n  } else {\n    return new BaseUnaryInterceptingCall(call, methodDefinition);\n  }\n}\n\nexport interface NextCall {\n  (options: InterceptorOptions): InterceptingCallInterface;\n}\n\nexport interface Interceptor {\n  (options: InterceptorOptions, nextCall: NextCall): InterceptingCall;\n}\n\nexport interface InterceptorProvider {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  (methodDefinition: ClientMethodDefinition<any, any>): Interceptor;\n}\n\nexport interface InterceptorArguments {\n  clientInterceptors: Interceptor[];\n  clientInterceptorProviders: InterceptorProvider[];\n  callInterceptors: Interceptor[];\n  callInterceptorProviders: InterceptorProvider[];\n}\n\nexport function getInterceptingCall(\n  interceptorArgs: InterceptorArguments,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodDefinition: ClientMethodDefinition<any, any>,\n  options: CallOptions,\n  channel: Channel\n): InterceptingCallInterface {\n  if (\n    interceptorArgs.clientInterceptors.length > 0 &&\n    interceptorArgs.clientInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as options ' +\n        'to the client constructor. Only one of these is allowed.'\n    );\n  }\n  if (\n    interceptorArgs.callInterceptors.length > 0 &&\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    throw new InterceptorConfigurationError(\n      'Both interceptors and interceptor_providers were passed as call ' +\n        'options. Only one of these is allowed.'\n    );\n  }\n  let interceptors: Interceptor[] = [];\n  // Interceptors passed to the call override interceptors passed to the client constructor\n  if (\n    interceptorArgs.callInterceptors.length > 0 ||\n    interceptorArgs.callInterceptorProviders.length > 0\n  ) {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.callInterceptors,\n        interceptorArgs.callInterceptorProviders.map((provider) =>\n          provider(methodDefinition)\n        )\n      )\n      .filter((interceptor) => interceptor);\n    // Filter out falsy values when providers return nothing\n  } else {\n    interceptors = ([] as Interceptor[])\n      .concat(\n        interceptorArgs.clientInterceptors,\n        interceptorArgs.clientInterceptorProviders.map((provider) =>\n          provider(methodDefinition)\n        )\n      )\n      .filter((interceptor) => interceptor);\n    // Filter out falsy values when providers return nothing\n  }\n  const interceptorOptions = Object.assign({}, options, {\n    method_definition: methodDefinition,\n  });\n  /* For each interceptor in the list, the nextCall function passed to it is\n   * based on the next interceptor in the list, using a nextCall function\n   * constructed with the following interceptor in the list, and so on. The\n   * initialValue, which is effectively at the end of the list, is a nextCall\n   * function that invokes getBottomInterceptingCall, the result of which\n   * handles (de)serialization and also gets the underlying call from the\n   * channel. */\n  const getCall: NextCall = interceptors.reduceRight<NextCall>(\n    (nextCall: NextCall, nextInterceptor: Interceptor) => {\n      return (currentOptions) => nextInterceptor(currentOptions, nextCall);\n    },\n    (finalOptions: InterceptorOptions) =>\n      getBottomInterceptingCall(channel, finalOptions, methodDefinition)\n  );\n  return getCall(interceptorOptions);\n}\n"]},"metadata":{},"sourceType":"script"}