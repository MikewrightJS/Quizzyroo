{"ast":null,"code":"'use strict';\n\nvar net = require('net'),\n    tls = require('tls'),\n    http = require('http'),\n    https = require('https'),\n    events = require('events'),\n    assert = require('assert'),\n    util = require('util');\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  return agent;\n}\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n  self.on('free', function onFree(socket, host, port) {\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n\n      if (pending.host === host && pending.port === port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\n\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port) {\n  var self = this;\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push({\n      host: host,\n      port: port,\n      request: req\n    });\n    return;\n  } // If we are under maxSockets create a new one.\n\n\n  self.createSocket({\n    host: host,\n    port: port,\n    request: req\n  }, function (socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, host, port);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket();\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false\n  });\n\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' + new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n\n  connectReq.once('response', onResponse); // for v0.6\n\n  connectReq.once('upgrade', onUpgrade); // for v0.6\n\n  connectReq.once('connect', onConnect); // for v0.7 or later\n\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function () {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode === 200) {\n      assert.equal(head.length, 0);\n      debug('tunneling connection has established');\n      self.sockets[self.sockets.indexOf(placeholder)] = socket;\n      cb(socket);\n    } else {\n      debug('tunneling socket could not be established, statusCode=%d', res.statusCode);\n      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n    }\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n    debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket);\n  if (pos === -1) return;\n  this.sockets.splice(pos, 1);\n  var pending = this.requests.shift();\n\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function (socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function (socket) {\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, mergeOptions({}, self.options, {\n      servername: options.host,\n      socket: socket\n    }));\n    cb(secureSocket);\n  });\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n\n  return target;\n}\n\nvar debug;\n\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments);\n\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n\n    console.error.apply(console, args);\n  };\n} else {\n  debug = function () {};\n}\n\nexports.debug = debug; // for test","map":{"version":3,"sources":["C:/react/quiz/node_modules/tunnel-agent/index.js"],"names":["net","require","tls","http","https","events","assert","util","exports","httpOverHttp","httpsOverHttp","httpOverHttps","httpsOverHttps","options","agent","TunnelingAgent","request","createSocket","createSecureSocket","self","proxyOptions","proxy","maxSockets","Agent","defaultMaxSockets","requests","sockets","on","onFree","socket","host","port","i","len","length","pending","splice","onSocket","destroy","removeSocket","inherits","EventEmitter","prototype","addRequest","req","push","onCloseOrRemove","emit","err","removeListener","cb","placeholder","connectOptions","mergeOptions","method","path","proxyAuth","headers","Buffer","toString","debug","connectReq","useChunkedEncodingByDefault","once","onResponse","onUpgrade","onConnect","onError","end","res","upgrade","head","process","nextTick","removeAllListeners","statusCode","equal","indexOf","error","Error","code","cause","message","stack","pos","shift","call","secureSocket","connect","servername","target","arguments","overrides","keys","Object","j","keyLen","k","undefined","env","NODE_DEBUG","test","args","Array","slice","unshift","console","apply"],"mappings":"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","sourcesContent":["'use strict'\n\nvar net = require('net')\n  , tls = require('tls')\n  , http = require('http')\n  , https = require('https')\n  , events = require('events')\n  , assert = require('assert')\n  , util = require('util')\n  ;\n\nexports.httpOverHttp = httpOverHttp\nexports.httpsOverHttp = httpsOverHttp\nexports.httpOverHttps = httpOverHttps\nexports.httpsOverHttps = httpsOverHttps\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  return agent\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = http.request\n  agent.createSocket = createSecureSocket\n  return agent\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  return agent\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options)\n  agent.request = https.request\n  agent.createSocket = createSecureSocket\n  return agent\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.proxyOptions = self.options.proxy || {}\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets\n  self.requests = []\n  self.sockets = []\n\n  self.on('free', function onFree(socket, host, port) {\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i]\n      if (pending.host === host && pending.port === port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1)\n        pending.request.onSocket(socket)\n        return\n      }\n    }\n    socket.destroy()\n    self.removeSocket(socket)\n  })\n}\nutil.inherits(TunnelingAgent, events.EventEmitter)\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port) {\n  var self = this\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push({host: host, port: port, request: req})\n    return\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket({host: host, port: port, request: req}, function(socket) {\n    socket.on('free', onFree)\n    socket.on('close', onCloseOrRemove)\n    socket.on('agentRemove', onCloseOrRemove)\n    req.onSocket(socket)\n\n    function onFree() {\n      self.emit('free', socket, host, port)\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket()\n      socket.removeListener('free', onFree)\n      socket.removeListener('close', onCloseOrRemove)\n      socket.removeListener('agentRemove', onCloseOrRemove)\n    }\n  })\n}\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this\n  var placeholder = {}\n  self.sockets.push(placeholder)\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, \n    { method: 'CONNECT'\n    , path: options.host + ':' + options.port\n    , agent: false\n    }\n  )\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {}\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64')\n  }\n\n  debug('making CONNECT request')\n  var connectReq = self.request(connectOptions)\n  connectReq.useChunkedEncodingByDefault = false // for v0.6\n  connectReq.once('response', onResponse) // for v0.6\n  connectReq.once('upgrade', onUpgrade)   // for v0.6\n  connectReq.once('connect', onConnect)   // for v0.7 or later\n  connectReq.once('error', onError)\n  connectReq.end()\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head)\n    })\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners()\n    socket.removeAllListeners()\n\n    if (res.statusCode === 200) {\n      assert.equal(head.length, 0)\n      debug('tunneling connection has established')\n      self.sockets[self.sockets.indexOf(placeholder)] = socket\n      cb(socket)\n    } else {\n      debug('tunneling socket could not be established, statusCode=%d', res.statusCode)\n      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode)\n      error.code = 'ECONNRESET'\n      options.request.emit('error', error)\n      self.removeSocket(placeholder)\n    }\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners()\n\n    debug('tunneling socket could not be established, cause=%s\\n', cause.message, cause.stack)\n    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message)\n    error.code = 'ECONNRESET'\n    options.request.emit('error', error)\n    self.removeSocket(placeholder)\n  }\n}\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) return\n  \n  this.sockets.splice(pos, 1)\n\n  var pending = this.requests.shift()\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket)\n    })\n  }\n}\n\nfunction createSecureSocket(options, cb) {\n  var self = this\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, mergeOptions({}, self.options, \n      { servername: options.host\n      , socket: socket\n      }\n    ))\n    cb(secureSocket)\n  })\n}\n\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i]\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides)\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j]\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k]\n        }\n      }\n    }\n  }\n  return target\n}\n\n\nvar debug\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments)\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0]\n    } else {\n      args.unshift('TUNNEL:')\n    }\n    console.error.apply(console, args)\n  }\n} else {\n  debug = function() {}\n}\nexports.debug = debug // for test\n"]},"metadata":{},"sourceType":"script"}