{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Server routines\nrequire('defaultable')(module, {}, function (module, exports, DEFS, require) {\n  var net = require('net');\n\n  var util = require('util');\n\n  var dgram = require('dgram');\n\n  var events = require('events');\n\n  var Message = require('./message');\n\n  var convenient = require('./convenient');\n\n  module.exports = createServer;\n\n  function createServer(handler) {\n    return new Server(handler);\n  }\n\n  util.inherits(Server, events.EventEmitter);\n\n  function Server(handler) {\n    var self = this;\n    events.EventEmitter.call(self);\n    self.log = console;\n    self.zones = {};\n    if (handler) self.on('request', handler);\n    self.udp = dgram.createSocket('udp4');\n    self.tcp = net.createServer();\n    self.udp.on('close', function () {\n      self.close();\n    });\n    self.tcp.on('close', function () {\n      self.close();\n    });\n    self.udp.on('error', function (er) {\n      self.emit('error', er);\n    });\n    self.tcp.on('error', function (er) {\n      self.emit('error', er);\n    });\n    self.tcp.on('connection', function (connection) {\n      self.on_tcp_connection(connection);\n    });\n    self.udp.on('message', function (msg, rinfo) {\n      self.on_udp(msg, rinfo);\n    });\n    var listening = {\n      'tcp': false,\n      'udp': false\n    };\n    self.udp.once('listening', function () {\n      listening.udp = true;\n      if (listening.tcp) self.emit('listening');\n    });\n    self.tcp.once('listening', function () {\n      listening.tcp = true;\n      if (listening.udp) self.emit('listening');\n    });\n  }\n\n  Server.prototype.zone = function (zone, server, admin, serial, refresh, retry, expire, ttl) {\n    var self = this,\n        record = zone;\n    if (typeof record != 'object') record = {\n      'class': 'IN',\n      'type': 'SOA',\n      'name': zone,\n      'data': {\n        'mname': server,\n        'rname': admin,\n        'serial': convenient.serial(serial),\n        'refresh': convenient.seconds(refresh),\n        'retry': convenient.seconds(retry),\n        'expire': convenient.seconds(expire),\n        'ttl': convenient.seconds(ttl || 0)\n      }\n    };\n    self.zones[record.name] = record;\n    return self;\n  };\n\n  Server.prototype.listen = function (port, ip, callback) {\n    var self = this;\n\n    if (typeof ip === 'function') {\n      callback = ip;\n      ip = null;\n    }\n\n    self.port = port;\n    self.ip = ip || '0.0.0.0';\n    if (typeof callback === 'function') self.on('listening', callback);\n    self.udp.bind(port, ip);\n    self.tcp.listen(port, ip);\n    return self;\n  };\n\n  Server.prototype.close = function () {\n    var self = this;\n    if (self.udp._receiving) self.udp.close();\n    if (self.tcp._handle) self.tcp.close(function () {\n      self.emit('close');\n    });\n  };\n\n  Server.prototype.unref = function () {\n    this.udp.unref();\n    this.tcp.unref();\n  };\n\n  Server.prototype.ref = function () {\n    this.udp.ref();\n    this.tcp.ref();\n  };\n\n  Server.prototype.on_tcp_connection = function (connection) {\n    var self = this;\n    var length = null,\n        bufs = [];\n    connection.type = 'tcp';\n    connection.server = self;\n    connection.on('data', function (data) {\n      bufs.push(data);\n      var bytes_received = bufs.reduce(function (state, buf) {\n        return state + buf.length;\n      }, 0);\n\n      if (length === null && bytes_received >= 2) {\n        var so_far = Buffer.concat(bufs); // Flatten them all together, it's probably not much data.\n\n        length = so_far.readUInt16BE(0);\n        bufs = [so_far.slice(2)];\n      }\n\n      if (length !== null && bytes_received == 2 + length) {\n        // All of the data (plus the 2-byte length prefix) is received.\n        var data = Buffer.concat(bufs),\n            req = new Request(data, connection),\n            res = new Response(data, connection);\n        self.emit('request', req, res);\n      }\n    });\n  };\n\n  Server.prototype.on_udp = function (data, rinfo) {\n    var self = this; // Provide something that feels like a net.Socket, which in turn feels like the http API.\n\n    var connection = {\n      'type': self.udp.type,\n      'remoteAddress': rinfo.address,\n      'remotePort': rinfo.port,\n      'server': self,\n      'send': function () {\n        self.udp.send.apply(self.udp, arguments);\n      },\n      'destroy': function () {},\n      'end': function () {}\n    };\n    var req = new Request(data, connection),\n        res = new Response(data, connection);\n    self.emit('request', req, res);\n  };\n\n  util.inherits(Request, Message);\n\n  function Request(data, connection) {\n    var self = this;\n    Message.call(self, data);\n    self.connection = connection;\n  }\n\n  Request.prototype.toJSON = function () {\n    var self = this;\n    var obj = {};\n    Object.keys(self).forEach(function (key) {\n      if (key != 'connection') obj[key] = self[key];\n    });\n    return obj;\n  };\n\n  util.inherits(Response, Message);\n\n  function Response(data, connection) {\n    var self = this;\n    Message.call(self, data);\n    self.question = self.question || [];\n    self.answer = self.answer || [];\n    self.authority = self.authority || [];\n    self.additional = self.additional || [];\n    self.connection = connection;\n    convenient.init_response(self);\n  }\n\n  Response.prototype.toJSON = Request.prototype.toJSON;\n\n  Response.prototype.end = function (value) {\n    var self = this;\n    var msg = convenient.final_response(self, value),\n        data = msg.toBinary();\n    if (self.connection.type == 'udp4' && data.length > 512) return self.emit('error', 'UDP responses greater than 512 bytes not yet implemented');else if (self.connection.type == 'udp4') self.connection.send(data, 0, data.length, self.connection.remotePort, self.connection.remoteAddress, function (er) {\n      if (er) self.emit('error', er);\n    });else if (self.connection.type == 'tcp') {\n      // Add the data length prefix.\n      var length = data.length;\n      data = Buffer.concat([new Buffer([length >> 8, length & 255]), data]);\n      self.connection.end(data, function (er) {\n        if (er) self.emit('error', er);\n      });\n    } else self.emit('error', new Error('Unknown connection type: ' + self.connection.type));\n  };\n}); // defaultable","map":{"version":3,"sources":["C:/react/quiz/node_modules/hbo-dnsd/server.js"],"names":["require","module","exports","DEFS","net","util","dgram","events","Message","convenient","createServer","handler","Server","inherits","EventEmitter","self","call","log","console","zones","on","udp","createSocket","tcp","close","er","emit","connection","on_tcp_connection","msg","rinfo","on_udp","listening","once","prototype","zone","server","admin","serial","refresh","retry","expire","ttl","record","seconds","name","listen","port","ip","callback","bind","_receiving","_handle","unref","ref","length","bufs","type","data","push","bytes_received","reduce","state","buf","so_far","Buffer","concat","readUInt16BE","slice","req","Request","res","Response","address","send","apply","arguments","toJSON","obj","Object","keys","forEach","key","question","answer","authority","additional","init_response","end","value","final_response","toBinary","remotePort","remoteAddress","Error"],"mappings":"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","sourcesContent":["// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Server routines\n\nrequire('defaultable')(module,\n  {\n  }, function(module, exports, DEFS, require) {\n\nvar net = require('net')\nvar util = require('util')\nvar dgram = require('dgram')\nvar events = require('events')\n\nvar Message = require('./message')\nvar convenient = require('./convenient')\n\nmodule.exports = createServer\n\nfunction createServer(handler) {\n  return new Server(handler)\n}\n\n\nutil.inherits(Server, events.EventEmitter)\nfunction Server (handler) {\n  var self = this\n  events.EventEmitter.call(self)\n\n  self.log = console\n  self.zones = {}\n\n  if(handler)\n    self.on('request', handler)\n\n  self.udp = dgram.createSocket('udp4')\n  self.tcp = net.createServer()\n\n  self.udp.on('close', function() { self.close() })\n  self.tcp.on('close', function() { self.close() })\n\n  self.udp.on('error', function(er) { self.emit('error', er) })\n  self.tcp.on('error', function(er) { self.emit('error', er) })\n\n  self.tcp.on('connection', function(connection) { self.on_tcp_connection(connection) })\n  self.udp.on('message', function(msg, rinfo) { self.on_udp(msg, rinfo) })\n\n  var listening = {'tcp':false, 'udp':false}\n  self.udp.once('listening', function() {\n    listening.udp = true\n    if(listening.tcp)\n      self.emit('listening')\n  })\n  self.tcp.once('listening', function() {\n    listening.tcp = true\n    if(listening.udp)\n      self.emit('listening')\n  })\n}\n\nServer.prototype.zone = function(zone, server, admin, serial, refresh, retry, expire, ttl) {\n  var self = this\n    , record = zone\n\n  if(typeof record != 'object')\n    record = { 'class': 'IN'\n             , 'type' : 'SOA'\n             , 'name' : zone\n             , 'data' : { 'mname': server\n                        , 'rname': admin\n                        , 'serial': convenient.serial(serial)\n                        , 'refresh': convenient.seconds(refresh)\n                        , 'retry'  : convenient.seconds(retry)\n                        , 'expire' : convenient.seconds(expire)\n                        , 'ttl'    : convenient.seconds(ttl || 0)\n                        }\n             }\n\n  self.zones[record.name] = record\n  return self\n}\n\nServer.prototype.listen = function(port, ip, callback) {\n  var self = this\n\n  if(typeof ip === 'function') {\n    callback = ip\n    ip = null\n  }\n\n  self.port = port\n  self.ip   = ip || '0.0.0.0'\n\n  if(typeof callback === 'function')\n    self.on('listening', callback)\n\n  self.udp.bind(port, ip)\n  self.tcp.listen(port, ip)\n\n  return self\n}\n\nServer.prototype.close = function() {\n  var self = this\n\n  if(self.udp._receiving)\n    self.udp.close()\n\n  if(self.tcp._handle)\n    self.tcp.close(function() {\n      self.emit('close')\n    })\n}\n\nServer.prototype.unref = function() {\n  this.udp.unref()\n  this.tcp.unref()\n}\n\nServer.prototype.ref = function() {\n  this.udp.ref()\n  this.tcp.ref()\n}\n\nServer.prototype.on_tcp_connection = function(connection) {\n  var self = this\n\n  var length = null\n    , bufs = []\n\n  connection.type = 'tcp'\n  connection.server = self\n\n  connection.on('data', function(data) {\n    bufs.push(data)\n    var bytes_received = bufs.reduce(function(state, buf) { return state + buf.length }, 0)\n\n    if(length === null && bytes_received >= 2) {\n      var so_far = Buffer.concat(bufs) // Flatten them all together, it's probably not much data.\n      length = so_far.readUInt16BE(0)\n      bufs = [ so_far.slice(2) ]\n    }\n\n    if(length !== null && bytes_received == 2 + length) {\n      // All of the data (plus the 2-byte length prefix) is received.\n      var data = Buffer.concat(bufs)\n        , req = new Request(data, connection)\n        , res = new Response(data, connection)\n\n      self.emit('request', req, res)\n    }\n  })\n}\n\nServer.prototype.on_udp = function(data, rinfo) {\n  var self = this\n\n  // Provide something that feels like a net.Socket, which in turn feels like the http API.\n  var connection = { 'type'         : self.udp.type\n                   , 'remoteAddress': rinfo.address\n                   , 'remotePort'   : rinfo.port\n                   , 'server'       : self\n                   , 'send'         : function() { self.udp.send.apply(self.udp, arguments) }\n                   , 'destroy'      : function() {}\n                   , 'end'          : function() {}\n                   }\n\n  var req = new Request(data, connection)\n    , res = new Response(data, connection)\n\n  self.emit('request', req, res)\n}\n\n\nutil.inherits(Request, Message)\nfunction Request (data, connection) {\n  var self = this\n  Message.call(self, data)\n\n  self.connection = connection\n}\n\nRequest.prototype.toJSON = function() {\n  var self = this\n  var obj = {}\n  Object.keys(self).forEach(function(key) {\n    if(key != 'connection')\n      obj[key] = self[key]\n  })\n  return obj\n}\n\nutil.inherits(Response, Message)\nfunction Response (data, connection) {\n  var self = this\n  Message.call(self, data)\n\n  self.question   = self.question   || []\n  self.answer     = self.answer     || []\n  self.authority  = self.authority  || []\n  self.additional = self.additional || []\n\n  self.connection = connection\n\n  convenient.init_response(self)\n}\n\nResponse.prototype.toJSON = Request.prototype.toJSON\n\nResponse.prototype.end = function(value) {\n  var self = this\n\n  var msg = convenient.final_response(self, value)\n    , data = msg.toBinary()\n\n  if(self.connection.type == 'udp4' && data.length > 512)\n    return self.emit('error', 'UDP responses greater than 512 bytes not yet implemented')\n\n  else if(self.connection.type == 'udp4')\n    self.connection.send(data, 0, data.length, self.connection.remotePort, self.connection.remoteAddress, function(er) {\n      if(er)\n        self.emit('error', er)\n    })\n\n  else if(self.connection.type == 'tcp') {\n    // Add the data length prefix.\n    var length = data.length\n    data = Buffer.concat([ new Buffer([length >> 8, length & 255]), data ])\n\n    self.connection.end(data, function(er) {\n      if(er)\n        self.emit('error', er)\n    })\n  }\n\n  else\n    self.emit('error', new Error('Unknown connection type: ' + self.connection.type))\n}\n\n\n}) // defaultable\n"]},"metadata":{},"sourceType":"script"}