{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChannelImplementation = void 0;\n\nconst call_stream_1 = require(\"./call-stream\");\n\nconst channel_credentials_1 = require(\"./channel-credentials\");\n\nconst resolving_load_balancer_1 = require(\"./resolving-load-balancer\");\n\nconst subchannel_pool_1 = require(\"./subchannel-pool\");\n\nconst picker_1 = require(\"./picker\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_stack_1 = require(\"./filter-stack\");\n\nconst call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nconst deadline_filter_1 = require(\"./deadline-filter\");\n\nconst compression_filter_1 = require(\"./compression-filter\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging_1 = require(\"./logging\");\n\nconst max_message_size_filter_1 = require(\"./max-message-size-filter\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst channelz_1 = require(\"./channelz\");\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\n\n\nconst MAX_TIMEOUT_TIME = 2147483647;\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber() {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n\n  return callNumber;\n}\n\nclass ChannelImplementation {\n  constructor(target, credentials, options) {\n    var _a, _b, _c;\n\n    this.credentials = credentials;\n    this.options = options;\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    this.currentPicker = new picker_1.UnavailablePicker();\n    /**\n     * Calls queued up to get a call config. Should only be populated before the\n     * first time the resolver returns a result, which includes the ConfigSelector.\n     */\n\n    this.configSelectionQueue = [];\n    this.pickQueue = [];\n    this.connectivityStateWatchers = [];\n    this.configSelector = null; // Channelz info\n\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker();\n\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n\n    if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {\n      throw new TypeError('Channel credentials must be a ChannelCredentials object');\n    }\n\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n\n    this.originalTarget = target;\n    const originalTargetUri = uri_parser_1.parseUri(target);\n\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n\n\n    const defaultSchemeMapResult = resolver_1.mapUriDefaultScheme(originalTargetUri);\n\n    if (defaultSchemeMapResult === null) {\n      throw new Error(`Could not find a default scheme for target name \"${target}\"`);\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n\n    if (this.channelzEnabled) {\n      this.channelzRef = channelz_1.registerChannelzChannel(target, () => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'channel',\n        id: -1,\n        name: ''\n      };\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'];\n    } else {\n      this.defaultAuthority = resolver_1.getDefaultAuthority(defaultSchemeMapResult);\n    }\n\n    const proxyMapResult = http_proxy_1.mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n\n    this.subchannelPool = subchannel_pool_1.getSubchannelPool(((_c = options['grpc.use_local_subchannel_pool']) !== null && _c !== void 0 ? _c : 0) === 0);\n    const channelControlHelper = {\n      createSubchannel: (subchannelAddress, subchannelArgs) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), this.credentials);\n\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n\n        return subchannel;\n      },\n      updateState: (connectivityState, picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata,\n          callConfig,\n          dynamicFilters\n        } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error('Resolving load balancer should never call requestReresolution');\n      },\n      addChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: child => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, options, configSelector => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n      }\n\n      this.configSelector = configSelector;\n      /* We process the queue asynchronously to ensure that the corresponding\n       * load balancer update has completed. */\n\n      process.nextTick(() => {\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n\n        for (const {\n          callStream,\n          callMetadata\n        } of localQueue) {\n          this.tryGetConfig(callStream, callMetadata);\n        }\n\n        this.configSelectionQueue = [];\n      });\n    }, status => {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n      }\n\n      if (this.configSelectionQueue.length > 0) {\n        this.trace('Name resolution failed with calls queued for config selection');\n      }\n\n      const localQueue = this.configSelectionQueue;\n      this.configSelectionQueue = [];\n      this.callRefTimerUnref();\n\n      for (const {\n        callStream,\n        callMetadata\n      } of localQueue) {\n        if (callMetadata.getOptions().waitForReady) {\n          this.callRefTimerRef();\n          this.configSelectionQueue.push({\n            callStream,\n            callMetadata\n          });\n        } else {\n          callStream.cancelWithStatus(status.code, status.details);\n        }\n      }\n    });\n    this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(this), new deadline_filter_1.DeadlineFilterFactory(this), new max_message_size_filter_1.MaxMessageSizeFilterFactory(this.options), new compression_filter_1.CompressionFilterFactory(this, this.options)]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  getChannelzInfo() {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n\n  trace(text, verbosityOverride) {\n    logging_1.trace(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + text);\n  }\n\n  callRefTimerRef() {\n    var _a, _b, _c, _d; // If the hasRef function does not exist, always run the code\n\n\n    if (!((_b = (_a = this.callRefTimer).hasRef) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n      this.trace('callRefTimer.ref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_d = (_c = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c);\n    }\n  }\n\n  callRefTimerUnref() {\n    var _a, _b; // If the hasRef function does not exist, always run the code\n\n\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace('callRefTimer.unref | configSelectionQueue.length=' + this.configSelectionQueue.length + ' pickQueue.length=' + this.pickQueue.length);\n      (_b = (_a = this.callRefTimer).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n  }\n\n  pushPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    this.pickQueue.push({\n      callStream,\n      callMetadata,\n      callConfig,\n      dynamicFilters\n    });\n    this.callRefTimerRef();\n  }\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n\n\n  tryPick(callStream, callMetadata, callConfig, dynamicFilters) {\n    var _a, _b, _c;\n\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation\n    });\n    this.trace('Pick result: ' + picker_1.PickResultType[pickResult.pickResultType] + ' subchannel: ' + ((_a = pickResult.subchannel) === null || _a === void 0 ? void 0 : _a.getAddress()) + ' status: ' + ((_b = pickResult.status) === null || _b === void 0 ? void 0 : _b.code) + ' ' + ((_c = pickResult.status) === null || _c === void 0 ? void 0 : _c.details));\n\n    switch (pickResult.pickResultType) {\n      case picker_1.PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(constants_1.Status.UNAVAILABLE, 'Request dropped by load balancing policy'); // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {\n            logging_1.log(constants_1.LogVerbosity.ERROR, 'Error: COMPLETE pick result subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()]);\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n\n\n          callStream.filterStack.sendMetadata(Promise.resolve(callMetadata.clone())).then(finalMetadata => {\n            var _a, _b;\n\n            const subchannelState = pickResult.subchannel.getConnectivityState();\n\n            if (subchannelState === connectivity_state_1.ConnectivityState.READY) {\n              try {\n                const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                pickResult.subchannel.startCallStream(finalMetadata, callStream, [...dynamicFilters, ...pickExtraFilters]);\n                /* If we reach this point, the call stream has started\n                 * successfully */\n\n                (_a = callConfig.onCommitted) === null || _a === void 0 ? void 0 : _a.call(callConfig);\n                (_b = pickResult.onCallStarted) === null || _b === void 0 ? void 0 : _b.call(pickResult);\n              } catch (error) {\n                if (error.code === 'ERR_HTTP2_GOAWAY_SESSION') {\n                  /* An error here indicates that something went wrong with\n                   * the picked subchannel's http2 stream right before we\n                   * tried to start the stream. We are handling a promise\n                   * result here, so this is asynchronous with respect to the\n                   * original tryPick call, so calling it again is not\n                   * recursive. We call tryPick immediately instead of\n                   * queueing this pick again because handling the queue is\n                   * triggered by state changes, and we want to immediately\n                   * check if the state has already changed since the\n                   * previous tryPick call. We do this instead of cancelling\n                   * the stream because the correct behavior may be\n                   * re-queueing instead, based on the logic in the rest of\n                   * tryPick */\n                  this.trace('Failed to start call on picked subchannel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Retrying pick', constants_1.LogVerbosity.INFO);\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                } else {\n                  this.trace('Failed to start call on picked subchanel ' + pickResult.subchannel.getAddress() + ' with error ' + error.message + '. Ending call', constants_1.LogVerbosity.INFO);\n                  callStream.cancelWithStatus(constants_1.Status.INTERNAL, `Failed to start HTTP/2 stream with error: ${error.message}`);\n                }\n              }\n            } else {\n              /* The logic for doing this here is the same as in the catch\n               * block above */\n              this.trace('Picked subchannel ' + pickResult.subchannel.getAddress() + ' has state ' + connectivity_state_1.ConnectivityState[subchannelState] + ' after metadata filters. Retrying pick', constants_1.LogVerbosity.INFO);\n              this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n            }\n          }, error => {\n            // We assume the error code isn't 0 (Status.OK)\n            callStream.cancelWithStatus(typeof error.code === 'number' ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);\n          });\n        }\n\n        break;\n\n      case picker_1.PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n\n      case picker_1.PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        }\n\n        break;\n\n      case picker_1.PickResultType.DROP:\n        callStream.cancelWithStatus(pickResult.status.code, pickResult.status.details);\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown pickResultType ${pickResult.pickResultType}`);\n    }\n  }\n\n  removeConnectivityStateWatcher(watcherObject) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(value => value === watcherObject);\n\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  updateState(newState) {\n    logging_1.trace(constants_1.LogVerbosity.DEBUG, 'connectivity_state', '(' + this.channelzRef.id + ') ' + uri_parser_1.uriToString(this.target) + ' ' + connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n  }\n\n  tryGetConfig(stream, metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      this.configSelectionQueue.push({\n        callStream: stream,\n        callMetadata: metadata\n      });\n      this.callRefTimerRef();\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n\n      if (callConfig.status === constants_1.Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(deadline.getSeconds() + callConfig.methodConfig.timeout.seconds);\n          deadline.setMilliseconds(deadline.getMilliseconds() + callConfig.methodConfig.timeout.nanos / 1000000);\n          stream.setConfigDeadline(deadline); // Refreshing the filters makes the deadline filter pick up the new deadline\n\n          stream.filterStack.refresh();\n        }\n\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name\n           * resolution and load balancing\".\n           *\n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new filter_stack_1.FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        stream.cancelWithStatus(callConfig.status, 'Failed to route call to method ' + stream.getMethod());\n      }\n    }\n  }\n\n  _startCallStream(stream, metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n\n    if (this.channelzEnabled) {\n      channelz_1.unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uri_parser_1.uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect) {\n    const connectivityState = this.connectivityState;\n\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n\n    return connectivityState;\n  }\n\n  watchConnectivityState(currentState, deadline, callback) {\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    let timer = null;\n\n    if (deadline !== Infinity) {\n      const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(callback, new Error('Deadline passed without connectivity state change'));\n        return;\n      }\n\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(new Error('Deadline passed without connectivity state change'));\n      }, deadlineDate.getTime() - now.getTime());\n    }\n\n    const watcherObject = {\n      currentState,\n      callback,\n      timer\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns\n   */\n\n\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(method, deadline, host, parentCall, propagateFlags) {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError('Channel#createCall: deadline must be a number or Date');\n    }\n\n    if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n\n    const callNumber = getNewCallNumber();\n    this.trace('createCall [' + callNumber + '] method=\"' + method + '\", deadline=' + deadline);\n    const finalOptions = {\n      deadline: deadline,\n      flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,\n      host: host !== null && host !== void 0 ? host : this.defaultAuthority,\n      parentCall: parentCall\n    };\n    const stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory, this.credentials._getCallCredentials(), callNumber);\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n\n    return stream;\n  }\n\n}\n\nexports.ChannelImplementation = ChannelImplementation;","map":{"version":3,"sources":["C:\\react\\quiz\\node_modules\\@grpc\\grpc-js\\src\\channel.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  Deadline,\n  Call,\n  Http2CallStream,\n  CallStreamOptions,\n} from './call-stream';\nimport { ChannelCredentials } from './channel-credentials';\nimport { ChannelOptions } from './channel-options';\nimport { ResolvingLoadBalancer } from './resolving-load-balancer';\nimport { SubchannelPool, getSubchannelPool } from './subchannel-pool';\nimport { ChannelControlHelper } from './load-balancer';\nimport { UnavailablePicker, Picker, PickResultType } from './picker';\nimport { Metadata } from './metadata';\nimport { Status, LogVerbosity, Propagate } from './constants';\nimport { FilterStackFactory } from './filter-stack';\nimport { CallCredentialsFilterFactory } from './call-credentials-filter';\nimport { DeadlineFilterFactory } from './deadline-filter';\nimport { CompressionFilterFactory } from './compression-filter';\nimport {\n  CallConfig,\n  ConfigSelector,\n  getDefaultAuthority,\n  mapUriDefaultScheme,\n} from './resolver';\nimport { trace, log } from './logging';\nimport { SubchannelAddress } from './subchannel-address';\nimport { MaxMessageSizeFilterFactory } from './max-message-size-filter';\nimport { mapProxyName } from './http_proxy';\nimport { GrpcUri, parseUri, uriToString } from './uri-parser';\nimport { ServerSurfaceCall } from './server-call';\nimport { Filter } from './filter';\n\nimport { ConnectivityState } from './connectivity-state';\nimport { ChannelInfo, ChannelRef, ChannelzCallTracker, ChannelzChildrenTracker, ChannelzTrace, registerChannelzChannel, SubchannelRef, unregisterChannelzRef } from './channelz';\n\n/**\n * See https://nodejs.org/api/timers.html#timers_setinterval_callback_delay_args\n */\nconst MAX_TIMEOUT_TIME = 2147483647;\n\nlet nextCallNumber = 0;\n\nfunction getNewCallNumber(): number {\n  const callNumber = nextCallNumber;\n  nextCallNumber += 1;\n  if (nextCallNumber >= Number.MAX_SAFE_INTEGER) {\n    nextCallNumber = 0;\n  }\n  return callNumber;\n}\n\n/**\n * An interface that represents a communication channel to a server specified\n * by a given address.\n */\nexport interface Channel {\n  /**\n   * Close the channel. This has the same functionality as the existing\n   * grpc.Client.prototype.close\n   */\n  close(): void;\n  /**\n   * Return the target that this channel connects to\n   */\n  getTarget(): string;\n  /**\n   * Get the channel's current connectivity state. This method is here mainly\n   * because it is in the existing internal Channel class, and there isn't\n   * another good place to put it.\n   * @param tryToConnect If true, the channel will start connecting if it is\n   *     idle. Otherwise, idle channels will only start connecting when a\n   *     call starts.\n   */\n  getConnectivityState(tryToConnect: boolean): ConnectivityState;\n  /**\n   * Watch for connectivity state changes. This is also here mainly because\n   * it is in the existing external Channel class.\n   * @param currentState The state to watch for transitions from. This should\n   *     always be populated by calling getConnectivityState immediately\n   *     before.\n   * @param deadline A deadline for waiting for a state change\n   * @param callback Called with no error when a state change, or with an\n   *     error if the deadline passes without a state change.\n   */\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void;\n  /**\n   * Get the channelz reference object for this channel. A request to the\n   * channelz service for the id in this object will provide information\n   * about this channel.\n   */\n  getChannelzRef(): ChannelRef;\n  /**\n   * Create a call object. Call is an opaque type that is used by the Client\n   * class. This function is called by the gRPC library when starting a\n   * request. Implementers should return an instance of Call that is returned\n   * from calling createCall on an instance of the provided Channel class.\n   * @param method The full method string to request.\n   * @param deadline The call deadline\n   * @param host A host string override for making the request\n   * @param parentCall A server call to propagate some information from\n   * @param propagateFlags A bitwise combination of elements of grpc.propagate\n   *     that indicates what information to propagate from parentCall.\n   */\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call;\n}\n\ninterface ConnectivityStateWatcher {\n  currentState: ConnectivityState;\n  timer: NodeJS.Timeout | null;\n  callback: (error?: Error) => void;\n}\n\nexport class ChannelImplementation implements Channel {\n  private resolvingLoadBalancer: ResolvingLoadBalancer;\n  private subchannelPool: SubchannelPool;\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  private currentPicker: Picker = new UnavailablePicker();\n  /**\n   * Calls queued up to get a call config. Should only be populated before the\n   * first time the resolver returns a result, which includes the ConfigSelector.\n   */\n  private configSelectionQueue: Array<{\n    callStream: Http2CallStream;\n    callMetadata: Metadata;\n  }> = [];\n  private pickQueue: Array<{\n    callStream: Http2CallStream;\n    callMetadata: Metadata;\n    callConfig: CallConfig;\n    dynamicFilters: Filter[];\n  }> = [];\n  private connectivityStateWatchers: ConnectivityStateWatcher[] = [];\n  private defaultAuthority: string;\n  private filterStackFactory: FilterStackFactory;\n  private target: GrpcUri;\n  /**\n   * This timer does not do anything on its own. Its purpose is to hold the\n   * event loop open while there are any pending calls for the channel that\n   * have not yet been assigned to specific subchannels. In other words,\n   * the invariant is that callRefTimer is reffed if and only if pickQueue\n   * is non-empty.\n   */\n  private callRefTimer: NodeJS.Timer;\n  private configSelector: ConfigSelector | null = null;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private originalTarget: string;\n  private channelzRef: ChannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  constructor(\n    target: string,\n    private readonly credentials: ChannelCredentials,\n    private readonly options: ChannelOptions\n  ) {\n    if (typeof target !== 'string') {\n      throw new TypeError('Channel target must be a string');\n    }\n    if (!(credentials instanceof ChannelCredentials)) {\n      throw new TypeError(\n        'Channel credentials must be a ChannelCredentials object'\n      );\n    }\n    if (options) {\n      if (typeof options !== 'object') {\n        throw new TypeError('Channel options must be an object');\n      }\n    }\n    this.originalTarget = target;\n    const originalTargetUri = parseUri(target);\n    if (originalTargetUri === null) {\n      throw new Error(`Could not parse target name \"${target}\"`);\n    }\n    /* This ensures that the target has a scheme that is registered with the\n     * resolver */\n    const defaultSchemeMapResult = mapUriDefaultScheme(originalTargetUri);\n    if (defaultSchemeMapResult === null) {\n      throw new Error(\n        `Could not find a default scheme for target name \"${target}\"`\n      );\n    }\n\n    this.callRefTimer = setInterval(() => {}, MAX_TIMEOUT_TIME);\n    this.callRefTimer.unref?.();\n\n    if (this.options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new ChannelzTrace();\n    if (this.channelzEnabled) {\n      this.channelzRef = registerChannelzChannel(target, () => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Channel created');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'channel',\n        id: -1,\n        name: ''\n      };\n    }\n\n    if (this.options['grpc.default_authority']) {\n      this.defaultAuthority = this.options['grpc.default_authority'] as string;\n    } else {\n      this.defaultAuthority = getDefaultAuthority(defaultSchemeMapResult);\n    }\n    const proxyMapResult = mapProxyName(defaultSchemeMapResult, options);\n    this.target = proxyMapResult.target;\n    this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);\n\n    /* The global boolean parameter to getSubchannelPool has the inverse meaning to what\n     * the grpc.use_local_subchannel_pool channel option means. */\n    this.subchannelPool = getSubchannelPool(\n      (options['grpc.use_local_subchannel_pool'] ?? 0) === 0\n    );\n    const channelControlHelper: ChannelControlHelper = {\n      createSubchannel: (\n        subchannelAddress: SubchannelAddress,\n        subchannelArgs: ChannelOptions\n      ) => {\n        const subchannel = this.subchannelPool.getOrCreateSubchannel(\n          this.target,\n          subchannelAddress,\n          Object.assign({}, this.options, subchannelArgs),\n          this.credentials\n        );\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Created subchannel or used existing subchannel', subchannel.getChannelzRef());\n        }\n        return subchannel;\n      },\n      updateState: (connectivityState: ConnectivityState, picker: Picker) => {\n        this.currentPicker = picker;\n        const queueCopy = this.pickQueue.slice();\n        this.pickQueue = [];\n        this.callRefTimerUnref();\n        for (const { callStream, callMetadata, callConfig, dynamicFilters } of queueCopy) {\n          this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n        }\n        this.updateState(connectivityState);\n      },\n      requestReresolution: () => {\n        // This should never be called.\n        throw new Error(\n          'Resolving load balancer should never call requestReresolution'\n        );\n      },\n      addChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.refChild(child);\n        }\n      },\n      removeChannelzChild: (child: ChannelRef | SubchannelRef) => {\n        if (this.channelzEnabled) {\n          this.childrenTracker.unrefChild(child);\n        }\n      }\n    };\n    this.resolvingLoadBalancer = new ResolvingLoadBalancer(\n      this.target,\n      channelControlHelper,\n      options,\n      (configSelector) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_INFO', 'Address resolution succeeded');\n        }\n        this.configSelector = configSelector;\n        /* We process the queue asynchronously to ensure that the corresponding\n         * load balancer update has completed. */\n        process.nextTick(() => {\n          const localQueue = this.configSelectionQueue;\n          this.configSelectionQueue = [];\n          this.callRefTimerUnref();\n          for (const { callStream, callMetadata } of localQueue) {\n            this.tryGetConfig(callStream, callMetadata);\n          }\n          this.configSelectionQueue = [];\n        });\n      },\n      (status) => {\n        if (this.channelzEnabled) {\n          this.channelzTrace.addTrace('CT_WARNING', 'Address resolution failed with code ' + status.code + ' and details \"' + status.details + '\"');\n        }\n        if (this.configSelectionQueue.length > 0) {\n          this.trace('Name resolution failed with calls queued for config selection');\n        }\n        const localQueue = this.configSelectionQueue;\n        this.configSelectionQueue = [];\n        this.callRefTimerUnref();\n        for (const { callStream, callMetadata } of localQueue) {\n          if (callMetadata.getOptions().waitForReady) {\n            this.callRefTimerRef();\n            this.configSelectionQueue.push({ callStream, callMetadata });\n          } else {\n            callStream.cancelWithStatus(status.code, status.details);\n          }\n        }\n      }\n    );\n    this.filterStackFactory = new FilterStackFactory([\n      new CallCredentialsFilterFactory(this),\n      new DeadlineFilterFactory(this),\n      new MaxMessageSizeFilterFactory(this.options),\n      new CompressionFilterFactory(this, this.options),\n    ]);\n    this.trace('Channel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): ChannelInfo {\n    return {\n      target: this.originalTarget,\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists()\n    };\n  }\n\n  private trace(text: string, verbosityOverride?: LogVerbosity) {\n    trace(verbosityOverride ?? LogVerbosity.DEBUG, 'channel', '(' + this.channelzRef.id + ') ' + uriToString(this.target) + ' ' + text);\n  }\n\n  private callRefTimerRef() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef?.()) {\n      this.trace(\n        'callRefTimer.ref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.ref?.();\n    }\n  }\n\n  private callRefTimerUnref() {\n    // If the hasRef function does not exist, always run the code\n    if (!this.callRefTimer.hasRef || this.callRefTimer.hasRef()) {\n      this.trace(\n        'callRefTimer.unref | configSelectionQueue.length=' +\n          this.configSelectionQueue.length +\n          ' pickQueue.length=' +\n          this.pickQueue.length\n      );\n      this.callRefTimer.unref?.();\n    }\n  }\n\n  private pushPick(\n    callStream: Http2CallStream,\n    callMetadata: Metadata,\n    callConfig: CallConfig,\n    dynamicFilters: Filter[]\n  ) {\n    this.pickQueue.push({ callStream, callMetadata, callConfig, dynamicFilters });\n    this.callRefTimerRef();\n  }\n\n  /**\n   * Check the picker output for the given call and corresponding metadata,\n   * and take any relevant actions. Should not be called while iterating\n   * over pickQueue.\n   * @param callStream\n   * @param callMetadata\n   */\n  private tryPick(\n    callStream: Http2CallStream,\n    callMetadata: Metadata,\n    callConfig: CallConfig,\n    dynamicFilters: Filter[]\n  ) {\n    const pickResult = this.currentPicker.pick({\n      metadata: callMetadata,\n      extraPickInfo: callConfig.pickInformation,\n    });\n    this.trace(\n      'Pick result: ' +\n        PickResultType[pickResult.pickResultType] +\n        ' subchannel: ' +\n        pickResult.subchannel?.getAddress() +\n        ' status: ' +\n        pickResult.status?.code +\n        ' ' +\n        pickResult.status?.details\n    );\n    switch (pickResult.pickResultType) {\n      case PickResultType.COMPLETE:\n        if (pickResult.subchannel === null) {\n          callStream.cancelWithStatus(\n            Status.UNAVAILABLE,\n            'Request dropped by load balancing policy'\n          );\n          // End the call with an error\n        } else {\n          /* If the subchannel is not in the READY state, that indicates a bug\n           * somewhere in the load balancer or picker. So, we log an error and\n           * queue the pick to be tried again later. */\n          if (\n            pickResult.subchannel!.getConnectivityState() !==\n            ConnectivityState.READY\n          ) {\n            log(\n              LogVerbosity.ERROR,\n              'Error: COMPLETE pick result subchannel ' +\n                pickResult.subchannel!.getAddress() +\n                ' has state ' +\n                ConnectivityState[pickResult.subchannel!.getConnectivityState()]\n            );\n            this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n            break;\n          }\n          /* We need to clone the callMetadata here because the transparent\n           * retry code in the promise resolution handler use the same\n           * callMetadata object, so it needs to stay unmodified */\n          callStream.filterStack\n            .sendMetadata(Promise.resolve(callMetadata.clone()))\n            .then(\n              (finalMetadata) => {\n                const subchannelState: ConnectivityState = pickResult.subchannel!.getConnectivityState();\n                if (subchannelState === ConnectivityState.READY) {\n                  try {\n                    const pickExtraFilters = pickResult.extraFilterFactories.map(factory => factory.createFilter(callStream));\n                    pickResult.subchannel!.startCallStream(\n                      finalMetadata,\n                      callStream,\n                      [...dynamicFilters, ...pickExtraFilters]\n                    );\n                    /* If we reach this point, the call stream has started\n                     * successfully */\n                    callConfig.onCommitted?.();\n                    pickResult.onCallStarted?.();\n                  } catch (error) {\n                    if (\n                      (error as NodeJS.ErrnoException).code ===\n                      'ERR_HTTP2_GOAWAY_SESSION'\n                    ) {\n                      /* An error here indicates that something went wrong with\n                       * the picked subchannel's http2 stream right before we\n                       * tried to start the stream. We are handling a promise\n                       * result here, so this is asynchronous with respect to the\n                       * original tryPick call, so calling it again is not\n                       * recursive. We call tryPick immediately instead of\n                       * queueing this pick again because handling the queue is\n                       * triggered by state changes, and we want to immediately\n                       * check if the state has already changed since the\n                       * previous tryPick call. We do this instead of cancelling\n                       * the stream because the correct behavior may be\n                       * re-queueing instead, based on the logic in the rest of\n                       * tryPick */\n                      this.trace(\n                        'Failed to start call on picked subchannel ' +\n                          pickResult.subchannel!.getAddress() +\n                          ' with error ' +\n                          (error as Error).message +\n                          '. Retrying pick',\n                          LogVerbosity.INFO\n                      );\n                      this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                    } else {\n                      this.trace(\n                        'Failed to start call on picked subchanel ' +\n                          pickResult.subchannel!.getAddress() +\n                          ' with error ' +\n                          (error as Error).message +\n                          '. Ending call',\n                          LogVerbosity.INFO\n                      );\n                      callStream.cancelWithStatus(\n                        Status.INTERNAL,\n                        `Failed to start HTTP/2 stream with error: ${\n                          (error as Error).message\n                        }`\n                      );\n                    }\n                  }\n                } else {\n                  /* The logic for doing this here is the same as in the catch\n                   * block above */\n                  this.trace(\n                    'Picked subchannel ' +\n                      pickResult.subchannel!.getAddress() +\n                      ' has state ' +\n                      ConnectivityState[subchannelState] +\n                      ' after metadata filters. Retrying pick',\n                      LogVerbosity.INFO\n                  );\n                  this.tryPick(callStream, callMetadata, callConfig, dynamicFilters);\n                }\n              },\n              (error: Error & { code: number }) => {\n                // We assume the error code isn't 0 (Status.OK)\n                callStream.cancelWithStatus(\n                  typeof error.code === 'number' ? error.code : Status.UNKNOWN,\n                  `Getting metadata from plugin failed with error: ${error.message}`\n                );\n              }\n            );\n        }\n        break;\n      case PickResultType.QUEUE:\n        this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        break;\n      case PickResultType.TRANSIENT_FAILURE:\n        if (callMetadata.getOptions().waitForReady) {\n          this.pushPick(callStream, callMetadata, callConfig, dynamicFilters);\n        } else {\n          callStream.cancelWithStatus(\n            pickResult.status!.code,\n            pickResult.status!.details\n          );\n        }\n        break;\n      case PickResultType.DROP:\n        callStream.cancelWithStatus(\n          pickResult.status!.code,\n          pickResult.status!.details\n        );\n        break;\n      default:\n        throw new Error(\n          `Invalid state: unknown pickResultType ${pickResult.pickResultType}`\n        );\n    }\n  }\n\n  private removeConnectivityStateWatcher(\n    watcherObject: ConnectivityStateWatcher\n  ) {\n    const watcherIndex = this.connectivityStateWatchers.findIndex(\n      (value) => value === watcherObject\n    );\n    if (watcherIndex >= 0) {\n      this.connectivityStateWatchers.splice(watcherIndex, 1);\n    }\n  }\n\n  private updateState(newState: ConnectivityState): void {\n    trace(\n      LogVerbosity.DEBUG,\n      'connectivity_state',\n      '(' + this.channelzRef.id + ') ' + \n        uriToString(this.target) +\n        ' ' +\n        ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    this.connectivityState = newState;\n    const watchersCopy = this.connectivityStateWatchers.slice();\n    for (const watcherObject of watchersCopy) {\n      if (newState !== watcherObject.currentState) {\n        if (watcherObject.timer) {\n          clearTimeout(watcherObject.timer);\n        }\n        this.removeConnectivityStateWatcher(watcherObject);\n        watcherObject.callback();\n      }\n    }\n  }\n\n  private tryGetConfig(stream: Http2CallStream, metadata: Metadata) {\n    if (stream.getStatus() !== null) {\n      /* If the stream has a status, it has already finished and we don't need\n       * to take any more actions on it. */\n      return;\n    }\n    if (this.configSelector === null) {\n      /* This branch will only be taken at the beginning of the channel's life,\n       * before the resolver ever returns a result. So, the\n       * ResolvingLoadBalancer may be idle and if so it needs to be kicked\n       * because it now has a pending request. */\n      this.resolvingLoadBalancer.exitIdle();\n      this.configSelectionQueue.push({\n        callStream: stream,\n        callMetadata: metadata,\n      });\n      this.callRefTimerRef();\n    } else {\n      const callConfig = this.configSelector(stream.getMethod(), metadata);\n      if (callConfig.status === Status.OK) {\n        if (callConfig.methodConfig.timeout) {\n          const deadline = new Date();\n          deadline.setSeconds(\n            deadline.getSeconds() + callConfig.methodConfig.timeout.seconds\n          );\n          deadline.setMilliseconds(\n            deadline.getMilliseconds() +\n              callConfig.methodConfig.timeout.nanos / 1_000_000\n          );\n          stream.setConfigDeadline(deadline);\n          // Refreshing the filters makes the deadline filter pick up the new deadline\n          stream.filterStack.refresh();\n        }\n        if (callConfig.dynamicFilterFactories.length > 0) {\n          /* These dynamicFilters are the mechanism for implementing gRFC A39:\n           * https://github.com/grpc/proposal/blob/master/A39-xds-http-filters.md\n           * We run them here instead of with the rest of the filters because\n           * that spec says \"the xDS HTTP filters will run in between name \n           * resolution and load balancing\".\n           * \n           * We use the filter stack here to simplify the multi-filter async\n           * waterfall logic, but we pass along the underlying list of filters\n           * to avoid having nested filter stacks when combining it with the\n           * original filter stack. We do not pass along the original filter\n           * factory list because these filters may need to persist data\n           * between sending headers and other operations. */\n          const dynamicFilterStackFactory = new FilterStackFactory(callConfig.dynamicFilterFactories);\n          const dynamicFilterStack = dynamicFilterStackFactory.createFilter(stream);\n          dynamicFilterStack.sendMetadata(Promise.resolve(metadata)).then(filteredMetadata => {\n            this.tryPick(stream, filteredMetadata, callConfig, dynamicFilterStack.getFilters());\n          });\n        } else {\n          this.tryPick(stream, metadata, callConfig, []);\n        }\n      } else {\n        stream.cancelWithStatus(\n          callConfig.status,\n          'Failed to route call to method ' + stream.getMethod()\n        );\n      }\n    }\n  }\n\n  _startCallStream(stream: Http2CallStream, metadata: Metadata) {\n    this.tryGetConfig(stream, metadata.clone());\n  }\n\n  close() {\n    this.resolvingLoadBalancer.destroy();\n    this.updateState(ConnectivityState.SHUTDOWN);\n    clearInterval(this.callRefTimer);\n    if (this.channelzEnabled) {\n      unregisterChannelzRef(this.channelzRef);\n    }\n\n    this.subchannelPool.unrefUnusedSubchannels();\n  }\n\n  getTarget() {\n    return uriToString(this.target);\n  }\n\n  getConnectivityState(tryToConnect: boolean) {\n    const connectivityState = this.connectivityState;\n    if (tryToConnect) {\n      this.resolvingLoadBalancer.exitIdle();\n    }\n    return connectivityState;\n  }\n\n  watchConnectivityState(\n    currentState: ConnectivityState,\n    deadline: Date | number,\n    callback: (error?: Error) => void\n  ): void {\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    let timer = null;\n    if (deadline !== Infinity) {\n      const deadlineDate: Date =\n        deadline instanceof Date ? deadline : new Date(deadline);\n      const now = new Date();\n      if (deadline === -Infinity || deadlineDate <= now) {\n        process.nextTick(\n          callback,\n          new Error('Deadline passed without connectivity state change')\n        );\n        return;\n      }\n      timer = setTimeout(() => {\n        this.removeConnectivityStateWatcher(watcherObject);\n        callback(\n          new Error('Deadline passed without connectivity state change')\n        );\n      }, deadlineDate.getTime() - now.getTime());\n    }\n    const watcherObject = {\n      currentState,\n      callback,\n      timer,\n    };\n    this.connectivityStateWatchers.push(watcherObject);\n  }\n\n  /**\n   * Get the channelz reference object for this channel. The returned value is\n   * garbage if channelz is disabled for this channel.\n   * @returns \n   */\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n  createCall(\n    method: string,\n    deadline: Deadline,\n    host: string | null | undefined,\n    parentCall: ServerSurfaceCall | null,\n    propagateFlags: number | null | undefined\n  ): Call {\n    if (typeof method !== 'string') {\n      throw new TypeError('Channel#createCall: method must be a string');\n    }\n    if (!(typeof deadline === 'number' || deadline instanceof Date)) {\n      throw new TypeError(\n        'Channel#createCall: deadline must be a number or Date'\n      );\n    }\n    if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n      throw new Error('Channel has been shut down');\n    }\n    const callNumber = getNewCallNumber();\n    this.trace(\n      'createCall [' +\n        callNumber +\n        '] method=\"' +\n        method +\n        '\", deadline=' +\n        deadline\n    );\n    const finalOptions: CallStreamOptions = {\n      deadline: deadline,\n      flags: propagateFlags ?? Propagate.DEFAULTS,\n      host: host ?? this.defaultAuthority,\n      parentCall: parentCall,\n    };\n    const stream: Http2CallStream = new Http2CallStream(\n      method,\n      this,\n      finalOptions,\n      this.filterStackFactory,\n      this.credentials._getCallCredentials(),\n      callNumber\n    );\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      stream.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n    }\n    return stream;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}