{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Encode DNS messages\nvar util = require('util');\n\nvar constants = require('./constants');\n\nmodule.exports = {\n  'State': State\n};\nvar SECTIONS = ['question', 'answer', 'authority', 'additional'];\n\nfunction State() {\n  var self = this;\n  self.header = new Buffer(12);\n  self.position = 0;\n  self.question = [];\n  self.answer = [];\n  self.authority = [];\n  self.additional = [];\n  self.domains = {}; // The compression lookup table\n}\n\nState.prototype.toBinary = function () {\n  var self = this;\n  var bufs = [self.header];\n  self.question.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.answer.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.authority.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  self.additional.forEach(function (buf) {\n    bufs.push(buf);\n  });\n  return Buffer.concat(bufs);\n};\n\nState.prototype.message = function (msg) {\n  var self = this; // ID\n\n  self.header.writeUInt16BE(msg.id, 0); // QR, opcode, AA, TC, RD\n\n  var byte = 0;\n  byte |= msg.type == 'response' ? 0x80 : 0x00;\n  byte |= msg.authoritative ? 0x04 : 0x00;\n  byte |= msg.truncated ? 0x02 : 0x00;\n  byte |= msg.recursion_desired ? 0x01 : 0x00;\n  var opcode_names = ['query', 'iquery', 'status', null, 'notify', 'update'],\n      opcode = opcode_names.indexOf(msg.opcode);\n  if (opcode == -1 || typeof msg.opcode != 'string') throw new Error('Unknown opcode: ' + msg.opcode);else byte |= opcode << 3;\n  self.header.writeUInt8(byte, 2); // RA, Z, AD, CD, Rcode\n\n  byte = 0;\n  byte |= msg.recursion_available ? 0x80 : 0x00;\n  byte |= msg.authenticated ? 0x20 : 0x00;\n  byte |= msg.checking_disabled ? 0x10 : 0x00;\n  byte |= msg.responseCode & 0x0f;\n  self.header.writeUInt8(byte, 3);\n  self.position = 12; // the beginning of the sections\n\n  SECTIONS.forEach(function (section) {\n    var records = msg[section] || [];\n    records.forEach(function (rec) {\n      self.record(section, rec);\n    });\n  }); // Write the section counts.\n\n  self.header.writeUInt16BE(self.question.length, 4);\n  self.header.writeUInt16BE(self.answer.length, 6);\n  self.header.writeUInt16BE(self.authority.length, 8);\n  self.header.writeUInt16BE(self.additional.length, 10);\n};\n\nState.prototype.record = function (section_name, record) {\n  var self = this;\n  var body = [],\n      buf; // Write the record name.\n\n  buf = self.encode(record.name);\n  body.push(buf);\n  self.position += buf.length;\n  var type = constants.type_to_number(record.type),\n      clas = constants.class_to_number(record.class); // Write the type.\n\n  buf = new Buffer(2);\n  buf.writeUInt16BE(type, 0);\n  body.push(buf);\n  self.position += 2; // Write the class.\n\n  buf = new Buffer(2);\n  buf.writeUInt16BE(clas, 0);\n  body.push(buf);\n  self.position += 2;\n\n  if (section_name != 'question') {\n    // Write the TTL.\n    buf = new Buffer(4);\n    buf.writeUInt32BE(record.ttl || 0, 0);\n    body.push(buf);\n    self.position += 4; // Write the rdata. Update the position now (the rdata length value) in case self.encode() runs.\n\n    var match, rdata;\n\n    switch (record.class + ' ' + record.type) {\n      case 'IN A':\n        rdata = record.data || '';\n        match = rdata.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/);\n        if (!match) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n        rdata = [+match[1], +match[2], +match[3], +match[4]];\n        break;\n\n      case 'IN AAAA':\n        // [hbouvier] More robust parsing of ipV6 address\n        rdata = ipv6_to_array(record.data || '::');\n        if (rdata.length !== 8) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n        rdata = rdata.map(pair_to_buf);\n        break;\n\n      case 'IN MX':\n        var host = record.data[1];\n        rdata = [buf16(record.data[0]), self.encode(host, 2 + 2) // Adjust for the rdata length + preference values.\n        ];\n        break;\n\n      case 'IN SOA':\n        var mname = self.encode(record.data.mname, 2) // Adust for rdata length\n        ,\n            rname = self.encode(record.data.rname, 2 + mname.length);\n        rdata = [mname, rname, buf32(record.data.serial), buf32(record.data.refresh), buf32(record.data.retry), buf32(record.data.expire), buf32(record.data.ttl)];\n        break;\n\n      case 'IN NS':\n      case 'IN PTR':\n      case 'IN CNAME':\n        rdata = self.encode(record.data, 2); // Adjust for the rdata length\n\n        break;\n\n      case 'IN TXT':\n        rdata = record.data.map(function (part) {\n          part = new Buffer(part);\n          return [part.length, part];\n        });\n        break;\n\n      case 'IN SRV':\n        rdata = [buf16(record.data.priority), buf16(record.data.weight), buf16(record.data.port), self.encode(record.data.target, 2 + 6, 'nocompress') // Offset for rdata length + priority, weight, and port.\n        ];\n        break;\n\n      case 'IN DS':\n        rdata = [buf16(record.data.key_tag), new Buffer([record.data.algorithm]), new Buffer([record.data.digest_type]), new Buffer(record.data.digest)];\n        break;\n\n      case 'NONE A':\n        // I think this is no data, from RFC 2136 S. 2.4.3.\n        rdata = [];\n        break;\n\n      default:\n        throw new Error('Unsupported record type: ' + JSON.stringify(record));\n    } // Write the rdata length. (The position was already updated.)\n\n\n    rdata = flat(rdata);\n    buf = new Buffer(2);\n    buf.writeUInt16BE(rdata.length, 0);\n    body.push(buf);\n    self.position += 2; // Write the rdata.\n\n    self.position += rdata.length;\n    if (rdata.length > 0) body.push(new Buffer(rdata));\n  }\n\n  self[section_name].push(Buffer.concat(body));\n};\n\nState.prototype.encode = function (full_domain, position_offset, option) {\n  var self = this; // [hbouvier] Added default value\n\n  var domain = full_domain || '';\n  domain = domain.replace(/\\.$/, ''); // Strip the trailing dot.\n\n  position = self.position + (position_offset || 0);\n  var body = [],\n      bytes;\n  var i = 0;\n  var max_iterations = 40; // Enough for 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\n\n  while (++i < max_iterations) {\n    if (domain == '') {\n      // Encode the root domain and be done.\n      body.push(new Buffer([0]));\n      return Buffer.concat(body);\n    } else if (self.domains[domain] && option !== 'nocompress') {\n      // Encode a pointer and be done.\n      body.push(new Buffer([0xc0, self.domains[domain]]));\n      return Buffer.concat(body);\n    } else {\n      // Encode the next part of the domain, saving its position in the lookup table for later.\n      self.domains[domain] = position;\n      var parts = domain.split(/\\./),\n          car = parts[0];\n      domain = parts.slice(1).join('.'); // Write the first part of the domain, with a length prefix.\n      //var part = parts[0]\n\n      var buf = new Buffer(car.length + 1);\n      buf.write(car, 1, car.length, 'ascii');\n      buf.writeUInt8(car.length, 0);\n      body.push(buf);\n      position += buf.length; //bytes.unshift(bytes.length)\n    }\n  }\n\n  throw new Error('Too many iterations encoding domain: ' + full_domain);\n}; //\n// Utilities\n//\n\n\nfunction buf32(value) {\n  var buf = new Buffer(4);\n  buf.writeUInt32BE(value, 0);\n  return buf;\n}\n\nfunction buf16(value) {\n  var buf = new Buffer(2);\n  buf.writeUInt16BE(value, 0);\n  return buf;\n}\n\nfunction flat(data) {\n  return Buffer.isBuffer(data) ? Array.prototype.slice.call(data) : Array.isArray(data) ? data.reduce(flatten, []) : [data];\n}\n\nfunction flatten(state, element) {\n  return Buffer.isBuffer(element) || Array.isArray(element) ? state.concat(flat(element)) : state.concat([element]);\n}\n\nfunction pair_to_buf(pair) {\n  // [hbouvier]  It is possible that the \"pair\" has less than 4 digits, lets\n  //             make sure that it has.\n  var pairLength = pair.length;\n  if (pairLength < 4) pair = \"0000\".substring(pairLength) + pair; // Convert a string of two hex bytes, e.g. \"89ab\" to a buffer.\n\n  if (!pair.match(/^[0-9a-fA-F]{4}$/)) throw new Error('Bad ' + record.type + ' record data: ' + JSON.stringify(record));\n  return new Buffer(pair, 'hex');\n} // [hbouvier] More robust parsing of ipV6 address\n\n\nfunction ipv6_to_array(string) {\n  var fullAddress = ['0', '0', '0', '0', '0', '0', '0', '0']; // Remove the contiguous empty strings generated by '::' and keep ony one.\n\n  var numbers = string.split(/:/).reduce(function (previous, current) {\n    if (previous instanceof Array === false) previous = [previous];\n\n    if (!(current === '' && previous[previous.length - 1] === '')) {\n      previous.push(current);\n    }\n\n    return previous;\n  }); // Replace the single empty string, by the number of '0' that\n  // were \"missing\" (e.g. shortened address)\n\n  var merged = [].concat.apply([], numbers.map(function (num) {\n    return num === '' ? fullAddress.slice(numbers.length - 1) : num;\n  }));\n  return merged;\n}","map":{"version":3,"sources":["C:/react/quiz/node_modules/hbo-dnsd/encode.js"],"names":["util","require","constants","module","exports","State","SECTIONS","self","header","Buffer","position","question","answer","authority","additional","domains","prototype","toBinary","bufs","forEach","buf","push","concat","message","msg","writeUInt16BE","id","byte","type","authoritative","truncated","recursion_desired","opcode_names","opcode","indexOf","Error","writeUInt8","recursion_available","authenticated","checking_disabled","responseCode","section","records","rec","record","length","section_name","body","encode","name","type_to_number","clas","class_to_number","class","writeUInt32BE","ttl","match","rdata","data","JSON","stringify","ipv6_to_array","map","pair_to_buf","host","buf16","mname","rname","buf32","serial","refresh","retry","expire","part","priority","weight","port","target","key_tag","algorithm","digest_type","digest","flat","full_domain","position_offset","option","domain","replace","bytes","i","max_iterations","parts","split","car","slice","join","write","value","isBuffer","Array","call","isArray","reduce","flatten","state","element","pair","pairLength","substring","string","fullAddress","numbers","previous","current","merged","apply","num"],"mappings":"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","sourcesContent":["// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Encode DNS messages\n\nvar util = require('util')\n\nvar constants = require('./constants')\n\nmodule.exports = { 'State': State\n                 }\n\nvar SECTIONS = ['question', 'answer', 'authority', 'additional']\n\nfunction State () {\n  var self = this\n\n  self.header = new Buffer(12)\n  self.position = 0\n\n  self.question   = []\n  self.answer     = []\n  self.authority  = []\n  self.additional = []\n\n  self.domains = {} // The compression lookup table\n}\n\nState.prototype.toBinary = function() {\n  var self = this\n\n  var bufs = [self.header]\n  self.question  .forEach(function(buf) { bufs.push(buf) })\n  self.answer    .forEach(function(buf) { bufs.push(buf) })\n  self.authority .forEach(function(buf) { bufs.push(buf) })\n  self.additional.forEach(function(buf) { bufs.push(buf) })\n\n  return Buffer.concat(bufs)\n}\n\nState.prototype.message = function(msg) {\n  var self = this\n\n  // ID\n  self.header.writeUInt16BE(msg.id, 0)\n\n  // QR, opcode, AA, TC, RD\n  var byte = 0\n  byte |= msg.type == 'response' ? 0x80 : 0x00\n  byte |= msg.authoritative      ? 0x04 : 0x00\n  byte |= msg.truncated          ? 0x02 : 0x00\n  byte |= msg.recursion_desired  ? 0x01 : 0x00\n\n  var opcode_names = ['query', 'iquery', 'status', null, 'notify', 'update']\n    , opcode = opcode_names.indexOf(msg.opcode)\n\n  if(opcode == -1 || typeof msg.opcode != 'string')\n    throw new Error('Unknown opcode: ' + msg.opcode)\n  else\n    byte |= (opcode << 3)\n\n  self.header.writeUInt8(byte, 2)\n\n  // RA, Z, AD, CD, Rcode\n  byte = 0\n  byte |= msg.recursion_available ? 0x80 : 0x00\n  byte |= msg.authenticated       ? 0x20 : 0x00\n  byte |= msg.checking_disabled   ? 0x10 : 0x00\n  byte |= (msg.responseCode & 0x0f)\n\n  self.header.writeUInt8(byte, 3)\n\n  self.position = 12 // the beginning of the sections\n  SECTIONS.forEach(function(section) {\n    var records = msg[section] || []\n    records.forEach(function(rec) {\n      self.record(section, rec)\n    })\n  })\n\n  // Write the section counts.\n  self.header.writeUInt16BE(self.question.length    , 4)\n  self.header.writeUInt16BE(self.answer.length      , 6)\n  self.header.writeUInt16BE(self.authority.length   , 8)\n  self.header.writeUInt16BE(self.additional.length  , 10)\n}\n\nState.prototype.record = function(section_name, record) {\n  var self = this\n\n  var body = []\n    , buf\n\n  // Write the record name.\n  buf = self.encode(record.name)\n  body.push(buf)\n  self.position += buf.length\n\n  var type = constants.type_to_number(record.type)\n    , clas = constants.class_to_number(record.class)\n\n  // Write the type.\n  buf = new Buffer(2)\n  buf.writeUInt16BE(type, 0)\n  body.push(buf)\n  self.position += 2\n\n  // Write the class.\n  buf = new Buffer(2)\n  buf.writeUInt16BE(clas, 0)\n  body.push(buf)\n  self.position += 2\n\n  if(section_name != 'question') {\n    // Write the TTL.\n    buf = new Buffer(4)\n    buf.writeUInt32BE(record.ttl || 0, 0)\n    body.push(buf)\n    self.position += 4\n\n    // Write the rdata. Update the position now (the rdata length value) in case self.encode() runs.\n    var match, rdata\n    switch (record.class + ' ' + record.type) {\n      case 'IN A':\n        rdata = record.data || ''\n        match = rdata.match(/^(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)$/)\n        if(!match)\n          throw new Error('Bad '+record.type+' record data: ' + JSON.stringify(record))\n        rdata = [ +match[1], +match[2], +match[3], +match[4] ]\n        break\n      case 'IN AAAA':\n        // [hbouvier] More robust parsing of ipV6 address\n        rdata = ipv6_to_array(record.data || '::')\n        if(rdata.length !== 8)\n          throw new Error('Bad '+record.type+' record data: ' + JSON.stringify(record))\n        rdata = rdata.map(pair_to_buf)\n        break\n      case 'IN MX':\n        var host = record.data[1]\n        rdata = [ buf16(record.data[0])\n                , self.encode(host, 2 + 2) // Adjust for the rdata length + preference values.\n                ]\n        break\n      case 'IN SOA':\n        var mname   = self.encode(record.data.mname, 2) // Adust for rdata length\n          , rname   = self.encode(record.data.rname, 2 + mname.length)\n        rdata = [ mname\n                , rname\n                , buf32(record.data.serial)\n                , buf32(record.data.refresh)\n                , buf32(record.data.retry)\n                , buf32(record.data.expire)\n                , buf32(record.data.ttl)\n                ]\n        break\n      case 'IN NS':\n      case 'IN PTR':\n      case 'IN CNAME':\n        rdata = self.encode(record.data, 2) // Adjust for the rdata length\n        break\n      case 'IN TXT':\n        rdata = record.data.map(function(part) {\n          part = new Buffer(part)\n          return [part.length, part]\n        })\n        break\n      case 'IN SRV':\n        rdata = [ buf16(record.data.priority)\n                , buf16(record.data.weight)\n                , buf16(record.data.port)\n                , self.encode(record.data.target, 2 + 6, 'nocompress') // Offset for rdata length + priority, weight, and port.\n                ]\n        break\n      case 'IN DS':\n        rdata = [ buf16(record.data.key_tag)\n                , new Buffer([record.data.algorithm])\n                , new Buffer([record.data.digest_type])\n                , new Buffer(record.data.digest)\n                ]\n        break\n      case 'NONE A':\n        // I think this is no data, from RFC 2136 S. 2.4.3.\n        rdata = []\n        break\n      default:\n        throw new Error('Unsupported record type: ' + JSON.stringify(record))\n    }\n\n    // Write the rdata length. (The position was already updated.)\n    rdata = flat(rdata)\n    buf = new Buffer(2)\n    buf.writeUInt16BE(rdata.length, 0)\n    body.push(buf)\n    self.position += 2\n\n    // Write the rdata.\n    self.position += rdata.length\n    if(rdata.length > 0)\n      body.push(new Buffer(rdata))\n  }\n\n  self[section_name].push(Buffer.concat(body))\n}\n\nState.prototype.encode = function(full_domain, position_offset, option) {\n  var self = this\n\n  // [hbouvier] Added default value\n  var domain = full_domain || '';\n  domain = domain.replace(/\\.$/, '') // Strip the trailing dot.\n  position = self.position + (position_offset || 0)\n\n  var body = []\n    , bytes\n\n  var i = 0\n  var max_iterations = 40 // Enough for 1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.ip6.arpa\n\n  while(++i < max_iterations) {\n    if(domain == '') {\n      // Encode the root domain and be done.\n      body.push(new Buffer([0]))\n      return Buffer.concat(body)\n    }\n\n    else if(self.domains[domain] && option !== 'nocompress') {\n      // Encode a pointer and be done.\n      body.push(new Buffer([0xc0, self.domains[domain]]))\n      return Buffer.concat(body)\n    }\n\n    else {\n      // Encode the next part of the domain, saving its position in the lookup table for later.\n      self.domains[domain] = position\n\n      var parts = domain.split(/\\./)\n        , car = parts[0]\n      domain = parts.slice(1).join('.')\n\n      // Write the first part of the domain, with a length prefix.\n      //var part = parts[0]\n      var buf = new Buffer(car.length + 1)\n      buf.write(car, 1, car.length, 'ascii')\n      buf.writeUInt8(car.length, 0)\n      body.push(buf)\n      position += buf.length\n      //bytes.unshift(bytes.length)\n    }\n  }\n\n  throw new Error('Too many iterations encoding domain: ' + full_domain)\n}\n\n\n//\n// Utilities\n//\n\nfunction buf32(value) {\n  var buf = new Buffer(4)\n  buf.writeUInt32BE(value, 0)\n  return buf\n}\n\nfunction buf16(value) {\n  var buf = new Buffer(2)\n  buf.writeUInt16BE(value, 0)\n  return buf\n}\n\nfunction flat(data) {\n  return Buffer.isBuffer(data)\n          ? Array.prototype.slice.call(data)\n          : Array.isArray(data)\n            ? data.reduce(flatten, [])\n            : [data]\n}\n\nfunction flatten(state, element) {\n  return (Buffer.isBuffer(element) || Array.isArray(element))\n          ? state.concat(flat(element))\n          : state.concat([element])\n}\n\nfunction pair_to_buf(pair) {\n  // [hbouvier]  It is possible that the \"pair\" has less than 4 digits, lets\n  //             make sure that it has.\n  var pairLength = pair.length;\n  if (pairLength < 4)\n    pair = \"0000\".substring(pairLength) + pair;\n\n  // Convert a string of two hex bytes, e.g. \"89ab\" to a buffer.\n  if(! pair.match(/^[0-9a-fA-F]{4}$/))\n    throw new Error('Bad '+record.type+' record data: ' + JSON.stringify(record))\n  return new Buffer(pair, 'hex')\n}\n\n// [hbouvier] More robust parsing of ipV6 address\nfunction ipv6_to_array(string) {\n  var fullAddress = ['0','0','0','0','0','0','0','0'];\n  // Remove the contiguous empty strings generated by '::' and keep ony one.\n  var numbers = string.split(/:/).reduce(function (previous, current) {\n    if (previous instanceof Array === false)\n      previous = [previous];\n    if (!(current === '' && previous[previous.length -1] === '')) {\n      previous.push(current)\n    }\n    return previous;\n  });\n  // Replace the single empty string, by the number of '0' that\n  // were \"missing\" (e.g. shortened address)\n  var merged = [].concat.apply([], numbers.map(function (num) {\n    return (num === '') ? fullAddress.slice(numbers.length -1): num;\n  }));\n  return merged;\n}\n"]},"metadata":{},"sourceType":"script"}