{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GoogleProtoFilesRoot = exports.GrpcClient = exports.ClientStub = void 0;\n\nconst grpcProtoLoader = require(\"@grpc/proto-loader\");\n\nconst child_process_1 = require(\"child_process\");\n\nconst fs = require(\"fs\");\n\nconst google_auth_library_1 = require(\"google-auth-library\");\n\nconst grpc = require(\"@grpc/grpc-js\");\n\nconst os = require(\"os\");\n\nconst path_1 = require(\"path\");\n\nconst path = require(\"path\");\n\nconst protobuf = require(\"protobufjs\");\n\nconst objectHash = require(\"object-hash\");\n\nconst gax = require(\"./gax\");\n\nconst googleProtoFilesDir = path.join(__dirname, '..', '..', 'protos'); // INCLUDE_DIRS is passed to @grpc/proto-loader\n\nconst INCLUDE_DIRS = [];\nINCLUDE_DIRS.push(googleProtoFilesDir); // COMMON_PROTO_FILES logic is here for protobufjs loads (see\n// GoogleProtoFilesRoot below)\n\nconst commonProtoFiles = require(\"./protosList.json\"); // use the correct path separator for the OS we are running on\n\n\nconst COMMON_PROTO_FILES = commonProtoFiles.map(file => file.replace(/[/\\\\]/g, path.sep));\n/*\n * Async version of readFile.\n *\n * @returns {Promise} Contents of file at path.\n */\n\nasync function readFileAsync(path) {\n  return new Promise((resolve, reject) => {\n    fs.readFile(path, 'utf8', (err, content) => {\n      if (err) return reject(err);else resolve(content);\n    });\n  });\n}\n/*\n * Async version of execFile.\n *\n * @returns {Promise} stdout from command execution.\n */\n\n\nasync function execFileAsync(command, args) {\n  return new Promise((resolve, reject) => {\n    child_process_1.execFile(command, args, (err, stdout) => {\n      if (err) return reject(err);else resolve(stdout);\n    });\n  });\n}\n\nclass ClientStub extends grpc.Client {}\n\nexports.ClientStub = ClientStub;\n\nclass GrpcClient {\n  /**\n   * A class which keeps the context of gRPC and auth for the gRPC.\n   *\n   * @param {Object=} options - The optional parameters. It will be directly\n   *   passed to google-auth-library library, so parameters like keyFile or\n   *   credentials will be valid.\n   * @param {Object=} options.auth - An instance of google-auth-library.\n   *   When specified, this auth instance will be used instead of creating\n   *   a new one.\n   * @param {Object=} options.grpc - When specified, this will be used\n   *   for the 'grpc' module in this context. By default, it will load the grpc\n   *   module in the standard way.\n   * @constructor\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    var _a;\n\n    this.auth = options.auth || new google_auth_library_1.GoogleAuth(options);\n    this.fallback = false;\n    const minimumVersion = 10;\n    const major = Number((_a = process.version.match(/^v(\\d+)/)) === null || _a === void 0 ? void 0 : _a[1]);\n\n    if (Number.isNaN(major) || major < minimumVersion) {\n      const errorMessage = `Node.js v${minimumVersion}.0.0 is a minimum requirement. To learn about legacy version support visit: ` + 'https://github.com/googleapis/google-cloud-node#supported-nodejs-versions';\n      throw new Error(errorMessage);\n    }\n\n    if ('grpc' in options) {\n      this.grpc = options.grpc;\n      this.grpcVersion = '';\n    } else {\n      this.grpc = grpc;\n      this.grpcVersion = require('@grpc/grpc-js/package.json').version;\n    }\n  }\n  /**\n   * Key for proto cache map. We are doing our best to make sure we respect\n   * the options, so if the same proto file is loaded with different set of\n   * options, the cache won't be used.  Since some of the options are\n   * Functions (e.g. `enums: String` - see below in `loadProto()`),\n   * they will be omitted from the cache key.  If the cache breaks anything\n   * for you, use the `ignoreCache` parameter of `loadProto()` to disable it.\n   */\n\n\n  static protoCacheKey(filename, options) {\n    if (!filename || Array.isArray(filename) && (filename.length === 0 || !filename[0])) {\n      return undefined;\n    }\n\n    return JSON.stringify(filename) + ' ' + JSON.stringify(options);\n  }\n  /**\n   * In rare cases users might need to deallocate all memory consumed by loaded protos.\n   * This method will delete the proto cache content.\n   */\n\n\n  static clearProtoCache() {\n    GrpcClient.protoCache.clear();\n  }\n  /**\n   * Creates a gRPC credentials. It asks the auth data if necessary.\n   * @private\n   * @param {Object} opts - options values for configuring credentials.\n   * @param {Object=} opts.sslCreds - when specified, this is used instead\n   *   of default channel credentials.\n   * @return {Promise} The promise which will be resolved to the gRPC credential.\n   */\n\n\n  async _getCredentials(opts) {\n    if (opts.sslCreds) {\n      return opts.sslCreds;\n    }\n\n    const grpc = this.grpc;\n    const sslCreds = opts.cert && opts.key ? grpc.credentials.createSsl(null, Buffer.from(opts.key), Buffer.from(opts.cert)) : grpc.credentials.createSsl();\n    const client = await this.auth.getClient();\n    const credentials = grpc.credentials.combineChannelCredentials(sslCreds, grpc.credentials.createFromGoogleCredential(client));\n    return credentials;\n  }\n\n  static defaultOptions() {\n    // This set of @grpc/proto-loader options\n    // 'closely approximates the existing behavior of grpc.load'\n    const includeDirs = INCLUDE_DIRS.slice();\n    const options = {\n      keepCase: false,\n      longs: String,\n      enums: String,\n      defaults: true,\n      oneofs: true,\n      includeDirs\n    };\n    return options;\n  }\n  /**\n   * Loads the gRPC service from the proto file(s) at the given path and with the\n   * given options. Caches the loaded protos so the subsequent loads don't do\n   * any disk reads.\n   * @param filename The path to the proto file(s).\n   * @param options Options for loading the proto file.\n   * @param ignoreCache Defaults to `false`. Set it to `true` if the caching logic\n   *   incorrectly decides that the options object is the same, or if you want to\n   *   re-read the protos from disk for any other reason.\n   */\n\n\n  loadFromProto(filename, options) {\n    let ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const cacheKey = GrpcClient.protoCacheKey(filename, options);\n    let grpcPackage = cacheKey ? GrpcClient.protoCache.get(cacheKey) : undefined;\n\n    if (ignoreCache || !grpcPackage) {\n      const packageDef = grpcProtoLoader.loadSync(filename, options);\n      grpcPackage = this.grpc.loadPackageDefinition(packageDef);\n\n      if (cacheKey) {\n        GrpcClient.protoCache.set(cacheKey, grpcPackage);\n      }\n    }\n\n    return grpcPackage;\n  }\n  /**\n   * Load gRPC proto service from a filename looking in googleapis common protos\n   * when necessary. Caches the loaded protos so the subsequent loads don't do\n   * any disk reads.\n   * @param {String} protoPath - The directory to search for the protofile.\n   * @param {String|String[]} filename - The filename(s) of the proto(s) to be loaded.\n   *   If omitted, protoPath will be treated as a file path to load.\n   * @param ignoreCache Defaults to `false`. Set it to `true` if the caching logic\n   *   incorrectly decides that the options object is the same, or if you want to\n   *   re-read the protos from disk for any other reason.\n   * @return {Object<string, *>} The gRPC loaded result (the toplevel namespace\n   *   object).\n   */\n\n\n  loadProto(protoPath, filename) {\n    let ignoreCache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n    if (!filename) {\n      filename = path.basename(protoPath);\n      protoPath = path.dirname(protoPath);\n    }\n\n    if (Array.isArray(filename) && filename.length === 0) {\n      return {};\n    }\n\n    const options = GrpcClient.defaultOptions();\n    options.includeDirs.unshift(protoPath);\n    return this.loadFromProto(filename, options, ignoreCache);\n  }\n\n  static _resolveFile(protoPath, filename) {\n    if (fs.existsSync(path.join(protoPath, filename))) {\n      return path.join(protoPath, filename);\n    } else if (COMMON_PROTO_FILES.indexOf(filename) > -1) {\n      return path.join(googleProtoFilesDir, filename);\n    }\n\n    throw new Error(filename + ' could not be found in ' + protoPath);\n  }\n\n  loadProtoJSON(json) {\n    let ignoreCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const hash = objectHash(json).toString();\n    const cached = GrpcClient.protoCache.get(hash);\n\n    if (cached && !ignoreCache) {\n      return cached;\n    }\n\n    const options = GrpcClient.defaultOptions();\n    const packageDefinition = grpcProtoLoader.fromJSON(json, options);\n    const grpcPackage = this.grpc.loadPackageDefinition(packageDefinition);\n    GrpcClient.protoCache.set(hash, grpcPackage);\n    return grpcPackage;\n  }\n\n  metadataBuilder(headers) {\n    const Metadata = this.grpc.Metadata;\n    const baseMetadata = new Metadata();\n\n    for (const key in headers) {\n      const value = headers[key];\n\n      if (Array.isArray(value)) {\n        value.forEach(v => baseMetadata.add(key, v));\n      } else {\n        baseMetadata.set(key, `${value}`);\n      }\n    }\n\n    return function buildMetadata(abTests, moreHeaders) {\n      // TODO: bring the A/B testing info into the metadata.\n      let copied = false;\n      let metadata = baseMetadata;\n\n      if (moreHeaders) {\n        for (const key in moreHeaders) {\n          if (key.toLowerCase() !== 'x-goog-api-client') {\n            if (!copied) {\n              copied = true;\n              metadata = metadata.clone();\n            }\n\n            const value = moreHeaders[key];\n\n            if (Array.isArray(value)) {\n              value.forEach(v => metadata.add(key, v));\n            } else {\n              metadata.set(key, `${value}`);\n            }\n          }\n        }\n      }\n\n      return metadata;\n    };\n  }\n  /**\n   * A wrapper of {@link constructSettings} function under the gRPC context.\n   *\n   * Most of parameters are common among constructSettings, please take a look.\n   * @param {string} serviceName - The fullly-qualified name of the service.\n   * @param {Object} clientConfig - A dictionary of the client config.\n   * @param {Object} configOverrides - A dictionary of overriding configs.\n   * @param {Object} headers - A dictionary of additional HTTP header name to\n   *   its value.\n   * @return {Object} A mapping of method names to CallSettings.\n   */\n\n\n  constructSettings(serviceName, clientConfig, configOverrides, headers) {\n    return gax.constructSettings(serviceName, clientConfig, configOverrides, this.grpc.status, {\n      metadataBuilder: this.metadataBuilder(headers)\n    });\n  }\n  /**\n   * Creates a gRPC stub with current gRPC and auth.\n   * @param {function} CreateStub - The constructor function of the stub.\n   * @param {Object} options - The optional arguments to customize\n   *   gRPC connection. This options will be passed to the constructor of\n   *   gRPC client too.\n   * @param {string} options.servicePath - The name of the server of the service.\n   * @param {number} options.port - The port of the service.\n   * @param {grpcTypes.ClientCredentials=} options.sslCreds - The credentials to be used\n   *   to set up gRPC connection.\n   * @param {string} defaultServicePath - The default service path.\n   * @return {Promise} A promise which resolves to a gRPC stub instance.\n   */\n\n\n  async createStub(CreateStub, options, customServicePath) {\n    // The following options are understood by grpc-gcp and need a special treatment\n    // (should be passed without a `grpc.` prefix)\n    const grpcGcpOptions = ['grpc.callInvocationTransformer', 'grpc.channelFactoryOverride', 'grpc.gcpApiConfig'];\n    const [cert, key] = await this._detectClientCertificate(options);\n\n    const servicePath = this._mtlsServicePath(options.servicePath, customServicePath, cert && key);\n\n    const opts = Object.assign({}, options, {\n      cert,\n      key,\n      servicePath\n    });\n    const serviceAddress = servicePath + ':' + opts.port;\n    const creds = await this._getCredentials(opts);\n    const grpcOptions = {}; // @grpc/grpc-js limits max receive/send message length starting from v0.8.0\n    // https://github.com/grpc/grpc-node/releases/tag/%40grpc%2Fgrpc-js%400.8.0\n    // To keep the existing behavior and avoid libraries breakage, we pass -1 there as suggested.\n\n    grpcOptions['grpc.max_receive_message_length'] = -1;\n    grpcOptions['grpc.max_send_message_length'] = -1;\n    grpcOptions['grpc.initial_reconnect_backoff_ms'] = 1000;\n    Object.keys(opts).forEach(key => {\n      const value = options[key]; // the older versions had a bug which required users to call an option\n      // grpc.grpc.* to make it actually pass to gRPC as grpc.*, let's handle\n      // this here until the next major release\n\n      if (key.startsWith('grpc.grpc.')) {\n        key = key.replace(/^grpc\\./, '');\n      }\n\n      if (key.startsWith('grpc.')) {\n        if (grpcGcpOptions.includes(key)) {\n          key = key.replace(/^grpc\\./, '');\n        }\n\n        grpcOptions[key] = value;\n      }\n\n      if (key.startsWith('grpc-node.')) {\n        grpcOptions[key] = value;\n      }\n    });\n    const stub = new CreateStub(serviceAddress, creds, grpcOptions);\n    return stub;\n  }\n  /**\n   * Detect mTLS client certificate based on logic described in\n   * https://google.aip.dev/auth/4114.\n   *\n   * @param {object} [options] - The configuration object.\n   * @returns {Promise} Resolves array of strings representing cert and key.\n   */\n\n\n  async _detectClientCertificate(opts) {\n    var _a;\n\n    const certRegex = /(?<cert>-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----)/s;\n    const keyRegex = /(?<key>-----BEGIN PRIVATE KEY-----.*?-----END PRIVATE KEY-----)/s; // If GOOGLE_API_USE_CLIENT_CERTIFICATE is true...:\n\n    if (typeof process !== 'undefined' && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.GOOGLE_API_USE_CLIENT_CERTIFICATE) === 'true') {\n      if ((opts === null || opts === void 0 ? void 0 : opts.cert) && (opts === null || opts === void 0 ? void 0 : opts.key)) {\n        return [opts.cert, opts.key];\n      } // If context aware metadata exists, run the cert provider command,\n      // parse the output to extract cert and key, and use this cert/key.\n\n\n      const metadataPath = path_1.join(os.homedir(), '.secureConnect', 'context_aware_metadata.json');\n      const metadata = JSON.parse(await readFileAsync(metadataPath));\n\n      if (!metadata.cert_provider_command) {\n        throw Error('no cert_provider_command found');\n      }\n\n      const stdout = await execFileAsync(metadata.cert_provider_command[0], metadata.cert_provider_command.slice(1));\n      const matchCert = stdout.toString().match(certRegex);\n      const matchKey = stdout.toString().match(keyRegex);\n\n      if (!((matchCert === null || matchCert === void 0 ? void 0 : matchCert.groups) && (matchKey === null || matchKey === void 0 ? void 0 : matchKey.groups))) {\n        throw Error('unable to parse certificate and key');\n      } else {\n        return [matchCert.groups.cert, matchKey.groups.key];\n      }\n    } // If GOOGLE_API_USE_CLIENT_CERTIFICATE is not set or false,\n    // use no cert or key:\n\n\n    return [undefined, undefined];\n  }\n  /**\n   * Return service path, taking into account mTLS logic.\n   * See: https://google.aip.dev/auth/4114\n   *\n   * @param {string|undefined} servicePath - The path of the service.\n   * @param {string|undefined} customServicePath - Did the user provide a custom service URL.\n   * @param {boolean} hasCertificate - Was a certificate found.\n   * @returns {string} The DNS address for this service.\n   */\n\n\n  _mtlsServicePath(servicePath, customServicePath, hasCertificate) {\n    var _a, _b; // If user provides a custom service path, return the current service\n    // path and do not attempt to add mtls subdomain:\n\n\n    if (customServicePath || !servicePath) return servicePath;\n\n    if (typeof process !== 'undefined' && ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.GOOGLE_API_USE_MTLS_ENDPOINT) === 'never') {\n      // It was explicitly asked that mtls endpoint not be used:\n      return servicePath;\n    } else if (typeof process !== 'undefined' && ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.GOOGLE_API_USE_MTLS_ENDPOINT) === 'always' || hasCertificate) {\n      // Either auto-detect or explicit setting of endpoint:\n      return servicePath.replace('googleapis.com', 'mtls.googleapis.com');\n    }\n\n    return servicePath;\n  }\n  /**\n   * Creates a 'bytelength' function for a given proto message class.\n   *\n   * See {@link BundleDescriptor} about the meaning of the return value.\n   *\n   * @param {function} message - a constructor function that is generated by\n   *   protobuf.js. Assumes 'encoder' field in the message.\n   * @return {function(Object):number} - a function to compute the byte length\n   *   for an object.\n   */\n\n\n  static createByteLengthFunction(message) {\n    return function getByteLength(obj) {\n      return message.encode(obj).finish().length;\n    };\n  }\n\n}\n\nexports.GrpcClient = GrpcClient;\nGrpcClient.protoCache = new Map();\n\nclass GoogleProtoFilesRoot extends protobuf.Root {\n  constructor() {\n    super(...arguments);\n  } // Causes the loading of an included proto to check if it is a common\n  // proto. If it is a common proto, use the bundled proto.\n\n\n  resolvePath(originPath, includePath) {\n    originPath = path.normalize(originPath);\n    includePath = path.normalize(includePath); // Fully qualified paths don't need to be resolved.\n\n    if (path.isAbsolute(includePath)) {\n      if (!fs.existsSync(includePath)) {\n        throw new Error('The include `' + includePath + '` was not found.');\n      }\n\n      return includePath;\n    }\n\n    if (COMMON_PROTO_FILES.indexOf(includePath) > -1) {\n      return path.join(googleProtoFilesDir, includePath);\n    }\n\n    return GoogleProtoFilesRoot._findIncludePath(originPath, includePath);\n  }\n\n  static _findIncludePath(originPath, includePath) {\n    originPath = path.normalize(originPath);\n    includePath = path.normalize(includePath);\n    let current = originPath;\n    let found = fs.existsSync(path.join(current, includePath));\n\n    while (!found && current.length > 0) {\n      current = current.substring(0, current.lastIndexOf(path.sep));\n      found = fs.existsSync(path.join(current, includePath));\n    }\n\n    if (!found) {\n      throw new Error('The include `' + includePath + '` was not found.');\n    }\n\n    return path.join(current, includePath);\n  }\n\n}\n\nexports.GoogleProtoFilesRoot = GoogleProtoFilesRoot;","map":{"version":3,"sources":["../../src/grpc.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GoogleProtoFilesRoot = exports.GrpcClient = exports.ClientStub = void 0;\nconst grpcProtoLoader = require(\"@grpc/proto-loader\");\nconst child_process_1 = require(\"child_process\");\nconst fs = require(\"fs\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst grpc = require(\"@grpc/grpc-js\");\nconst os = require(\"os\");\nconst path_1 = require(\"path\");\nconst path = require(\"path\");\nconst protobuf = require(\"protobufjs\");\nconst objectHash = require(\"object-hash\");\nconst gax = require(\"./gax\");\nconst googleProtoFilesDir = path.join(__dirname, '..', '..', 'protos');\n// INCLUDE_DIRS is passed to @grpc/proto-loader\nconst INCLUDE_DIRS = [];\nINCLUDE_DIRS.push(googleProtoFilesDir);\n// COMMON_PROTO_FILES logic is here for protobufjs loads (see\n// GoogleProtoFilesRoot below)\nconst commonProtoFiles = require(\"./protosList.json\");\n// use the correct path separator for the OS we are running on\nconst COMMON_PROTO_FILES = commonProtoFiles.map(file => file.replace(/[/\\\\]/g, path.sep));\n/*\n * Async version of readFile.\n *\n * @returns {Promise} Contents of file at path.\n */\nasync function readFileAsync(path) {\n    return new Promise((resolve, reject) => {\n        fs.readFile(path, 'utf8', (err, content) => {\n            if (err)\n                return reject(err);\n            else\n                resolve(content);\n        });\n    });\n}\n/*\n * Async version of execFile.\n *\n * @returns {Promise} stdout from command execution.\n */\nasync function execFileAsync(command, args) {\n    return new Promise((resolve, reject) => {\n        child_process_1.execFile(command, args, (err, stdout) => {\n            if (err)\n                return reject(err);\n            else\n                resolve(stdout);\n        });\n    });\n}\nclass ClientStub extends grpc.Client {\n}\nexports.ClientStub = ClientStub;\nclass GrpcClient {\n    /**\n     * A class which keeps the context of gRPC and auth for the gRPC.\n     *\n     * @param {Object=} options - The optional parameters. It will be directly\n     *   passed to google-auth-library library, so parameters like keyFile or\n     *   credentials will be valid.\n     * @param {Object=} options.auth - An instance of google-auth-library.\n     *   When specified, this auth instance will be used instead of creating\n     *   a new one.\n     * @param {Object=} options.grpc - When specified, this will be used\n     *   for the 'grpc' module in this context. By default, it will load the grpc\n     *   module in the standard way.\n     * @constructor\n     */\n    constructor(options = {}) {\n        var _a;\n        this.auth = options.auth || new google_auth_library_1.GoogleAuth(options);\n        this.fallback = false;\n        const minimumVersion = 10;\n        const major = Number((_a = process.version.match(/^v(\\d+)/)) === null || _a === void 0 ? void 0 : _a[1]);\n        if (Number.isNaN(major) || major < minimumVersion) {\n            const errorMessage = `Node.js v${minimumVersion}.0.0 is a minimum requirement. To learn about legacy version support visit: ` +\n                'https://github.com/googleapis/google-cloud-node#supported-nodejs-versions';\n            throw new Error(errorMessage);\n        }\n        if ('grpc' in options) {\n            this.grpc = options.grpc;\n            this.grpcVersion = '';\n        }\n        else {\n            this.grpc = grpc;\n            this.grpcVersion = require('@grpc/grpc-js/package.json').version;\n        }\n    }\n    /**\n     * Key for proto cache map. We are doing our best to make sure we respect\n     * the options, so if the same proto file is loaded with different set of\n     * options, the cache won't be used.  Since some of the options are\n     * Functions (e.g. `enums: String` - see below in `loadProto()`),\n     * they will be omitted from the cache key.  If the cache breaks anything\n     * for you, use the `ignoreCache` parameter of `loadProto()` to disable it.\n     */\n    static protoCacheKey(filename, options) {\n        if (!filename ||\n            (Array.isArray(filename) && (filename.length === 0 || !filename[0]))) {\n            return undefined;\n        }\n        return JSON.stringify(filename) + ' ' + JSON.stringify(options);\n    }\n    /**\n     * In rare cases users might need to deallocate all memory consumed by loaded protos.\n     * This method will delete the proto cache content.\n     */\n    static clearProtoCache() {\n        GrpcClient.protoCache.clear();\n    }\n    /**\n     * Creates a gRPC credentials. It asks the auth data if necessary.\n     * @private\n     * @param {Object} opts - options values for configuring credentials.\n     * @param {Object=} opts.sslCreds - when specified, this is used instead\n     *   of default channel credentials.\n     * @return {Promise} The promise which will be resolved to the gRPC credential.\n     */\n    async _getCredentials(opts) {\n        if (opts.sslCreds) {\n            return opts.sslCreds;\n        }\n        const grpc = this.grpc;\n        const sslCreds = opts.cert && opts.key\n            ? grpc.credentials.createSsl(null, Buffer.from(opts.key), Buffer.from(opts.cert))\n            : grpc.credentials.createSsl();\n        const client = await this.auth.getClient();\n        const credentials = grpc.credentials.combineChannelCredentials(sslCreds, grpc.credentials.createFromGoogleCredential(client));\n        return credentials;\n    }\n    static defaultOptions() {\n        // This set of @grpc/proto-loader options\n        // 'closely approximates the existing behavior of grpc.load'\n        const includeDirs = INCLUDE_DIRS.slice();\n        const options = {\n            keepCase: false,\n            longs: String,\n            enums: String,\n            defaults: true,\n            oneofs: true,\n            includeDirs,\n        };\n        return options;\n    }\n    /**\n     * Loads the gRPC service from the proto file(s) at the given path and with the\n     * given options. Caches the loaded protos so the subsequent loads don't do\n     * any disk reads.\n     * @param filename The path to the proto file(s).\n     * @param options Options for loading the proto file.\n     * @param ignoreCache Defaults to `false`. Set it to `true` if the caching logic\n     *   incorrectly decides that the options object is the same, or if you want to\n     *   re-read the protos from disk for any other reason.\n     */\n    loadFromProto(filename, options, ignoreCache = false) {\n        const cacheKey = GrpcClient.protoCacheKey(filename, options);\n        let grpcPackage = cacheKey\n            ? GrpcClient.protoCache.get(cacheKey)\n            : undefined;\n        if (ignoreCache || !grpcPackage) {\n            const packageDef = grpcProtoLoader.loadSync(filename, options);\n            grpcPackage = this.grpc.loadPackageDefinition(packageDef);\n            if (cacheKey) {\n                GrpcClient.protoCache.set(cacheKey, grpcPackage);\n            }\n        }\n        return grpcPackage;\n    }\n    /**\n     * Load gRPC proto service from a filename looking in googleapis common protos\n     * when necessary. Caches the loaded protos so the subsequent loads don't do\n     * any disk reads.\n     * @param {String} protoPath - The directory to search for the protofile.\n     * @param {String|String[]} filename - The filename(s) of the proto(s) to be loaded.\n     *   If omitted, protoPath will be treated as a file path to load.\n     * @param ignoreCache Defaults to `false`. Set it to `true` if the caching logic\n     *   incorrectly decides that the options object is the same, or if you want to\n     *   re-read the protos from disk for any other reason.\n     * @return {Object<string, *>} The gRPC loaded result (the toplevel namespace\n     *   object).\n     */\n    loadProto(protoPath, filename, ignoreCache = false) {\n        if (!filename) {\n            filename = path.basename(protoPath);\n            protoPath = path.dirname(protoPath);\n        }\n        if (Array.isArray(filename) && filename.length === 0) {\n            return {};\n        }\n        const options = GrpcClient.defaultOptions();\n        options.includeDirs.unshift(protoPath);\n        return this.loadFromProto(filename, options, ignoreCache);\n    }\n    static _resolveFile(protoPath, filename) {\n        if (fs.existsSync(path.join(protoPath, filename))) {\n            return path.join(protoPath, filename);\n        }\n        else if (COMMON_PROTO_FILES.indexOf(filename) > -1) {\n            return path.join(googleProtoFilesDir, filename);\n        }\n        throw new Error(filename + ' could not be found in ' + protoPath);\n    }\n    loadProtoJSON(json, ignoreCache = false) {\n        const hash = objectHash(json).toString();\n        const cached = GrpcClient.protoCache.get(hash);\n        if (cached && !ignoreCache) {\n            return cached;\n        }\n        const options = GrpcClient.defaultOptions();\n        const packageDefinition = grpcProtoLoader.fromJSON(json, options);\n        const grpcPackage = this.grpc.loadPackageDefinition(packageDefinition);\n        GrpcClient.protoCache.set(hash, grpcPackage);\n        return grpcPackage;\n    }\n    metadataBuilder(headers) {\n        const Metadata = this.grpc.Metadata;\n        const baseMetadata = new Metadata();\n        for (const key in headers) {\n            const value = headers[key];\n            if (Array.isArray(value)) {\n                value.forEach(v => baseMetadata.add(key, v));\n            }\n            else {\n                baseMetadata.set(key, `${value}`);\n            }\n        }\n        return function buildMetadata(abTests, moreHeaders) {\n            // TODO: bring the A/B testing info into the metadata.\n            let copied = false;\n            let metadata = baseMetadata;\n            if (moreHeaders) {\n                for (const key in moreHeaders) {\n                    if (key.toLowerCase() !== 'x-goog-api-client') {\n                        if (!copied) {\n                            copied = true;\n                            metadata = metadata.clone();\n                        }\n                        const value = moreHeaders[key];\n                        if (Array.isArray(value)) {\n                            value.forEach(v => metadata.add(key, v));\n                        }\n                        else {\n                            metadata.set(key, `${value}`);\n                        }\n                    }\n                }\n            }\n            return metadata;\n        };\n    }\n    /**\n     * A wrapper of {@link constructSettings} function under the gRPC context.\n     *\n     * Most of parameters are common among constructSettings, please take a look.\n     * @param {string} serviceName - The fullly-qualified name of the service.\n     * @param {Object} clientConfig - A dictionary of the client config.\n     * @param {Object} configOverrides - A dictionary of overriding configs.\n     * @param {Object} headers - A dictionary of additional HTTP header name to\n     *   its value.\n     * @return {Object} A mapping of method names to CallSettings.\n     */\n    constructSettings(serviceName, clientConfig, configOverrides, headers) {\n        return gax.constructSettings(serviceName, clientConfig, configOverrides, this.grpc.status, { metadataBuilder: this.metadataBuilder(headers) });\n    }\n    /**\n     * Creates a gRPC stub with current gRPC and auth.\n     * @param {function} CreateStub - The constructor function of the stub.\n     * @param {Object} options - The optional arguments to customize\n     *   gRPC connection. This options will be passed to the constructor of\n     *   gRPC client too.\n     * @param {string} options.servicePath - The name of the server of the service.\n     * @param {number} options.port - The port of the service.\n     * @param {grpcTypes.ClientCredentials=} options.sslCreds - The credentials to be used\n     *   to set up gRPC connection.\n     * @param {string} defaultServicePath - The default service path.\n     * @return {Promise} A promise which resolves to a gRPC stub instance.\n     */\n    async createStub(CreateStub, options, customServicePath) {\n        // The following options are understood by grpc-gcp and need a special treatment\n        // (should be passed without a `grpc.` prefix)\n        const grpcGcpOptions = [\n            'grpc.callInvocationTransformer',\n            'grpc.channelFactoryOverride',\n            'grpc.gcpApiConfig',\n        ];\n        const [cert, key] = await this._detectClientCertificate(options);\n        const servicePath = this._mtlsServicePath(options.servicePath, customServicePath, cert && key);\n        const opts = Object.assign({}, options, { cert, key, servicePath });\n        const serviceAddress = servicePath + ':' + opts.port;\n        const creds = await this._getCredentials(opts);\n        const grpcOptions = {};\n        // @grpc/grpc-js limits max receive/send message length starting from v0.8.0\n        // https://github.com/grpc/grpc-node/releases/tag/%40grpc%2Fgrpc-js%400.8.0\n        // To keep the existing behavior and avoid libraries breakage, we pass -1 there as suggested.\n        grpcOptions['grpc.max_receive_message_length'] = -1;\n        grpcOptions['grpc.max_send_message_length'] = -1;\n        grpcOptions['grpc.initial_reconnect_backoff_ms'] = 1000;\n        Object.keys(opts).forEach(key => {\n            const value = options[key];\n            // the older versions had a bug which required users to call an option\n            // grpc.grpc.* to make it actually pass to gRPC as grpc.*, let's handle\n            // this here until the next major release\n            if (key.startsWith('grpc.grpc.')) {\n                key = key.replace(/^grpc\\./, '');\n            }\n            if (key.startsWith('grpc.')) {\n                if (grpcGcpOptions.includes(key)) {\n                    key = key.replace(/^grpc\\./, '');\n                }\n                grpcOptions[key] = value;\n            }\n            if (key.startsWith('grpc-node.')) {\n                grpcOptions[key] = value;\n            }\n        });\n        const stub = new CreateStub(serviceAddress, creds, grpcOptions);\n        return stub;\n    }\n    /**\n     * Detect mTLS client certificate based on logic described in\n     * https://google.aip.dev/auth/4114.\n     *\n     * @param {object} [options] - The configuration object.\n     * @returns {Promise} Resolves array of strings representing cert and key.\n     */\n    async _detectClientCertificate(opts) {\n        var _a;\n        const certRegex = /(?<cert>-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----)/s;\n        const keyRegex = /(?<key>-----BEGIN PRIVATE KEY-----.*?-----END PRIVATE KEY-----)/s;\n        // If GOOGLE_API_USE_CLIENT_CERTIFICATE is true...:\n        if (typeof process !== 'undefined' &&\n            ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.GOOGLE_API_USE_CLIENT_CERTIFICATE) === 'true') {\n            if ((opts === null || opts === void 0 ? void 0 : opts.cert) && (opts === null || opts === void 0 ? void 0 : opts.key)) {\n                return [opts.cert, opts.key];\n            }\n            // If context aware metadata exists, run the cert provider command,\n            // parse the output to extract cert and key, and use this cert/key.\n            const metadataPath = path_1.join(os.homedir(), '.secureConnect', 'context_aware_metadata.json');\n            const metadata = JSON.parse(await readFileAsync(metadataPath));\n            if (!metadata.cert_provider_command) {\n                throw Error('no cert_provider_command found');\n            }\n            const stdout = await execFileAsync(metadata.cert_provider_command[0], metadata.cert_provider_command.slice(1));\n            const matchCert = stdout.toString().match(certRegex);\n            const matchKey = stdout.toString().match(keyRegex);\n            if (!((matchCert === null || matchCert === void 0 ? void 0 : matchCert.groups) && (matchKey === null || matchKey === void 0 ? void 0 : matchKey.groups))) {\n                throw Error('unable to parse certificate and key');\n            }\n            else {\n                return [matchCert.groups.cert, matchKey.groups.key];\n            }\n        }\n        // If GOOGLE_API_USE_CLIENT_CERTIFICATE is not set or false,\n        // use no cert or key:\n        return [undefined, undefined];\n    }\n    /**\n     * Return service path, taking into account mTLS logic.\n     * See: https://google.aip.dev/auth/4114\n     *\n     * @param {string|undefined} servicePath - The path of the service.\n     * @param {string|undefined} customServicePath - Did the user provide a custom service URL.\n     * @param {boolean} hasCertificate - Was a certificate found.\n     * @returns {string} The DNS address for this service.\n     */\n    _mtlsServicePath(servicePath, customServicePath, hasCertificate) {\n        var _a, _b;\n        // If user provides a custom service path, return the current service\n        // path and do not attempt to add mtls subdomain:\n        if (customServicePath || !servicePath)\n            return servicePath;\n        if (typeof process !== 'undefined' &&\n            ((_a = process === null || process === void 0 ? void 0 : process.env) === null || _a === void 0 ? void 0 : _a.GOOGLE_API_USE_MTLS_ENDPOINT) === 'never') {\n            // It was explicitly asked that mtls endpoint not be used:\n            return servicePath;\n        }\n        else if ((typeof process !== 'undefined' &&\n            ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.GOOGLE_API_USE_MTLS_ENDPOINT) === 'always') ||\n            hasCertificate) {\n            // Either auto-detect or explicit setting of endpoint:\n            return servicePath.replace('googleapis.com', 'mtls.googleapis.com');\n        }\n        return servicePath;\n    }\n    /**\n     * Creates a 'bytelength' function for a given proto message class.\n     *\n     * See {@link BundleDescriptor} about the meaning of the return value.\n     *\n     * @param {function} message - a constructor function that is generated by\n     *   protobuf.js. Assumes 'encoder' field in the message.\n     * @return {function(Object):number} - a function to compute the byte length\n     *   for an object.\n     */\n    static createByteLengthFunction(message) {\n        return function getByteLength(obj) {\n            return message.encode(obj).finish().length;\n        };\n    }\n}\nexports.GrpcClient = GrpcClient;\nGrpcClient.protoCache = new Map();\nclass GoogleProtoFilesRoot extends protobuf.Root {\n    constructor(...args) {\n        super(...args);\n    }\n    // Causes the loading of an included proto to check if it is a common\n    // proto. If it is a common proto, use the bundled proto.\n    resolvePath(originPath, includePath) {\n        originPath = path.normalize(originPath);\n        includePath = path.normalize(includePath);\n        // Fully qualified paths don't need to be resolved.\n        if (path.isAbsolute(includePath)) {\n            if (!fs.existsSync(includePath)) {\n                throw new Error('The include `' + includePath + '` was not found.');\n            }\n            return includePath;\n        }\n        if (COMMON_PROTO_FILES.indexOf(includePath) > -1) {\n            return path.join(googleProtoFilesDir, includePath);\n        }\n        return GoogleProtoFilesRoot._findIncludePath(originPath, includePath);\n    }\n    static _findIncludePath(originPath, includePath) {\n        originPath = path.normalize(originPath);\n        includePath = path.normalize(includePath);\n        let current = originPath;\n        let found = fs.existsSync(path.join(current, includePath));\n        while (!found && current.length > 0) {\n            current = current.substring(0, current.lastIndexOf(path.sep));\n            found = fs.existsSync(path.join(current, includePath));\n        }\n        if (!found) {\n            throw new Error('The include `' + includePath + '` was not found.');\n        }\n        return path.join(current, includePath);\n    }\n}\nexports.GoogleProtoFilesRoot = GoogleProtoFilesRoot;\n"]},"metadata":{},"sourceType":"script"}