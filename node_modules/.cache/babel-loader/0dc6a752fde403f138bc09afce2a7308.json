{"ast":null,"code":"// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Parse DNS messages\nvar util = require('util');\n\nvar constants = require('./constants');\n\nmodule.exports = {\n  'id': id,\n  'qr': qr,\n  'aa': aa,\n  'tc': tc,\n  'rd': rd,\n  'ra': ra,\n  'ad': ad,\n  'cd': cd,\n  'rcode': rcode,\n  'opcode': opcode,\n  'record_count': record_count,\n  'record_name': record_name,\n  'record_class': record_class,\n  'record_ttl': record_ttl,\n  'record_type': record_type,\n  'record_data': record_data,\n  'uncompress': uncompress,\n  'sections': sections,\n  'mx': mx,\n  'srv': srv,\n  'soa': soa,\n  'txt': txt\n};\n\nfunction id(msg) {\n  return msg.readUInt16BE(0);\n}\n\nfunction qr(msg) {\n  return msg.readUInt8(2) >> 7;\n}\n\nfunction opcode(msg) {\n  return msg.readUInt8(2) >> 3 & 0x0f;\n}\n\nfunction aa(msg) {\n  return msg.readUInt8(2) >> 2 & 0x01;\n}\n\nfunction tc(msg) {\n  return msg.readUInt8(2) >> 1 & 0x01;\n}\n\nfunction rd(msg) {\n  return msg.readUInt8(2) & 0x01;\n}\n\nfunction ra(msg) {\n  return msg.readUInt8(3) >> 7;\n}\n\nfunction ad(msg) {\n  return msg.readUInt8(3) >> 5 & 0x01;\n}\n\nfunction cd(msg) {\n  return msg.readUInt8(3) >> 4 & 0x01;\n}\n\nfunction rcode(msg) {\n  return msg.readUInt8(3) & 0x0f;\n}\n\nfunction record_count(msg, name) {\n  if (name == 'question') return msg.readUInt16BE(4);else if (name == 'answer') return msg.readUInt16BE(6);else if (name == 'authority') return msg.readUInt16BE(8);else if (name == 'additional') return msg.readUInt16BE(10);else throw new Error('Unknown section name: ' + name);\n}\n\nfunction record_name(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.name;\n}\n\nfunction record_class(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.class;\n}\n\nfunction record_type(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.type;\n}\n\nfunction record_ttl(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.ttl;\n}\n\nfunction record_data(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.data;\n}\n\nfunction record_class(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset);\n  return rec.class;\n}\n\nfunction record(msg, section_name, offset) {\n  if (typeof offset != 'number' || isNaN(offset) || offset < 0) throw new Error('Offset must be a natural number'); // Support msg being a previously-parsed sections object.\n\n  var sects = Buffer.isBuffer(msg) ? sections(msg) : msg;\n  var records = sects[section_name];\n  if (!records) throw new Error('No such section: \"' + section_name + '\"');\n  var rec = records[offset];\n  if (!rec) throw new Error('Bad offset for section \"' + section_name + '\": ' + offset);\n  return rec;\n}\n\nfunction sections(msg) {\n  // Count the times this message has been parsed, for debugging and testing purposes.\n  if ('__parsed' in msg) msg.__parsed += 1;\n  var position = 12 // First byte of the first section\n  ,\n      result = {\n    'question': [],\n    'answer': [],\n    'authority': [],\n    'additional': []\n  },\n      need = {\n    'question': record_count(msg, 'question'),\n    'answer': record_count(msg, 'answer'),\n    'authority': record_count(msg, 'authority'),\n    'additional': record_count(msg, 'additional')\n  };\n  var states = ['question', 'answer', 'authority', 'additional', 'done'],\n      state = states.shift();\n\n  while (true) {\n    if (state == 'done') return result;else if (result[state].length == need[state]) state = states.shift();else if (!state) throw new Error('Unknown parsing state at position ' + position + ': ' + JSON.stringify(state));else add_record();\n  }\n\n  function add_record() {\n    var record = {};\n    var data = domain_parts(msg, position);\n    record.name = data.parts.join('.');\n    position += data.length;\n    record.type = msg.readUInt16BE(position + 0);\n    record.class = msg.readUInt16BE(position + 2);\n    position += 4;\n\n    if (state != 'question') {\n      record.ttl = msg.readUInt32BE(position + 0);\n      var rdata_len = msg.readUInt16BE(position + 4);\n      position += 6;\n      record.data = msg.slice(position, position + rdata_len);\n      position += rdata_len;\n\n      if (constants.type(record.type) === 'OPT') {\n        // EDNS\n        if (record.name !== '') throw new Error('EDNS record option for non-root domain: ' + record.name);\n        record.udp_size = record.class;\n        delete record.class;\n        record.extended_rcode = record.ttl >> 24;\n        record.edns_version = record.ttl >> 16 & 0xff;\n        record.zero = record.ttl >> 8;\n        delete record.ttl;\n        record.data = Array.prototype.slice.call(record.data);\n      }\n    }\n\n    result[state] = result[state] || [];\n    result[state].push(record);\n  }\n}\n\nfunction mx(msg, data) {\n  return [data.readUInt16BE(0), uncompress(msg, data.slice(2))];\n}\n\nfunction srv(msg, data) {\n  return {\n    'priority': data.readUInt16BE(0),\n    'weight': data.readUInt16BE(2),\n    'port': data.readUInt16BE(4),\n    'target': uncompress(msg, data.slice(6)) // Techncially compression is not allowed in RFC 2782.\n\n  };\n}\n\nfunction soa(msg, data) {\n  var result = domain_parts(msg, data),\n      offset = result.length,\n      mname = result.parts.join('.');\n  result = domain_parts(msg, data.slice(offset));\n  var rname = result.parts.join('.');\n  offset += result.length;\n  return {\n    'mname': mname,\n    'rname': rname //.replace(/\\./, '@')\n    ,\n    'serial': data.readUInt32BE(offset + 0),\n    'refresh': data.readUInt32BE(offset + 4),\n    'retry': data.readUInt32BE(offset + 8),\n    'expire': data.readUInt32BE(offset + 12),\n    'ttl': data.readUInt32BE(offset + 16)\n  };\n}\n\nfunction txt(msg, data) {\n  var parts = [];\n\n  while (data.length) {\n    var len = data.readUInt8(0);\n    parts.push(data.slice(1, 1 + len).toString('ascii'));\n    data = data.slice(1 + len);\n  }\n\n  return parts;\n}\n\nfunction uncompress(msg, offset) {\n  var data = domain_parts(msg, offset);\n  return data.parts.join('.');\n}\n\nfunction domain_parts(msg, offset) {\n  if (Buffer.isBuffer(offset)) {\n    var full_message = msg;\n    msg = offset;\n    offset = 0;\n  }\n\n  if (typeof offset != 'number' || isNaN(offset) || offset < 0 || offset > msg.length) throw new Error('Bad offset: ' + offset);\n  var parts = [],\n      real_length = 0,\n      jumped = false;\n  var i = 0;\n\n  while (true) {\n    if (++i >= 100) throw new Error('Too many iterations uncompressing name');\n    var byte = msg.readUInt8(offset),\n        flags = byte >> 6,\n        len = byte & 0x3f; // 0 - 63\n\n    offset += 1;\n    add_length(1);\n\n    if (flags === 0x03) {\n      offset = (len << 8) + msg.readUInt8(offset);\n      add_length(1);\n      jumped = true; // If processing so far has just been on some given fragment, begin using the full message now.\n\n      msg = full_message || msg;\n    } else if (len == 0) return {\n      'parts': parts,\n      'length': real_length\n    };else {\n      parts.push(msg.toString('ascii', offset, offset + len));\n      offset += len;\n      add_length(len);\n    }\n  }\n\n  function add_length(amount) {\n    if (!jumped) real_length += amount;\n  }\n}","map":{"version":3,"sources":["C:/react/quiz/node_modules/hbo-dnsd/parse.js"],"names":["util","require","constants","module","exports","id","qr","aa","tc","rd","ra","ad","cd","rcode","opcode","record_count","record_name","record_class","record_ttl","record_type","record_data","uncompress","sections","mx","srv","soa","txt","msg","readUInt16BE","readUInt8","name","Error","section_name","offset","rec","record","class","type","ttl","data","isNaN","sects","Buffer","isBuffer","records","__parsed","position","result","need","states","state","shift","length","JSON","stringify","add_record","domain_parts","parts","join","readUInt32BE","rdata_len","slice","udp_size","extended_rcode","edns_version","zero","Array","prototype","call","push","mname","rname","len","toString","full_message","real_length","jumped","i","byte","flags","add_length","amount"],"mappings":"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","sourcesContent":["// Copyright 2012 Iris Couch, all rights reserved.\n//\n// Parse DNS messages\n\nvar util = require('util')\n\nvar constants = require('./constants')\n\nmodule.exports = { 'id': id\n                 , 'qr': qr\n                 , 'aa': aa\n                 , 'tc': tc\n                 , 'rd': rd\n                 , 'ra': ra\n                 , 'ad': ad\n                 , 'cd': cd\n                 , 'rcode': rcode\n                 , 'opcode': opcode\n                 , 'record_count': record_count\n                 , 'record_name' : record_name\n                 , 'record_class': record_class\n                 , 'record_ttl'  : record_ttl\n                 , 'record_type' : record_type\n                 , 'record_data' : record_data\n                 , 'uncompress'  : uncompress\n                 , 'sections'    : sections\n                 , 'mx': mx\n                 , 'srv': srv\n                 , 'soa': soa\n                 , 'txt': txt\n                 }\n\n\nfunction id(msg) {\n  return msg.readUInt16BE(0)\n}\n\nfunction qr(msg) {\n  return msg.readUInt8(2) >> 7\n}\n\nfunction opcode(msg) {\n  return (msg.readUInt8(2) >> 3) & 0x0f\n}\n\nfunction aa(msg) {\n  return (msg.readUInt8(2) >> 2) & 0x01\n}\n\nfunction tc(msg) {\n  return (msg.readUInt8(2) >> 1) & 0x01\n}\n\nfunction rd(msg) {\n  return msg.readUInt8(2) & 0x01\n}\n\nfunction ra(msg) {\n  return msg.readUInt8(3) >> 7\n}\n\nfunction ad(msg) {\n  return msg.readUInt8(3) >> 5 & 0x01\n}\n\nfunction cd(msg) {\n  return msg.readUInt8(3) >> 4 & 0x01\n}\n\nfunction rcode(msg) {\n  return msg.readUInt8(3) & 0x0f\n}\n\nfunction record_count(msg, name) {\n  if(name == 'question')\n    return msg.readUInt16BE(4)\n  else if(name == 'answer')\n    return msg.readUInt16BE(6)\n  else if(name == 'authority')\n    return msg.readUInt16BE(8)\n  else if(name == 'additional')\n    return msg.readUInt16BE(10)\n  else\n    throw new Error('Unknown section name: ' + name)\n}\n\nfunction record_name(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset)\n  return rec.name\n}\n\nfunction record_class(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset)\n  return rec.class\n}\n\nfunction record_type(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset)\n  return rec.type\n}\n\nfunction record_ttl(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset)\n  return rec.ttl\n}\n\nfunction record_data(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset)\n  return rec.data\n}\n\nfunction record_class(msg, section_name, offset) {\n  var rec = record(msg, section_name, offset)\n  return rec.class\n}\n\nfunction record(msg, section_name, offset) {\n  if(typeof offset != 'number' || isNaN(offset) || offset < 0)\n    throw new Error('Offset must be a natural number')\n\n  // Support msg being a previously-parsed sections object.\n  var sects = Buffer.isBuffer(msg)\n                ? sections(msg)\n                : msg\n\n  var records = sects[section_name]\n  if(!records)\n    throw new Error('No such section: \"'+section_name+'\"')\n\n  var rec = records[offset]\n  if(!rec)\n    throw new Error('Bad offset for section \"'+section_name+'\": ' + offset)\n\n  return rec\n}\n\nfunction sections(msg) {\n  // Count the times this message has been parsed, for debugging and testing purposes.\n  if('__parsed' in msg)\n    msg.__parsed += 1\n\n  var position = 12 // First byte of the first section\n    , result = {'question':[], 'answer':[], 'authority':[], 'additional':[]}\n    , need = { 'question'  : record_count(msg, 'question')\n             , 'answer'    : record_count(msg, 'answer')\n             , 'authority' : record_count(msg, 'authority')\n             , 'additional': record_count(msg, 'additional')\n             }\n\n  var states = ['question', 'answer', 'authority', 'additional', 'done']\n    , state = states.shift()\n\n  while(true) {\n    if(state == 'done')\n      return result\n    else if(result[state].length == need[state])\n      state = states.shift()\n    else if(!state)\n      throw new Error('Unknown parsing state at position '+position+': '+JSON.stringify(state))\n    else\n      add_record()\n  }\n\n  function add_record() {\n    var record = {}\n\n    var data = domain_parts(msg, position)\n    record.name = data.parts.join('.')\n    position += data.length\n\n    record.type  = msg.readUInt16BE(position + 0)\n    record.class = msg.readUInt16BE(position + 2)\n    position += 4\n\n    if(state != 'question') {\n      record.ttl    = msg.readUInt32BE(position + 0)\n      var rdata_len = msg.readUInt16BE(position + 4)\n\n      position += 6\n      record.data = msg.slice(position, position + rdata_len)\n\n      position += rdata_len\n\n      if(constants.type(record.type) === 'OPT') {\n        // EDNS\n        if(record.name !== '')\n          throw new Error('EDNS record option for non-root domain: ' + record.name)\n\n        record.udp_size = record.class\n        delete record.class\n\n        record.extended_rcode = (record.ttl >> 24)\n        record.edns_version   = (record.ttl >> 16) & 0xff\n        record.zero           = (record.ttl >>  8)\n        delete record.ttl\n\n        record.data = Array.prototype.slice.call(record.data)\n      }\n    }\n\n    result[state] = result[state] || []\n    result[state].push(record)\n  }\n}\n\nfunction mx(msg, data) {\n  return [ data.readUInt16BE(0)\n         , uncompress(msg, data.slice(2))\n         ]\n}\n\nfunction srv(msg, data) {\n  return { 'priority': data.readUInt16BE(0)\n         , 'weight'  : data.readUInt16BE(2)\n         , 'port'    : data.readUInt16BE(4)\n         , 'target'  : uncompress(msg, data.slice(6)) // Techncially compression is not allowed in RFC 2782.\n         }\n}\n\nfunction soa(msg, data) {\n  var result = domain_parts(msg, data)\n    , offset = result.length\n    , mname = result.parts.join('.')\n\n  result = domain_parts(msg, data.slice(offset))\n  var rname = result.parts.join('.')\n  offset += result.length\n\n  return { 'mname'  : mname\n         , 'rname'  : rname //.replace(/\\./, '@')\n         , 'serial' : data.readUInt32BE(offset + 0)\n         , 'refresh': data.readUInt32BE(offset + 4)\n         , 'retry'  : data.readUInt32BE(offset + 8)\n         , 'expire' : data.readUInt32BE(offset + 12)\n         , 'ttl'    : data.readUInt32BE(offset + 16)\n         }\n}\n\nfunction txt(msg, data) {\n  var parts = []\n  while(data.length) {\n    var len = data.readUInt8(0)\n    parts.push(data.slice(1, 1+len).toString('ascii'))\n    data = data.slice(1+len)\n  }\n\n  return parts\n}\n\nfunction uncompress(msg, offset) {\n  var data = domain_parts(msg, offset)\n  return data.parts.join('.')\n}\n\nfunction domain_parts(msg, offset) {\n  if(Buffer.isBuffer(offset)) {\n    var full_message = msg\n    msg = offset\n    offset = 0\n  }\n\n  if(typeof offset != 'number' || isNaN(offset) || offset < 0 || offset > msg.length)\n    throw new Error('Bad offset: ' + offset)\n\n  var parts = []\n    , real_length = 0\n    , jumped = false\n\n  var i = 0\n  while(true) {\n    if(++i >= 100)\n      throw new Error('Too many iterations uncompressing name')\n\n    var byte = msg.readUInt8(offset)\n      , flags = byte >> 6\n      , len   = byte & 0x3f // 0 - 63\n\n    offset += 1\n    add_length(1)\n\n    if(flags === 0x03) {\n      offset = (len << 8) + msg.readUInt8(offset)\n      add_length(1)\n      jumped = true\n\n      // If processing so far has just been on some given fragment, begin using the full message now.\n      msg = full_message || msg\n    }\n\n    else if(len == 0)\n      return {'parts':parts, 'length':real_length}\n\n    else {\n      parts.push(msg.toString('ascii', offset, offset + len))\n\n      offset += len\n      add_length(len)\n    }\n  }\n\n  function add_length(amount) {\n    if(! jumped)\n      real_length += amount\n  }\n}\n"]},"metadata":{},"sourceType":"script"}