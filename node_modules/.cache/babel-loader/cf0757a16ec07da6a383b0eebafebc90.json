{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompressionFilterFactory = exports.CompressionFilter = void 0;\n\nconst zlib = require(\"zlib\");\n\nconst compression_algorithms_1 = require(\"./compression-algorithms\");\n\nconst constants_1 = require(\"./constants\");\n\nconst filter_1 = require(\"./filter\");\n\nconst logging = require(\"./logging\");\n\nconst isCompressionAlgorithmKey = key => {\n  return typeof key === 'number' && typeof compression_algorithms_1.CompressionAlgorithms[key] === 'string';\n};\n\nclass CompressionHandler {\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  async writeMessage(message, compress) {\n    let messageBuffer = message;\n\n    if (compress) {\n      messageBuffer = await this.compressMessage(messageBuffer);\n    }\n\n    const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n    output.writeUInt8(compress ? 1 : 0, 0);\n    output.writeUInt32BE(messageBuffer.length, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n\n\n  async readMessage(data) {\n    const compressed = data.readUInt8(0) === 1;\n    let messageBuffer = data.slice(5);\n\n    if (compressed) {\n      messageBuffer = await this.decompressMessage(messageBuffer);\n    }\n\n    return messageBuffer;\n  }\n\n}\n\nclass IdentityHandler extends CompressionHandler {\n  async compressMessage(message) {\n    return message;\n  }\n\n  async writeMessage(message, compress) {\n    const output = Buffer.allocUnsafe(message.length + 5);\n    /* With \"identity\" compression, messages should always be marked as\n     * uncompressed */\n\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(message.length, 1);\n    message.copy(output, 5);\n    return output;\n  }\n\n  decompressMessage(message) {\n    return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n  }\n\n}\n\nclass DeflateHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.inflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass GzipHandler extends CompressionHandler {\n  compressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message) {\n    return new Promise((resolve, reject) => {\n      zlib.unzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n}\n\nclass UnknownHandler extends CompressionHandler {\n  constructor(compressionName) {\n    super();\n    this.compressionName = compressionName;\n  }\n\n  compressMessage(message) {\n    return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));\n  }\n\n  decompressMessage(message) {\n    // This should be unreachable\n    return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));\n  }\n\n}\n\nfunction getCompressionHandler(compressionName) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n\n    case 'deflate':\n      return new DeflateHandler();\n\n    case 'gzip':\n      return new GzipHandler();\n\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nclass CompressionFilter extends filter_1.BaseFilter {\n  constructor(channelOptions, sharedFilterConfig) {\n    var _a;\n\n    super();\n    this.sharedFilterConfig = sharedFilterConfig;\n    this.sendCompression = new IdentityHandler();\n    this.receiveCompression = new IdentityHandler();\n    this.currentCompressionAlgorithm = 'identity';\n    const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n\n    if (compressionAlgorithmKey !== undefined) {\n      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n        const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];\n        const serverSupportedEncodings = (_a = sharedFilterConfig.serverSupportedEncodingHeader) === null || _a === void 0 ? void 0 : _a.split(',');\n        /**\n         * There are two possible situations here:\n         * 1) We don't have any info yet from the server about what compression it supports\n         *    In that case we should just use what the client tells us to use\n         * 2) We've previously received a response from the server including a grpc-accept-encoding header\n         *    In that case we only want to use the encoding chosen by the client if the server supports it\n         */\n\n        if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n          this.currentCompressionAlgorithm = clientSelectedEncoding;\n          this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n        }\n      } else {\n        logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n      }\n    }\n  }\n\n  async sendMetadata(metadata) {\n    const headers = await metadata;\n    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n    headers.set('accept-encoding', 'identity'); // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n\n    if (this.currentCompressionAlgorithm === 'identity') {\n      headers.remove('grpc-encoding');\n    } else {\n      headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n    }\n\n    return headers;\n  }\n\n  receiveMetadata(metadata) {\n    const receiveEncoding = metadata.get('grpc-encoding');\n\n    if (receiveEncoding.length > 0) {\n      const encoding = receiveEncoding[0];\n\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding);\n      }\n    }\n\n    metadata.remove('grpc-encoding');\n    /* Check to see if the compression we're using to send messages is supported by the server\n     * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n\n    const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0];\n\n    if (serverSupportedEncodingsHeader) {\n      this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n      const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n\n      if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n        this.sendCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n      }\n    }\n\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  async sendMessage(message) {\n    var _a;\n    /* This filter is special. The input message is the bare message bytes,\n     * and the output is a framed and possibly compressed message. For this\n     * reason, this filter should be at the bottom of the filter stack */\n\n\n    const resolvedMessage = await message;\n    let compress;\n\n    if (this.sendCompression instanceof IdentityHandler) {\n      compress = false;\n    } else {\n      compress = (((_a = resolvedMessage.flags) !== null && _a !== void 0 ? _a : 0) & 2\n      /* NoCompress */\n      ) === 0;\n    }\n\n    return {\n      message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),\n      flags: resolvedMessage.flags\n    };\n  }\n\n  async receiveMessage(message) {\n    /* This filter is also special. The input message is framed and possibly\n     * compressed, and the output message is deframed and uncompressed. So\n     * this is another reason that this filter should be at the bottom of the\n     * filter stack. */\n    return this.receiveCompression.readMessage(await message);\n  }\n\n}\n\nexports.CompressionFilter = CompressionFilter;\n\nclass CompressionFilterFactory {\n  constructor(channel, options) {\n    this.channel = channel;\n    this.options = options;\n    this.sharedFilterConfig = {};\n  }\n\n  createFilter(callStream) {\n    return new CompressionFilter(this.options, this.sharedFilterConfig);\n  }\n\n}\n\nexports.CompressionFilterFactory = CompressionFilterFactory;","map":{"version":3,"sources":["C:\\react\\quiz\\node_modules\\@grpc\\grpc-js\\src\\compression-filter.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as zlib from 'zlib';\n\nimport { Call, WriteObject, WriteFlags } from './call-stream';\nimport { Channel } from './channel';\nimport { ChannelOptions } from './channel-options';\nimport { CompressionAlgorithms } from './compression-algorithms';\nimport { LogVerbosity } from './constants';\nimport { BaseFilter, Filter, FilterFactory } from './filter';\nimport * as logging from './logging';\nimport { Metadata, MetadataValue } from './metadata';\n\nconst isCompressionAlgorithmKey = (key: number): key is CompressionAlgorithms => {\n  return typeof key === 'number' && typeof CompressionAlgorithms[key] === 'string';\n}\n\ntype CompressionAlgorithm = keyof typeof CompressionAlgorithms;\n\ntype SharedCompressionFilterConfig = {\n  serverSupportedEncodingHeader?: string;\n};\n\nabstract class CompressionHandler {\n  protected abstract compressMessage(message: Buffer): Promise<Buffer>;\n  protected abstract decompressMessage(data: Buffer): Promise<Buffer>;\n  /**\n   * @param message Raw uncompressed message bytes\n   * @param compress Indicates whether the message should be compressed\n   * @return Framed message, compressed if applicable\n   */\n  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> {\n    let messageBuffer = message;\n    if (compress) {\n      messageBuffer = await this.compressMessage(messageBuffer);\n    }\n    const output = Buffer.allocUnsafe(messageBuffer.length + 5);\n    output.writeUInt8(compress ? 1 : 0, 0);\n    output.writeUInt32BE(messageBuffer.length, 1);\n    messageBuffer.copy(output, 5);\n    return output;\n  }\n  /**\n   * @param data Framed message, possibly compressed\n   * @return Uncompressed message\n   */\n  async readMessage(data: Buffer): Promise<Buffer> {\n    const compressed = data.readUInt8(0) === 1;\n    let messageBuffer = data.slice(5);\n    if (compressed) {\n      messageBuffer = await this.decompressMessage(messageBuffer);\n    }\n    return messageBuffer;\n  }\n}\n\nclass IdentityHandler extends CompressionHandler {\n  async compressMessage(message: Buffer) {\n    return message;\n  }\n\n  async writeMessage(message: Buffer, compress: boolean): Promise<Buffer> {\n    const output = Buffer.allocUnsafe(message.length + 5);\n    /* With \"identity\" compression, messages should always be marked as\n     * uncompressed */\n    output.writeUInt8(0, 0);\n    output.writeUInt32BE(message.length, 1);\n    message.copy(output, 5);\n    return output;\n  }\n\n  decompressMessage(message: Buffer): Promise<Buffer> {\n    return Promise.reject<Buffer>(\n      new Error(\n        'Received compressed message but \"grpc-encoding\" header was identity'\n      )\n    );\n  }\n}\n\nclass DeflateHandler extends CompressionHandler {\n  compressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.deflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.inflate(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n}\n\nclass GzipHandler extends CompressionHandler {\n  compressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.gzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n\n  decompressMessage(message: Buffer) {\n    return new Promise<Buffer>((resolve, reject) => {\n      zlib.unzip(message, (err, output) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(output);\n        }\n      });\n    });\n  }\n}\n\nclass UnknownHandler extends CompressionHandler {\n  constructor(private readonly compressionName: string) {\n    super();\n  }\n  compressMessage(message: Buffer): Promise<Buffer> {\n    return Promise.reject<Buffer>(\n      new Error(\n        `Received message compressed with unsupported compression method ${this.compressionName}`\n      )\n    );\n  }\n\n  decompressMessage(message: Buffer): Promise<Buffer> {\n    // This should be unreachable\n    return Promise.reject<Buffer>(\n      new Error(`Compression method not supported: ${this.compressionName}`)\n    );\n  }\n}\n\nfunction getCompressionHandler(compressionName: string): CompressionHandler {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n    case 'deflate':\n      return new DeflateHandler();\n    case 'gzip':\n      return new GzipHandler();\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nexport class CompressionFilter extends BaseFilter implements Filter {\n  private sendCompression: CompressionHandler = new IdentityHandler();\n  private receiveCompression: CompressionHandler = new IdentityHandler();\n  private currentCompressionAlgorithm: CompressionAlgorithm = 'identity';\n\n  constructor(channelOptions: ChannelOptions, private sharedFilterConfig: SharedCompressionFilterConfig) {\n    super();\n\n    const compressionAlgorithmKey = channelOptions['grpc.default_compression_algorithm'];\n    if (compressionAlgorithmKey !== undefined) {\n      if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {\n        const clientSelectedEncoding = CompressionAlgorithms[compressionAlgorithmKey] as CompressionAlgorithm;\n        const serverSupportedEncodings = sharedFilterConfig.serverSupportedEncodingHeader?.split(',');\n        /**\n         * There are two possible situations here:\n         * 1) We don't have any info yet from the server about what compression it supports\n         *    In that case we should just use what the client tells us to use\n         * 2) We've previously received a response from the server including a grpc-accept-encoding header\n         *    In that case we only want to use the encoding chosen by the client if the server supports it\n         */\n        if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {\n          this.currentCompressionAlgorithm = clientSelectedEncoding;\n          this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm);\n        }\n      } else {\n        logging.log(LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);\n      }\n    }\n  }\n\n  async sendMetadata(metadata: Promise<Metadata>): Promise<Metadata> {\n    const headers: Metadata = await metadata;\n    headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n    headers.set('accept-encoding', 'identity');\n\n    // No need to send the header if it's \"identity\" -  behavior is identical; save the bandwidth\n    if (this.currentCompressionAlgorithm === 'identity') {\n      headers.remove('grpc-encoding');\n    } else {\n      headers.set('grpc-encoding', this.currentCompressionAlgorithm);\n    }\n\n    return headers;\n  }\n\n  receiveMetadata(metadata: Metadata): Metadata {\n    const receiveEncoding: MetadataValue[] = metadata.get('grpc-encoding');\n    if (receiveEncoding.length > 0) {\n      const encoding: MetadataValue = receiveEncoding[0];\n      if (typeof encoding === 'string') {\n        this.receiveCompression = getCompressionHandler(encoding);\n      }\n    }\n    metadata.remove('grpc-encoding');\n\n    /* Check to see if the compression we're using to send messages is supported by the server\n     * If not, reset the sendCompression filter and have it use the default IdentityHandler */\n    const serverSupportedEncodingsHeader = metadata.get('grpc-accept-encoding')[0] as string | undefined;\n    if (serverSupportedEncodingsHeader) {\n      this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;\n      const serverSupportedEncodings = serverSupportedEncodingsHeader.split(',');\n\n      if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {\n        this.sendCompression = new IdentityHandler();\n        this.currentCompressionAlgorithm = 'identity';\n      }\n    }\n    metadata.remove('grpc-accept-encoding');\n    return metadata;\n  }\n\n  async sendMessage(message: Promise<WriteObject>): Promise<WriteObject> {\n    /* This filter is special. The input message is the bare message bytes,\n     * and the output is a framed and possibly compressed message. For this\n     * reason, this filter should be at the bottom of the filter stack */\n    const resolvedMessage: WriteObject = await message;\n    let compress: boolean;\n    if (this.sendCompression instanceof IdentityHandler) {\n      compress = false;\n    } else {\n      compress = ((resolvedMessage.flags ?? 0) & WriteFlags.NoCompress) === 0;\n    }\n\n    return {\n      message: await this.sendCompression.writeMessage(\n        resolvedMessage.message,\n        compress\n      ),\n      flags: resolvedMessage.flags,\n    };\n  }\n\n  async receiveMessage(message: Promise<Buffer>) {\n    /* This filter is also special. The input message is framed and possibly\n     * compressed, and the output message is deframed and uncompressed. So\n     * this is another reason that this filter should be at the bottom of the\n     * filter stack. */\n    return this.receiveCompression.readMessage(await message);\n  }\n}\n\nexport class CompressionFilterFactory\n  implements FilterFactory<CompressionFilter> {\n    private sharedFilterConfig: SharedCompressionFilterConfig = {};\n  constructor(private readonly channel: Channel, private readonly options: ChannelOptions) {}\n  createFilter(callStream: Call): CompressionFilter {\n    return new CompressionFilter(this.options, this.sharedFilterConfig);\n  }\n}\n"]},"metadata":{},"sourceType":"script"}