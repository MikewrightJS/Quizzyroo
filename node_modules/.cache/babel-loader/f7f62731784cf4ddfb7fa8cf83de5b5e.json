{"ast":null,"code":"// Copyright 2011 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n// TODO: change the default UDP packet size that node-dns sends\n//       from 4096 to conform to these:\n//       - [requestor's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.3)\n//       - [responders's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.4)\n'use strict';\n\nvar consts = require('./consts'),\n    BufferCursor = require('buffercursor'),\n    BufferCursorOverflow = BufferCursor.BufferCursorOverflow,\n    ipaddr = require('ipaddr.js'),\n    assert = require('assert'),\n    util = require('util');\n\nfunction assertUndefined(val, msg) {\n  assert(typeof val != 'undefined', msg);\n}\n\nvar Packet = module.exports = function () {\n  this.header = {\n    id: 0,\n    qr: 0,\n    opcode: 0,\n    aa: 0,\n    tc: 0,\n    rd: 1,\n    ra: 0,\n    res1: 0,\n    res2: 0,\n    res3: 0,\n    rcode: 0\n  };\n  this.question = [];\n  this.answer = [];\n  this.authority = [];\n  this.additional = [];\n  this.edns_options = []; // TODO: DEPRECATED! Use `.edns.options` instead!\n\n  this.payload = undefined; // TODO: DEPRECATED! Use `.edns.payload` instead!\n};\n\nvar LABEL_POINTER = 0xC0;\n\nvar isPointer = function (len) {\n  return (len & LABEL_POINTER) === LABEL_POINTER;\n};\n\nfunction nameUnpack(buff) {\n  var len,\n      comp,\n      end,\n      pos,\n      part,\n      combine = '';\n  len = buff.readUInt8();\n  comp = false;\n  end = buff.tell();\n\n  while (len !== 0) {\n    if (isPointer(len)) {\n      len -= LABEL_POINTER;\n      len = len << 8;\n      pos = len + buff.readUInt8();\n      if (!comp) end = buff.tell();\n      buff.seek(pos);\n      len = buff.readUInt8();\n      comp = true;\n      continue;\n    }\n\n    part = buff.toString('ascii', len);\n    if (combine.length) combine = combine + '.' + part;else combine = part;\n    len = buff.readUInt8();\n    if (!comp) end = buff.tell();\n  }\n\n  buff.seek(end);\n  return combine;\n}\n\nfunction namePack(str, buff, index) {\n  var offset, dot, part;\n\n  while (str) {\n    if (index[str]) {\n      offset = (LABEL_POINTER << 8) + index[str];\n      buff.writeUInt16BE(offset);\n      break;\n    } else {\n      index[str] = buff.tell();\n      dot = str.indexOf('.');\n\n      if (dot > -1) {\n        part = str.slice(0, dot);\n        str = str.slice(dot + 1);\n      } else {\n        part = str;\n        str = undefined;\n      }\n\n      buff.writeUInt8(part.length);\n      buff.write(part, part.length, 'ascii');\n    }\n  }\n\n  if (!str) {\n    buff.writeUInt8(0);\n  }\n}\n\nvar WRITE_HEADER = 100001,\n    WRITE_TRUNCATE = 100002,\n    WRITE_QUESTION = 100003,\n    WRITE_RESOURCE_RECORD = 100004,\n    WRITE_RESOURCE_WRITE = 100005,\n    WRITE_RESOURCE_DONE = 100006,\n    WRITE_RESOURCE_END = 100007,\n    WRITE_EDNS = 100008,\n    WRITE_END = 100009,\n    WRITE_A = consts.NAME_TO_QTYPE.A,\n    WRITE_AAAA = consts.NAME_TO_QTYPE.AAAA,\n    WRITE_NS = consts.NAME_TO_QTYPE.NS,\n    WRITE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n    WRITE_PTR = consts.NAME_TO_QTYPE.PTR,\n    WRITE_SPF = consts.NAME_TO_QTYPE.SPF,\n    WRITE_MX = consts.NAME_TO_QTYPE.MX,\n    WRITE_SRV = consts.NAME_TO_QTYPE.SRV,\n    WRITE_TXT = consts.NAME_TO_QTYPE.TXT,\n    WRITE_SOA = consts.NAME_TO_QTYPE.SOA,\n    WRITE_OPT = consts.NAME_TO_QTYPE.OPT,\n    WRITE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n    WRITE_TLSA = consts.NAME_TO_QTYPE.TLSA;\n\nfunction writeHeader(buff, packet) {\n  assert(packet.header, 'Packet requires \"header\"');\n  buff.writeUInt16BE(packet.header.id & 0xFFFF);\n  var val = 0;\n  val += packet.header.qr << 15 & 0x8000;\n  val += packet.header.opcode << 11 & 0x7800;\n  val += packet.header.aa << 10 & 0x400;\n  val += packet.header.tc << 9 & 0x200;\n  val += packet.header.rd << 8 & 0x100;\n  val += packet.header.ra << 7 & 0x80;\n  val += packet.header.res1 << 6 & 0x40;\n  val += packet.header.res2 << 5 & 0x20;\n  val += packet.header.res3 << 4 & 0x10;\n  val += packet.header.rcode & 0xF;\n  buff.writeUInt16BE(val & 0xFFFF);\n  assert(packet.question.length == 1, 'DNS requires one question'); // aren't used\n\n  buff.writeUInt16BE(1); // answer offset 6\n\n  buff.writeUInt16BE(packet.answer.length & 0xFFFF); // authority offset 8\n\n  buff.writeUInt16BE(packet.authority.length & 0xFFFF); // additional offset 10\n\n  buff.writeUInt16BE(packet.additional.length & 0xFFFF);\n  return WRITE_QUESTION;\n}\n\nfunction writeTruncate(buff, packet, section, val) {\n  // XXX FIXME TODO truncation is currently done wrong.\n  // Quote rfc2181 section 9\n  // The TC bit should not be set merely because some extra information\n  // could have been included, but there was insufficient room.  This\n  // includes the results of additional section processing.  In such cases\n  // the entire RRSet that will not fit in the response should be omitted,\n  // and the reply sent as is, with the TC bit clear.  If the recipient of\n  // the reply needs the omitted data, it can construct a query for that\n  // data and send that separately.\n  //\n  // TODO IOW only set TC if we hit it in ANSWERS otherwise make sure an\n  // entire RRSet is removed during a truncation.\n  var pos;\n  buff.seek(2);\n  val = buff.readUInt16BE();\n  val |= 1 << 9 & 0x200;\n  buff.seek(2);\n  buff.writeUInt16BE(val);\n\n  switch (section) {\n    case 'answer':\n      pos = 6; // seek to authority and clear it and additional out\n\n      buff.seek(8);\n      buff.writeUInt16BE(0);\n      buff.writeUInt16BE(0);\n      break;\n\n    case 'authority':\n      pos = 8; // seek to additional and clear it out\n\n      buff.seek(10);\n      buff.writeUInt16BE(0);\n      break;\n\n    case 'additional':\n      pos = 10;\n      break;\n  }\n\n  buff.seek(pos);\n  buff.writeUInt16BE(count - 1); // TODO: count not defined!\n\n  buff.seek(last_resource); // TODO: last_resource not defined!\n\n  return WRITE_END;\n}\n\nfunction writeQuestion(buff, val, label_index) {\n  assert(val, 'Packet requires a question');\n  assertUndefined(val.name, 'Question requires a \"name\"');\n  assertUndefined(val.type, 'Question requires a \"type\"');\n  assertUndefined(val.class, 'Questionn requires a \"class\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeResource(buff, val, label_index, rdata) {\n  assert(val, 'Resource must be defined');\n  assertUndefined(val.name, 'Resource record requires \"name\"');\n  assertUndefined(val.type, 'Resource record requires \"type\"');\n  assertUndefined(val.class, 'Resource record requires \"class\"');\n  assertUndefined(val.ttl, 'Resource record requires \"ttl\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  buff.writeUInt32BE(val.ttl & 0xFFFFFFFF);\n  rdata.pos = buff.tell();\n  buff.writeUInt16BE(0); // if there is rdata, then this value will be updated\n  // to the correct value by 'writeResourceDone'\n\n  return val.type;\n}\n\nfunction writeResourceDone(buff, rdata) {\n  var pos = buff.tell();\n  buff.seek(rdata.pos);\n  buff.writeUInt16BE(pos - rdata.pos - 2);\n  buff.seek(pos);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeIp(buff, val) {\n  //TODO XXX FIXME -- assert that address is of proper type\n  assertUndefined(val.address, 'A/AAAA record requires \"address\"');\n  val = ipaddr.parse(val.address).toByteArray();\n  val.forEach(function (b) {\n    buff.writeUInt8(b);\n  });\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeCname(buff, val, label_index) {\n  assertUndefined(val.data, 'NS/CNAME/PTR record requires \"data\"');\n  namePack(val.data, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // For <character-string> see: http://tools.ietf.org/html/rfc1035#section-3.3\n// For TXT: http://tools.ietf.org/html/rfc1035#section-3.3.14\n\n\nfunction writeTxt(buff, val) {\n  //TODO XXX FIXME -- split on max char string and loop\n  assertUndefined(val.data, 'TXT record requires \"data\"');\n\n  for (var i = 0, len = val.data.length; i < len; i++) {\n    var dataLen = Buffer.byteLength(val.data[i], 'utf8');\n    buff.writeUInt8(dataLen);\n    buff.write(val.data[i], dataLen, 'utf8');\n  }\n\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeMx(buff, val, label_index) {\n  assertUndefined(val.priority, 'MX record requires \"priority\"');\n  assertUndefined(val.exchange, 'MX record requires \"exchange\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  namePack(val.exchange, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // SRV: https://tools.ietf.org/html/rfc2782\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n\n\nfunction writeSrv(buff, val, label_index) {\n  assertUndefined(val.priority, 'SRV record requires \"priority\"');\n  assertUndefined(val.weight, 'SRV record requires \"weight\"');\n  assertUndefined(val.port, 'SRV record requires \"port\"');\n  assertUndefined(val.target, 'SRV record requires \"target\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  buff.writeUInt16BE(val.weight & 0xFFFF);\n  buff.writeUInt16BE(val.port & 0xFFFF);\n  namePack(val.target, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeSoa(buff, val, label_index) {\n  assertUndefined(val.primary, 'SOA record requires \"primary\"');\n  assertUndefined(val.admin, 'SOA record requires \"admin\"');\n  assertUndefined(val.serial, 'SOA record requires \"serial\"');\n  assertUndefined(val.refresh, 'SOA record requires \"refresh\"');\n  assertUndefined(val.retry, 'SOA record requires \"retry\"');\n  assertUndefined(val.expiration, 'SOA record requires \"expiration\"');\n  assertUndefined(val.minimum, 'SOA record requires \"minimum\"');\n  namePack(val.primary, buff, label_index);\n  namePack(val.admin, buff, label_index);\n  buff.writeUInt32BE(val.serial & 0xFFFFFFFF);\n  buff.writeInt32BE(val.refresh & 0xFFFFFFFF);\n  buff.writeInt32BE(val.retry & 0xFFFFFFFF);\n  buff.writeInt32BE(val.expiration & 0xFFFFFFFF);\n  buff.writeInt32BE(val.minimum & 0xFFFFFFFF);\n  return WRITE_RESOURCE_DONE;\n} // http://tools.ietf.org/html/rfc3403#section-4.1\n\n\nfunction writeNaptr(buff, val, label_index) {\n  assertUndefined(val.order, 'NAPTR record requires \"order\"');\n  assertUndefined(val.preference, 'NAPTR record requires \"preference\"');\n  assertUndefined(val.flags, 'NAPTR record requires \"flags\"');\n  assertUndefined(val.service, 'NAPTR record requires \"service\"');\n  assertUndefined(val.regexp, 'NAPTR record requires \"regexp\"');\n  assertUndefined(val.replacement, 'NAPTR record requires \"replacement\"');\n  buff.writeUInt16BE(val.order & 0xFFFF);\n  buff.writeUInt16BE(val.preference & 0xFFFF);\n  buff.writeUInt8(val.flags.length);\n  buff.write(val.flags, val.flags.length, 'ascii');\n  buff.writeUInt8(val.service.length);\n  buff.write(val.service, val.service.length, 'ascii');\n  buff.writeUInt8(val.regexp.length);\n  buff.write(val.regexp, val.regexp.length, 'ascii');\n  namePack(val.replacement, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n} // https://tools.ietf.org/html/rfc6698\n\n\nfunction writeTlsa(buff, val) {\n  assertUndefined(val.usage, 'TLSA record requires \"usage\"');\n  assertUndefined(val.selector, 'TLSA record requires \"selector\"');\n  assertUndefined(val.matchingtype, 'TLSA record requires \"matchingtype\"');\n  assertUndefined(val.buff, 'TLSA record requires \"buff\"');\n  buff.writeUInt8(val.usage);\n  buff.writeUInt8(val.selector);\n  buff.writeUInt8(val.matchingtype);\n  buff.copy(val.buff);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction makeEdns(packet) {\n  packet.edns = {\n    name: '',\n    type: consts.NAME_TO_QTYPE.OPT,\n    class: packet.payload,\n    options: [],\n    ttl: 0\n  };\n  packet.edns_options = packet.edns.options; // TODO: 'edns_options' is DEPRECATED!\n\n  packet.additional.push(packet.edns);\n  return WRITE_HEADER;\n}\n\nfunction writeOpt(buff, val) {\n  var opt;\n\n  for (var i = 0, len = val.options.length; i < len; i++) {\n    opt = val.options[i];\n    buff.writeUInt16BE(opt.code);\n    buff.writeUInt16BE(opt.data.length);\n    buff.copy(opt.data);\n  }\n\n  return WRITE_RESOURCE_DONE;\n}\n\nPacket.write = function (buff, packet) {\n  var state = WRITE_HEADER,\n      val,\n      section,\n      count,\n      rdata,\n      last_resource,\n      label_index = {};\n  buff = new BufferCursor(buff); // the existence of 'edns' in a packet indicates that a proper OPT record exists\n  // in 'additional' and that all of the other fields in packet (that are parsed by\n  // 'parseOpt') are properly set. If it does not exist, we assume that the user\n  // is requesting that we create one for them.\n\n  if (typeof packet.edns_version !== 'undefined' && typeof packet.edns === \"undefined\") state = makeEdns(packet); // TODO: this is unnecessarily inefficient. rewrite this using a\n  //       function table instead. (same for Packet.parse too).\n\n  while (true) {\n    try {\n      switch (state) {\n        case WRITE_HEADER:\n          state = writeHeader(buff, packet);\n          break;\n\n        case WRITE_TRUNCATE:\n          state = writeTruncate(buff, packet, section, last_resource);\n          break;\n\n        case WRITE_QUESTION:\n          state = writeQuestion(buff, packet.question[0], label_index);\n          section = 'answer';\n          count = 0;\n          break;\n\n        case WRITE_RESOURCE_RECORD:\n          last_resource = buff.tell();\n\n          if (packet[section].length == count) {\n            switch (section) {\n              case 'answer':\n                section = 'authority';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n\n              case 'authority':\n                section = 'additional';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n\n              case 'additional':\n                state = WRITE_END;\n                break;\n            }\n\n            count = 0;\n          } else {\n            state = WRITE_RESOURCE_WRITE;\n          }\n\n          break;\n\n        case WRITE_RESOURCE_WRITE:\n          rdata = {};\n          val = packet[section][count];\n          state = writeResource(buff, val, label_index, rdata);\n          break;\n\n        case WRITE_RESOURCE_DONE:\n          count += 1;\n          state = writeResourceDone(buff, rdata);\n          break;\n\n        case WRITE_A:\n        case WRITE_AAAA:\n          state = writeIp(buff, val);\n          break;\n\n        case WRITE_NS:\n        case WRITE_CNAME:\n        case WRITE_PTR:\n          state = writeCname(buff, val, label_index);\n          break;\n\n        case WRITE_SPF:\n        case WRITE_TXT:\n          state = writeTxt(buff, val);\n          break;\n\n        case WRITE_MX:\n          state = writeMx(buff, val, label_index);\n          break;\n\n        case WRITE_SRV:\n          state = writeSrv(buff, val, label_index);\n          break;\n\n        case WRITE_SOA:\n          state = writeSoa(buff, val, label_index);\n          break;\n\n        case WRITE_OPT:\n          state = writeOpt(buff, val);\n          break;\n\n        case WRITE_NAPTR:\n          state = writeNaptr(buff, val, label_index);\n          break;\n\n        case WRITE_TLSA:\n          state = writeTlsa(buff, val);\n          break;\n\n        case WRITE_END:\n          return buff.tell();\n\n        default:\n          if (typeof val.data !== 'object') throw new Error('Packet.write Unknown State: ' + state); // write unhandled RR type\n\n          buff.copy(val.data);\n          state = WRITE_RESOURCE_DONE;\n      }\n    } catch (e) {\n      if (e instanceof BufferCursorOverflow) {\n        state = WRITE_TRUNCATE;\n      } else {\n        throw e;\n      }\n    }\n  }\n};\n\nfunction parseHeader(msg, packet) {\n  packet.header.id = msg.readUInt16BE();\n  var val = msg.readUInt16BE();\n  packet.header.qr = (val & 0x8000) >> 15;\n  packet.header.opcode = (val & 0x7800) >> 11;\n  packet.header.aa = (val & 0x400) >> 10;\n  packet.header.tc = (val & 0x200) >> 9;\n  packet.header.rd = (val & 0x100) >> 8;\n  packet.header.ra = (val & 0x80) >> 7;\n  packet.header.res1 = (val & 0x40) >> 6;\n  packet.header.res2 = (val & 0x20) >> 5;\n  packet.header.res3 = (val & 0x10) >> 4;\n  packet.header.rcode = val & 0xF;\n  packet.question = new Array(msg.readUInt16BE());\n  packet.answer = new Array(msg.readUInt16BE());\n  packet.authority = new Array(msg.readUInt16BE());\n  packet.additional = new Array(msg.readUInt16BE());\n  return PARSE_QUESTION;\n}\n\nfunction parseQuestion(msg, packet) {\n  var val = {};\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  packet.question[0] = val;\n  assert(packet.question.length === 1); // TODO handle qdcount > 1 in practice no one sends this\n\n  return PARSE_RESOURCE_RECORD;\n}\n\nfunction parseRR(msg, val, rdata) {\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  val.ttl = msg.readUInt32BE();\n  rdata.len = msg.readUInt16BE();\n  return val.type;\n}\n\nfunction parseA(val, msg) {\n  var address = '' + msg.readUInt8() + '.' + msg.readUInt8() + '.' + msg.readUInt8() + '.' + msg.readUInt8();\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseAAAA(val, msg) {\n  var address = '';\n  var compressed = false;\n\n  for (var i = 0; i < 8; i++) {\n    if (i > 0) address += ':'; // TODO zero compression\n\n    address += msg.readUInt16BE().toString(16);\n  }\n\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseCname(val, msg) {\n  val.data = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTxt(val, msg, rdata) {\n  val.data = [];\n  var end = msg.tell() + rdata.len;\n\n  while (msg.tell() != end) {\n    var len = msg.readUInt8();\n    val.data.push(msg.toString('utf8', len));\n  }\n\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseMx(val, msg, rdata) {\n  val.priority = msg.readUInt16BE();\n  val.exchange = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n} // TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n//       https://tools.ietf.org/html/rfc2782\n\n\nfunction parseSrv(val, msg) {\n  val.priority = msg.readUInt16BE();\n  val.weight = msg.readUInt16BE();\n  val.port = msg.readUInt16BE();\n  val.target = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseSoa(val, msg) {\n  val.primary = nameUnpack(msg);\n  val.admin = nameUnpack(msg);\n  val.serial = msg.readUInt32BE();\n  val.refresh = msg.readInt32BE();\n  val.retry = msg.readInt32BE();\n  val.expiration = msg.readInt32BE();\n  val.minimum = msg.readInt32BE();\n  return PARSE_RESOURCE_DONE;\n} // http://tools.ietf.org/html/rfc3403#section-4.1\n\n\nfunction parseNaptr(val, msg) {\n  val.order = msg.readUInt16BE();\n  val.preference = msg.readUInt16BE();\n  var len = msg.readUInt8();\n  val.flags = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.service = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.regexp = msg.toString('ascii', len);\n  val.replacement = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTlsa(val, msg, rdata) {\n  val.usage = msg.readUInt8();\n  val.selector = msg.readUInt8();\n  val.matchingtype = msg.readUInt8();\n  val.buff = msg.slice(rdata.len - 3).buffer; // 3 because of the 3 UInt8s above.\n\n  return PARSE_RESOURCE_DONE;\n} // https://tools.ietf.org/html/rfc6891#section-6.1.2\n// https://tools.ietf.org/html/rfc2671#section-4.4\n//       - [payload size selection](https://tools.ietf.org/html/rfc6891#section-6.2.5)\n\n\nfunction parseOpt(val, msg, rdata, packet) {\n  // assert first entry in additional\n  rdata.buf = msg.slice(rdata.len);\n  val.rcode = ((val.ttl & 0xFF000000) >> 20) + packet.header.rcode;\n  val.version = val.ttl >> 16 & 0xFF;\n  val.do = val.ttl >> 15 & 1;\n  val.z = val.ttl & 0x7F;\n  val.options = [];\n  packet.edns = val;\n  packet.edns_version = val.version; // TODO: return BADVERS for unsupported version! (Section 6.1.3)\n  // !! BEGIN DEPRECATION NOTICE !!\n  // THESE FIELDS MAY BE REMOVED IN THE FUTURE!\n\n  packet.edns_options = val.options;\n  packet.payload = val.class; // !! END DEPRECATION NOTICE !!\n\n  while (!rdata.buf.eof()) {\n    val.options.push({\n      code: rdata.buf.readUInt16BE(),\n      data: rdata.buf.slice(rdata.buf.readUInt16BE()).buffer\n    });\n  }\n\n  return PARSE_RESOURCE_DONE;\n}\n\nvar PARSE_HEADER = 100000,\n    PARSE_QUESTION = 100001,\n    PARSE_RESOURCE_RECORD = 100002,\n    PARSE_RR_UNPACK = 100003,\n    PARSE_RESOURCE_DONE = 100004,\n    PARSE_END = 100005,\n    PARSE_A = consts.NAME_TO_QTYPE.A,\n    PARSE_NS = consts.NAME_TO_QTYPE.NS,\n    PARSE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n    PARSE_SOA = consts.NAME_TO_QTYPE.SOA,\n    PARSE_PTR = consts.NAME_TO_QTYPE.PTR,\n    PARSE_MX = consts.NAME_TO_QTYPE.MX,\n    PARSE_TXT = consts.NAME_TO_QTYPE.TXT,\n    PARSE_AAAA = consts.NAME_TO_QTYPE.AAAA,\n    PARSE_SRV = consts.NAME_TO_QTYPE.SRV,\n    PARSE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n    PARSE_OPT = consts.NAME_TO_QTYPE.OPT,\n    PARSE_SPF = consts.NAME_TO_QTYPE.SPF,\n    PARSE_TLSA = consts.NAME_TO_QTYPE.TLSA;\n\nPacket.parse = function (msg) {\n  var state, pos, val, rdata, section, count;\n  var packet = new Packet();\n  pos = 0;\n  state = PARSE_HEADER;\n  msg = new BufferCursor(msg);\n\n  while (true) {\n    switch (state) {\n      case PARSE_HEADER:\n        state = parseHeader(msg, packet);\n        break;\n\n      case PARSE_QUESTION:\n        state = parseQuestion(msg, packet);\n        section = 'answer';\n        count = 0;\n        break;\n\n      case PARSE_RESOURCE_RECORD:\n        // console.log('PARSE_RESOURCE_RECORD: count = %d, %s.len = %d', count, section, packet[section].length);\n        if (count === packet[section].length) {\n          switch (section) {\n            case 'answer':\n              section = 'authority';\n              count = 0;\n              break;\n\n            case 'authority':\n              section = 'additional';\n              count = 0;\n              break;\n\n            case 'additional':\n              state = PARSE_END;\n              break;\n          }\n        } else {\n          state = PARSE_RR_UNPACK;\n        }\n\n        break;\n\n      case PARSE_RR_UNPACK:\n        val = {};\n        rdata = {};\n        state = parseRR(msg, val, rdata);\n        break;\n\n      case PARSE_RESOURCE_DONE:\n        packet[section][count++] = val;\n        state = PARSE_RESOURCE_RECORD;\n        break;\n\n      case PARSE_A:\n        state = parseA(val, msg);\n        break;\n\n      case PARSE_AAAA:\n        state = parseAAAA(val, msg);\n        break;\n\n      case PARSE_NS:\n      case PARSE_CNAME:\n      case PARSE_PTR:\n        state = parseCname(val, msg);\n        break;\n\n      case PARSE_SPF:\n      case PARSE_TXT:\n        state = parseTxt(val, msg, rdata);\n        break;\n\n      case PARSE_MX:\n        state = parseMx(val, msg);\n        break;\n\n      case PARSE_SRV:\n        state = parseSrv(val, msg);\n        break;\n\n      case PARSE_SOA:\n        state = parseSoa(val, msg);\n        break;\n\n      case PARSE_OPT:\n        state = parseOpt(val, msg, rdata, packet);\n        break;\n\n      case PARSE_NAPTR:\n        state = parseNaptr(val, msg);\n        break;\n\n      case PARSE_TLSA:\n        state = parseTlsa(val, msg, rdata);\n        break;\n\n      case PARSE_END:\n        return packet;\n\n      default:\n        //console.log(state, val);\n        val.data = msg.slice(rdata.len);\n        state = PARSE_RESOURCE_DONE;\n        break;\n    }\n  }\n};","map":{"version":3,"sources":["C:/react/quiz/node_modules/native-dns-packet/packet.js"],"names":["consts","require","BufferCursor","BufferCursorOverflow","ipaddr","assert","util","assertUndefined","val","msg","Packet","module","exports","header","id","qr","opcode","aa","tc","rd","ra","res1","res2","res3","rcode","question","answer","authority","additional","edns_options","payload","undefined","LABEL_POINTER","isPointer","len","nameUnpack","buff","comp","end","pos","part","combine","readUInt8","tell","seek","toString","length","namePack","str","index","offset","dot","writeUInt16BE","indexOf","slice","writeUInt8","write","WRITE_HEADER","WRITE_TRUNCATE","WRITE_QUESTION","WRITE_RESOURCE_RECORD","WRITE_RESOURCE_WRITE","WRITE_RESOURCE_DONE","WRITE_RESOURCE_END","WRITE_EDNS","WRITE_END","WRITE_A","NAME_TO_QTYPE","A","WRITE_AAAA","AAAA","WRITE_NS","NS","WRITE_CNAME","CNAME","WRITE_PTR","PTR","WRITE_SPF","SPF","WRITE_MX","MX","WRITE_SRV","SRV","WRITE_TXT","TXT","WRITE_SOA","SOA","WRITE_OPT","OPT","WRITE_NAPTR","NAPTR","WRITE_TLSA","TLSA","writeHeader","packet","writeTruncate","section","readUInt16BE","count","last_resource","writeQuestion","label_index","name","type","class","writeResource","rdata","ttl","writeUInt32BE","writeResourceDone","writeIp","address","parse","toByteArray","forEach","b","writeCname","data","writeTxt","i","dataLen","Buffer","byteLength","writeMx","priority","exchange","writeSrv","weight","port","target","writeSoa","primary","admin","serial","refresh","retry","expiration","minimum","writeInt32BE","writeNaptr","order","preference","flags","service","regexp","replacement","writeTlsa","usage","selector","matchingtype","copy","makeEdns","edns","options","push","writeOpt","opt","code","state","edns_version","Error","e","parseHeader","Array","PARSE_QUESTION","parseQuestion","PARSE_RESOURCE_RECORD","parseRR","readUInt32BE","parseA","PARSE_RESOURCE_DONE","parseAAAA","compressed","parseCname","parseTxt","parseMx","parseSrv","parseSoa","readInt32BE","parseNaptr","parseTlsa","buffer","parseOpt","buf","version","do","z","eof","PARSE_HEADER","PARSE_RR_UNPACK","PARSE_END","PARSE_A","PARSE_NS","PARSE_CNAME","PARSE_SOA","PARSE_PTR","PARSE_MX","PARSE_TXT","PARSE_AAAA","PARSE_SRV","PARSE_NAPTR","PARSE_OPT","PARSE_SPF","PARSE_TLSA"],"mappings":"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","sourcesContent":["// Copyright 2011 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the 'Software'), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n\n// TODO: change the default UDP packet size that node-dns sends\n//       from 4096 to conform to these:\n//       - [requestor's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.3)\n//       - [responders's payload size](https://tools.ietf.org/html/rfc6891#section-6.2.4)\n\n'use strict';\n\nvar consts = require('./consts'),\n    BufferCursor = require('buffercursor'),\n    BufferCursorOverflow = BufferCursor.BufferCursorOverflow,\n    ipaddr = require('ipaddr.js'),\n    assert = require('assert'),\n    util = require('util');\n\nfunction assertUndefined(val, msg) {\n  assert(typeof val != 'undefined', msg);\n}\n\nvar Packet = module.exports = function() {\n  this.header = {\n    id: 0,\n    qr: 0,\n    opcode: 0,\n    aa: 0,\n    tc: 0,\n    rd: 1,\n    ra: 0,\n    res1: 0,\n    res2: 0,\n    res3: 0,\n    rcode: 0\n  };\n  this.question = [];\n  this.answer = [];\n  this.authority = [];\n  this.additional = [];\n  this.edns_options = [];   // TODO: DEPRECATED! Use `.edns.options` instead!\n  this.payload = undefined; // TODO: DEPRECATED! Use `.edns.payload` instead!\n};\n\nvar LABEL_POINTER = 0xC0;\n\nvar isPointer = function(len) {\n  return (len & LABEL_POINTER) === LABEL_POINTER;\n};\n\nfunction nameUnpack(buff) {\n  var len, comp, end, pos, part, combine = '';\n\n  len = buff.readUInt8();\n  comp = false;\n  end = buff.tell();\n\n  while (len !== 0) {\n    if (isPointer(len)) {\n      len -= LABEL_POINTER;\n      len = len << 8;\n      pos = len + buff.readUInt8();\n      if (!comp)\n        end = buff.tell();\n      buff.seek(pos);\n      len = buff.readUInt8();\n      comp = true;\n      continue;\n    }\n\n    part = buff.toString('ascii', len);\n\n    if (combine.length)\n      combine = combine + '.' + part;\n    else\n      combine = part;\n\n    len = buff.readUInt8();\n\n    if (!comp)\n      end = buff.tell();\n  }\n\n  buff.seek(end);\n\n  return combine;\n}\n\nfunction namePack(str, buff, index) {\n  var offset, dot, part;\n\n  while (str) {\n    if (index[str]) {\n      offset = (LABEL_POINTER << 8) + index[str];\n      buff.writeUInt16BE(offset);\n      break;\n    } else {\n      index[str] = buff.tell();\n      dot = str.indexOf('.');\n      if (dot > -1) {\n        part = str.slice(0, dot);\n        str = str.slice(dot + 1);\n      } else {\n        part = str;\n        str = undefined;\n      }\n      buff.writeUInt8(part.length);\n      buff.write(part, part.length, 'ascii');\n    }\n  }\n\n  if (!str) {\n    buff.writeUInt8(0);\n  }\n}\n\nvar\n  WRITE_HEADER              = 100001,\n  WRITE_TRUNCATE            = 100002,\n  WRITE_QUESTION            = 100003,\n  WRITE_RESOURCE_RECORD     = 100004,\n  WRITE_RESOURCE_WRITE      = 100005,\n  WRITE_RESOURCE_DONE       = 100006,\n  WRITE_RESOURCE_END        = 100007,\n  WRITE_EDNS                = 100008,\n  WRITE_END                 = 100009,\n  WRITE_A     = consts.NAME_TO_QTYPE.A,\n  WRITE_AAAA  = consts.NAME_TO_QTYPE.AAAA,\n  WRITE_NS    = consts.NAME_TO_QTYPE.NS,\n  WRITE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n  WRITE_PTR   = consts.NAME_TO_QTYPE.PTR,\n  WRITE_SPF   = consts.NAME_TO_QTYPE.SPF,\n  WRITE_MX    = consts.NAME_TO_QTYPE.MX,\n  WRITE_SRV   = consts.NAME_TO_QTYPE.SRV,\n  WRITE_TXT   = consts.NAME_TO_QTYPE.TXT,\n  WRITE_SOA   = consts.NAME_TO_QTYPE.SOA,\n  WRITE_OPT   = consts.NAME_TO_QTYPE.OPT,\n  WRITE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n  WRITE_TLSA  = consts.NAME_TO_QTYPE.TLSA;\n\nfunction writeHeader(buff, packet) {\n  assert(packet.header, 'Packet requires \"header\"');\n  buff.writeUInt16BE(packet.header.id & 0xFFFF);\n  var val = 0;\n  val += (packet.header.qr << 15) & 0x8000;\n  val += (packet.header.opcode << 11) & 0x7800;\n  val += (packet.header.aa << 10) & 0x400;\n  val += (packet.header.tc << 9) & 0x200;\n  val += (packet.header.rd << 8) & 0x100;\n  val += (packet.header.ra << 7) & 0x80;\n  val += (packet.header.res1 << 6) & 0x40;\n  val += (packet.header.res2 << 5) & 0x20;\n  val += (packet.header.res3 << 4) & 0x10;\n  val += packet.header.rcode & 0xF;\n  buff.writeUInt16BE(val & 0xFFFF);\n  assert(packet.question.length == 1, 'DNS requires one question');\n  // aren't used\n  buff.writeUInt16BE(1);\n  // answer offset 6\n  buff.writeUInt16BE(packet.answer.length & 0xFFFF);\n  // authority offset 8\n  buff.writeUInt16BE(packet.authority.length & 0xFFFF);\n  // additional offset 10\n  buff.writeUInt16BE(packet.additional.length & 0xFFFF);\n  return WRITE_QUESTION;\n}\n\nfunction writeTruncate(buff, packet, section, val) {\n  // XXX FIXME TODO truncation is currently done wrong.\n  // Quote rfc2181 section 9\n  // The TC bit should not be set merely because some extra information\n  // could have been included, but there was insufficient room.  This\n  // includes the results of additional section processing.  In such cases\n  // the entire RRSet that will not fit in the response should be omitted,\n  // and the reply sent as is, with the TC bit clear.  If the recipient of\n  // the reply needs the omitted data, it can construct a query for that\n  // data and send that separately.\n  //\n  // TODO IOW only set TC if we hit it in ANSWERS otherwise make sure an\n  // entire RRSet is removed during a truncation.\n  var pos;\n\n  buff.seek(2);\n  val = buff.readUInt16BE();\n  val |= (1 << 9) & 0x200;\n  buff.seek(2);\n  buff.writeUInt16BE(val);\n  switch (section) {\n    case 'answer':\n      pos = 6;\n      // seek to authority and clear it and additional out\n      buff.seek(8);\n      buff.writeUInt16BE(0);\n      buff.writeUInt16BE(0);\n      break;\n    case 'authority':\n      pos = 8;\n      // seek to additional and clear it out\n      buff.seek(10);\n      buff.writeUInt16BE(0);\n      break;\n    case 'additional':\n      pos = 10;\n      break;\n  }\n  buff.seek(pos);\n  buff.writeUInt16BE(count - 1); // TODO: count not defined!\n  buff.seek(last_resource);      // TODO: last_resource not defined!\n  return WRITE_END;\n}\n\nfunction writeQuestion(buff, val, label_index) {\n  assert(val, 'Packet requires a question');\n  assertUndefined(val.name, 'Question requires a \"name\"');\n  assertUndefined(val.type, 'Question requires a \"type\"');\n  assertUndefined(val.class, 'Questionn requires a \"class\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeResource(buff, val, label_index, rdata) {\n  assert(val, 'Resource must be defined');\n  assertUndefined(val.name, 'Resource record requires \"name\"');\n  assertUndefined(val.type, 'Resource record requires \"type\"');\n  assertUndefined(val.class, 'Resource record requires \"class\"');\n  assertUndefined(val.ttl, 'Resource record requires \"ttl\"');\n  namePack(val.name, buff, label_index);\n  buff.writeUInt16BE(val.type & 0xFFFF);\n  buff.writeUInt16BE(val.class & 0xFFFF);\n  buff.writeUInt32BE(val.ttl & 0xFFFFFFFF);\n  rdata.pos = buff.tell();\n  buff.writeUInt16BE(0); // if there is rdata, then this value will be updated\n                         // to the correct value by 'writeResourceDone'\n  return val.type;\n}\n\nfunction writeResourceDone(buff, rdata) {\n  var pos = buff.tell();\n  buff.seek(rdata.pos);\n  buff.writeUInt16BE(pos - rdata.pos - 2);\n  buff.seek(pos);\n  return WRITE_RESOURCE_RECORD;\n}\n\nfunction writeIp(buff, val) {\n  //TODO XXX FIXME -- assert that address is of proper type\n  assertUndefined(val.address, 'A/AAAA record requires \"address\"');\n  val = ipaddr.parse(val.address).toByteArray();\n  val.forEach(function(b) {\n    buff.writeUInt8(b);\n  });\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeCname(buff, val, label_index) {\n  assertUndefined(val.data, 'NS/CNAME/PTR record requires \"data\"');\n  namePack(val.data, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// For <character-string> see: http://tools.ietf.org/html/rfc1035#section-3.3\n// For TXT: http://tools.ietf.org/html/rfc1035#section-3.3.14\nfunction writeTxt(buff, val) {\n  //TODO XXX FIXME -- split on max char string and loop\n  assertUndefined(val.data, 'TXT record requires \"data\"');\n  for (var i=0,len=val.data.length; i<len; i++) {\n    var dataLen = Buffer.byteLength(val.data[i], 'utf8');\n    buff.writeUInt8(dataLen);\n    buff.write(val.data[i], dataLen, 'utf8');\n  }\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeMx(buff, val, label_index) {\n  assertUndefined(val.priority, 'MX record requires \"priority\"');\n  assertUndefined(val.exchange, 'MX record requires \"exchange\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  namePack(val.exchange, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// SRV: https://tools.ietf.org/html/rfc2782\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\nfunction writeSrv(buff, val, label_index) {\n  assertUndefined(val.priority, 'SRV record requires \"priority\"');\n  assertUndefined(val.weight, 'SRV record requires \"weight\"');\n  assertUndefined(val.port, 'SRV record requires \"port\"');\n  assertUndefined(val.target, 'SRV record requires \"target\"');\n  buff.writeUInt16BE(val.priority & 0xFFFF);\n  buff.writeUInt16BE(val.weight & 0xFFFF);\n  buff.writeUInt16BE(val.port & 0xFFFF);\n  namePack(val.target, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction writeSoa(buff, val, label_index) {\n  assertUndefined(val.primary, 'SOA record requires \"primary\"');\n  assertUndefined(val.admin, 'SOA record requires \"admin\"');\n  assertUndefined(val.serial, 'SOA record requires \"serial\"');\n  assertUndefined(val.refresh, 'SOA record requires \"refresh\"');\n  assertUndefined(val.retry, 'SOA record requires \"retry\"');\n  assertUndefined(val.expiration, 'SOA record requires \"expiration\"');\n  assertUndefined(val.minimum, 'SOA record requires \"minimum\"');\n  namePack(val.primary, buff, label_index);\n  namePack(val.admin, buff, label_index);\n  buff.writeUInt32BE(val.serial & 0xFFFFFFFF);\n  buff.writeInt32BE(val.refresh & 0xFFFFFFFF);\n  buff.writeInt32BE(val.retry & 0xFFFFFFFF);\n  buff.writeInt32BE(val.expiration & 0xFFFFFFFF);\n  buff.writeInt32BE(val.minimum & 0xFFFFFFFF);\n  return WRITE_RESOURCE_DONE;\n}\n\n// http://tools.ietf.org/html/rfc3403#section-4.1\nfunction writeNaptr(buff, val, label_index) {\n  assertUndefined(val.order, 'NAPTR record requires \"order\"');\n  assertUndefined(val.preference, 'NAPTR record requires \"preference\"');\n  assertUndefined(val.flags, 'NAPTR record requires \"flags\"');\n  assertUndefined(val.service, 'NAPTR record requires \"service\"');\n  assertUndefined(val.regexp, 'NAPTR record requires \"regexp\"');\n  assertUndefined(val.replacement, 'NAPTR record requires \"replacement\"');\n  buff.writeUInt16BE(val.order & 0xFFFF);\n  buff.writeUInt16BE(val.preference & 0xFFFF);\n  buff.writeUInt8(val.flags.length);\n  buff.write(val.flags, val.flags.length, 'ascii');\n  buff.writeUInt8(val.service.length);\n  buff.write(val.service, val.service.length, 'ascii');\n  buff.writeUInt8(val.regexp.length);\n  buff.write(val.regexp, val.regexp.length, 'ascii');\n  namePack(val.replacement, buff, label_index);\n  return WRITE_RESOURCE_DONE;\n}\n\n// https://tools.ietf.org/html/rfc6698\nfunction writeTlsa(buff, val) {\n  assertUndefined(val.usage, 'TLSA record requires \"usage\"');\n  assertUndefined(val.selector, 'TLSA record requires \"selector\"');\n  assertUndefined(val.matchingtype, 'TLSA record requires \"matchingtype\"');\n  assertUndefined(val.buff, 'TLSA record requires \"buff\"');\n  buff.writeUInt8(val.usage);\n  buff.writeUInt8(val.selector);\n  buff.writeUInt8(val.matchingtype);\n  buff.copy(val.buff);\n  return WRITE_RESOURCE_DONE;\n}\n\nfunction makeEdns(packet) {\n  packet.edns = {\n    name: '',\n    type: consts.NAME_TO_QTYPE.OPT,\n    class: packet.payload,\n    options: [],\n    ttl: 0\n  };\n  packet.edns_options = packet.edns.options; // TODO: 'edns_options' is DEPRECATED!\n  packet.additional.push(packet.edns);\n  return WRITE_HEADER;\n}\n\nfunction writeOpt(buff, val) {\n  var opt;\n  for (var i=0, len=val.options.length; i<len; i++) {\n    opt = val.options[i];\n    buff.writeUInt16BE(opt.code);\n    buff.writeUInt16BE(opt.data.length);\n    buff.copy(opt.data);\n  }\n  return WRITE_RESOURCE_DONE;\n}\n\nPacket.write = function(buff, packet) {\n  var state = WRITE_HEADER,\n      val,\n      section,\n      count,\n      rdata,\n      last_resource,\n      label_index = {};\n\n  buff = new BufferCursor(buff);\n\n  // the existence of 'edns' in a packet indicates that a proper OPT record exists\n  // in 'additional' and that all of the other fields in packet (that are parsed by\n  // 'parseOpt') are properly set. If it does not exist, we assume that the user\n  // is requesting that we create one for them.\n  if (typeof packet.edns_version !== 'undefined' && typeof packet.edns === \"undefined\")\n    state = makeEdns(packet);\n\n  // TODO: this is unnecessarily inefficient. rewrite this using a\n  //       function table instead. (same for Packet.parse too).\n  while (true) {\n    try {\n      switch (state) {\n        case WRITE_HEADER:\n          state = writeHeader(buff, packet);\n          break;\n        case WRITE_TRUNCATE:\n          state = writeTruncate(buff, packet, section, last_resource);\n          break;\n        case WRITE_QUESTION:\n          state = writeQuestion(buff, packet.question[0], label_index);\n          section = 'answer';\n          count = 0;\n          break;\n        case WRITE_RESOURCE_RECORD:\n          last_resource = buff.tell();\n          if (packet[section].length == count) {\n            switch (section) {\n              case 'answer':\n                section = 'authority';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n              case 'authority':\n                section = 'additional';\n                state = WRITE_RESOURCE_RECORD;\n                break;\n              case 'additional':\n                state = WRITE_END;\n                break;\n            }\n            count = 0;\n          } else {\n            state = WRITE_RESOURCE_WRITE;\n          }\n          break;\n        case WRITE_RESOURCE_WRITE:\n          rdata = {};\n          val = packet[section][count];\n          state = writeResource(buff, val, label_index, rdata);\n          break;\n        case WRITE_RESOURCE_DONE:\n          count += 1;\n          state = writeResourceDone(buff, rdata);\n          break;\n        case WRITE_A:\n        case WRITE_AAAA:\n          state = writeIp(buff, val);\n          break;\n        case WRITE_NS:\n        case WRITE_CNAME:\n        case WRITE_PTR:\n          state = writeCname(buff, val, label_index);\n          break;\n        case WRITE_SPF:\n        case WRITE_TXT:\n          state = writeTxt(buff, val);\n          break;\n        case WRITE_MX:\n          state = writeMx(buff, val, label_index);\n          break;\n        case WRITE_SRV:\n          state = writeSrv(buff, val, label_index);\n          break;\n        case WRITE_SOA:\n          state = writeSoa(buff, val, label_index);\n          break;\n        case WRITE_OPT:\n          state = writeOpt(buff, val);\n          break;\n        case WRITE_NAPTR:\n          state = writeNaptr(buff, val, label_index);\n          break;\n        case WRITE_TLSA:\n          state = writeTlsa(buff, val);\n          break;\n        case WRITE_END:\n          return buff.tell();\n        default:\n          if (typeof val.data !== 'object')\n            throw new Error('Packet.write Unknown State: ' + state);\n          // write unhandled RR type\n          buff.copy(val.data);\n          state = WRITE_RESOURCE_DONE;\n      }\n    } catch (e) {\n      if (e instanceof BufferCursorOverflow) {\n        state = WRITE_TRUNCATE;\n      } else {\n        throw e;\n      }\n    }\n  }\n};\n\nfunction parseHeader(msg, packet) {\n  packet.header.id = msg.readUInt16BE();\n  var val = msg.readUInt16BE();\n  packet.header.qr = (val & 0x8000) >> 15;\n  packet.header.opcode = (val & 0x7800) >> 11;\n  packet.header.aa = (val & 0x400) >> 10;\n  packet.header.tc = (val & 0x200) >> 9;\n  packet.header.rd = (val & 0x100) >> 8;\n  packet.header.ra = (val & 0x80) >> 7;\n  packet.header.res1 = (val & 0x40) >> 6;\n  packet.header.res2 = (val & 0x20) >> 5;\n  packet.header.res3 = (val & 0x10) >> 4;\n  packet.header.rcode = (val & 0xF);\n  packet.question = new Array(msg.readUInt16BE());\n  packet.answer = new Array(msg.readUInt16BE());\n  packet.authority = new Array(msg.readUInt16BE());\n  packet.additional = new Array(msg.readUInt16BE());\n  return PARSE_QUESTION;\n}\n\nfunction parseQuestion(msg, packet) {\n  var val = {};\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  packet.question[0] = val;\n  assert(packet.question.length === 1);\n  // TODO handle qdcount > 1 in practice no one sends this\n  return PARSE_RESOURCE_RECORD;\n}\n\nfunction parseRR(msg, val, rdata) {\n  val.name = nameUnpack(msg);\n  val.type = msg.readUInt16BE();\n  val.class = msg.readUInt16BE();\n  val.ttl = msg.readUInt32BE();\n  rdata.len = msg.readUInt16BE();\n  return val.type;\n}\n\nfunction parseA(val, msg) {\n  var address = '' +\n    msg.readUInt8() +\n    '.' + msg.readUInt8() +\n    '.' + msg.readUInt8() +\n    '.' + msg.readUInt8();\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseAAAA(val, msg) {\n  var address = '';\n  var compressed = false;\n\n  for (var i = 0; i < 8; i++) {\n    if (i > 0) address += ':';\n    // TODO zero compression\n    address += msg.readUInt16BE().toString(16);\n  }\n  val.address = address;\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseCname(val, msg) {\n  val.data = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTxt(val, msg, rdata) {\n  val.data = [];\n  var end = msg.tell() + rdata.len;\n  while (msg.tell() != end) {\n    var len = msg.readUInt8();\n    val.data.push(msg.toString('utf8', len));\n  }\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseMx(val, msg, rdata) {\n  val.priority = msg.readUInt16BE();\n  val.exchange = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\n// TODO: SRV fixture failing for '_xmpp-server._tcp.gmail.com.srv.js'\n//       https://tools.ietf.org/html/rfc2782\nfunction parseSrv(val, msg) {\n  val.priority = msg.readUInt16BE();\n  val.weight = msg.readUInt16BE();\n  val.port = msg.readUInt16BE();\n  val.target = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseSoa(val, msg) {\n  val.primary = nameUnpack(msg);\n  val.admin = nameUnpack(msg);\n  val.serial = msg.readUInt32BE();\n  val.refresh = msg.readInt32BE();\n  val.retry = msg.readInt32BE();\n  val.expiration = msg.readInt32BE();\n  val.minimum = msg.readInt32BE();\n  return PARSE_RESOURCE_DONE;\n}\n\n// http://tools.ietf.org/html/rfc3403#section-4.1\nfunction parseNaptr(val, msg) {\n  val.order = msg.readUInt16BE();\n  val.preference = msg.readUInt16BE();\n  var len = msg.readUInt8();\n  val.flags = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.service = msg.toString('ascii', len);\n  len = msg.readUInt8();\n  val.regexp = msg.toString('ascii', len);\n  val.replacement = nameUnpack(msg);\n  return PARSE_RESOURCE_DONE;\n}\n\nfunction parseTlsa(val, msg, rdata) {\n  val.usage = msg.readUInt8();\n  val.selector = msg.readUInt8();\n  val.matchingtype = msg.readUInt8();\n  val.buff = msg.slice(rdata.len - 3).buffer; // 3 because of the 3 UInt8s above.\n  return PARSE_RESOURCE_DONE;\n}\n\n// https://tools.ietf.org/html/rfc6891#section-6.1.2\n// https://tools.ietf.org/html/rfc2671#section-4.4\n//       - [payload size selection](https://tools.ietf.org/html/rfc6891#section-6.2.5)\nfunction parseOpt(val, msg, rdata, packet) {\n  // assert first entry in additional\n  rdata.buf = msg.slice(rdata.len);\n\n  val.rcode = ((val.ttl & 0xFF000000) >> 20) + packet.header.rcode;\n  val.version = (val.ttl >> 16) & 0xFF;\n  val.do = (val.ttl >> 15) & 1;\n  val.z = val.ttl & 0x7F;\n  val.options = [];\n\n  packet.edns = val;\n  packet.edns_version = val.version; // TODO: return BADVERS for unsupported version! (Section 6.1.3)\n\n  // !! BEGIN DEPRECATION NOTICE !!\n  // THESE FIELDS MAY BE REMOVED IN THE FUTURE!\n  packet.edns_options = val.options;\n  packet.payload = val.class;\n  // !! END DEPRECATION NOTICE !!\n\n  while (!rdata.buf.eof()) {\n    val.options.push({\n      code: rdata.buf.readUInt16BE(),\n      data: rdata.buf.slice(rdata.buf.readUInt16BE()).buffer\n    });\n  }\n  return PARSE_RESOURCE_DONE;\n}\n\nvar\n  PARSE_HEADER          = 100000,\n  PARSE_QUESTION        = 100001,\n  PARSE_RESOURCE_RECORD = 100002,\n  PARSE_RR_UNPACK       = 100003,\n  PARSE_RESOURCE_DONE   = 100004,\n  PARSE_END             = 100005,\n  PARSE_A     = consts.NAME_TO_QTYPE.A,\n  PARSE_NS    = consts.NAME_TO_QTYPE.NS,\n  PARSE_CNAME = consts.NAME_TO_QTYPE.CNAME,\n  PARSE_SOA   = consts.NAME_TO_QTYPE.SOA,\n  PARSE_PTR   = consts.NAME_TO_QTYPE.PTR,\n  PARSE_MX    = consts.NAME_TO_QTYPE.MX,\n  PARSE_TXT   = consts.NAME_TO_QTYPE.TXT,\n  PARSE_AAAA  = consts.NAME_TO_QTYPE.AAAA,\n  PARSE_SRV   = consts.NAME_TO_QTYPE.SRV,\n  PARSE_NAPTR = consts.NAME_TO_QTYPE.NAPTR,\n  PARSE_OPT   = consts.NAME_TO_QTYPE.OPT,\n  PARSE_SPF   = consts.NAME_TO_QTYPE.SPF,\n  PARSE_TLSA  = consts.NAME_TO_QTYPE.TLSA;\n  \n\nPacket.parse = function(msg) {\n  var state,\n      pos,\n      val,\n      rdata,\n      section,\n      count;\n\n  var packet = new Packet();\n\n  pos = 0;\n  state = PARSE_HEADER;\n\n  msg = new BufferCursor(msg);\n\n  while (true) {\n    switch (state) {\n      case PARSE_HEADER:\n        state = parseHeader(msg, packet);\n        break;\n      case PARSE_QUESTION:\n        state = parseQuestion(msg, packet);\n        section = 'answer';\n        count = 0;\n        break;\n      case PARSE_RESOURCE_RECORD:\n        // console.log('PARSE_RESOURCE_RECORD: count = %d, %s.len = %d', count, section, packet[section].length);\n        if (count === packet[section].length) {\n          switch (section) {\n            case 'answer':\n              section = 'authority';\n              count = 0;\n              break;\n            case 'authority':\n              section = 'additional';\n              count = 0;\n              break;\n            case 'additional':\n              state = PARSE_END;\n              break;\n          }\n        } else {\n          state = PARSE_RR_UNPACK;\n        }\n        break;\n      case PARSE_RR_UNPACK:\n        val = {};\n        rdata = {};\n        state = parseRR(msg, val, rdata);\n        break;\n      case PARSE_RESOURCE_DONE:\n        packet[section][count++] = val;\n        state = PARSE_RESOURCE_RECORD;\n        break;\n      case PARSE_A:\n        state = parseA(val, msg);\n        break;\n      case PARSE_AAAA:\n        state = parseAAAA(val, msg);\n        break;\n      case PARSE_NS:\n      case PARSE_CNAME:\n      case PARSE_PTR:\n        state = parseCname(val, msg);\n        break;\n      case PARSE_SPF:\n      case PARSE_TXT:\n        state = parseTxt(val, msg, rdata);\n        break;\n      case PARSE_MX:\n        state = parseMx(val, msg);\n        break;\n      case PARSE_SRV:\n        state = parseSrv(val, msg);\n        break;\n      case PARSE_SOA:\n        state = parseSoa(val, msg);\n        break;\n      case PARSE_OPT:\n        state = parseOpt(val, msg, rdata, packet);\n        break;\n      case PARSE_NAPTR:\n        state = parseNaptr(val, msg);\n        break;\n      case PARSE_TLSA:\n        state = parseTlsa(val, msg, rdata);\n        break;\n      case PARSE_END:\n        return packet;\n      default:\n        //console.log(state, val);\n        val.data = msg.slice(rdata.len);\n        state = PARSE_RESOURCE_DONE;\n        break;\n    }\n  }\n};\n"]},"metadata":{},"sourceType":"script"}