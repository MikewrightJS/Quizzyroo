{"ast":null,"code":"module.exports = ForeverAgent;\nForeverAgent.SSL = ForeverAgentSSL;\n\nvar util = require('util'),\n    Agent = require('http').Agent,\n    net = require('net'),\n    tls = require('tls'),\n    AgentSSL = require('https').Agent;\n\nfunction ForeverAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.requests = {};\n  self.sockets = {};\n  self.freeSockets = {};\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets;\n  self.on('free', function (socket, host, port) {\n    var name = host + ':' + port;\n\n    if (self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket);\n    } else if (self.sockets[name].length < self.minSockets) {\n      if (!self.freeSockets[name]) self.freeSockets[name] = [];\n      self.freeSockets[name].push(socket); // if an error happens while we don't use the socket anyway, meh, throw the socket away\n\n      function onIdleError() {\n        socket.destroy();\n      }\n\n      socket._onIdleError = onIdleError;\n      socket.on('error', onIdleError);\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy();\n    }\n  });\n}\n\nutil.inherits(ForeverAgent, Agent);\nForeverAgent.defaultMinSockets = 5;\nForeverAgent.prototype.createConnection = net.createConnection;\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;\n\nForeverAgent.prototype.addRequest = function (req, host, port) {\n  var name = host + ':' + port;\n\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n    var idleSocket = this.freeSockets[name].pop();\n    idleSocket.removeListener('error', idleSocket._onIdleError);\n    delete idleSocket._onIdleError;\n    req._reusedSocket = true;\n    req.onSocket(idleSocket);\n  } else {\n    this.addRequestNoreuse(req, host, port);\n  }\n};\n\nForeverAgent.prototype.removeSocket = function (s, name, host, port) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s);\n\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1);\n    }\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n    // don't leak\n    delete this.sockets[name];\n    delete this.requests[name];\n  }\n\n  if (this.freeSockets[name]) {\n    var index = this.freeSockets[name].indexOf(s);\n\n    if (index !== -1) {\n      this.freeSockets[name].splice(index, 1);\n\n      if (this.freeSockets[name].length === 0) {\n        delete this.freeSockets[name];\n      }\n    }\n  }\n\n  if (this.requests[name] && this.requests[name].length) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(name, host, port).emit('free');\n  }\n};\n\nfunction ForeverAgentSSL(options) {\n  ForeverAgent.call(this, options);\n}\n\nutil.inherits(ForeverAgentSSL, ForeverAgent);\nForeverAgentSSL.prototype.createConnection = createConnectionSSL;\nForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;\n\nfunction createConnectionSSL(port, host, options) {\n  options.port = port;\n  options.host = host;\n  return tls.connect(options);\n}","map":{"version":3,"sources":["C:/react/quiz/node_modules/forever-agent/index.js"],"names":["module","exports","ForeverAgent","SSL","ForeverAgentSSL","util","require","Agent","net","tls","AgentSSL","options","self","requests","sockets","freeSockets","maxSockets","defaultMaxSockets","minSockets","defaultMinSockets","on","socket","host","port","name","length","shift","onSocket","push","onIdleError","destroy","_onIdleError","inherits","prototype","createConnection","addRequestNoreuse","addRequest","req","useChunkedEncodingByDefault","idleSocket","pop","removeListener","_reusedSocket","removeSocket","s","index","indexOf","splice","createSocket","emit","call","createConnectionSSL","connect"],"mappings":"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","sourcesContent":["module.exports = ForeverAgent\nForeverAgent.SSL = ForeverAgentSSL\n\nvar util = require('util')\n  , Agent = require('http').Agent\n  , net = require('net')\n  , tls = require('tls')\n  , AgentSSL = require('https').Agent\n\nfunction ForeverAgent(options) {\n  var self = this\n  self.options = options || {}\n  self.requests = {}\n  self.sockets = {}\n  self.freeSockets = {}\n  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets\n  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets\n  self.on('free', function(socket, host, port) {\n    var name = host + ':' + port\n    if (self.requests[name] && self.requests[name].length) {\n      self.requests[name].shift().onSocket(socket)\n    } else if (self.sockets[name].length < self.minSockets) {\n      if (!self.freeSockets[name]) self.freeSockets[name] = []\n      self.freeSockets[name].push(socket)\n      \n      // if an error happens while we don't use the socket anyway, meh, throw the socket away\n      function onIdleError() {\n        socket.destroy()\n      }\n      socket._onIdleError = onIdleError\n      socket.on('error', onIdleError)\n    } else {\n      // If there are no pending requests just destroy the\n      // socket and it will get removed from the pool. This\n      // gets us out of timeout issues and allows us to\n      // default to Connection:keep-alive.\n      socket.destroy()\n    }\n  })\n\n}\nutil.inherits(ForeverAgent, Agent)\n\nForeverAgent.defaultMinSockets = 5\n\n\nForeverAgent.prototype.createConnection = net.createConnection\nForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest\nForeverAgent.prototype.addRequest = function(req, host, port) {\n  var name = host + ':' + port\n  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {\n    var idleSocket = this.freeSockets[name].pop()\n    idleSocket.removeListener('error', idleSocket._onIdleError)\n    delete idleSocket._onIdleError\n    req._reusedSocket = true\n    req.onSocket(idleSocket)\n  } else {\n    this.addRequestNoreuse(req, host, port)\n  }\n}\n\nForeverAgent.prototype.removeSocket = function(s, name, host, port) {\n  if (this.sockets[name]) {\n    var index = this.sockets[name].indexOf(s)\n    if (index !== -1) {\n      this.sockets[name].splice(index, 1)\n    }\n  } else if (this.sockets[name] && this.sockets[name].length === 0) {\n    // don't leak\n    delete this.sockets[name]\n    delete this.requests[name]\n  }\n  \n  if (this.freeSockets[name]) {\n    var index = this.freeSockets[name].indexOf(s)\n    if (index !== -1) {\n      this.freeSockets[name].splice(index, 1)\n      if (this.freeSockets[name].length === 0) {\n        delete this.freeSockets[name]\n      }\n    }\n  }\n\n  if (this.requests[name] && this.requests[name].length) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(name, host, port).emit('free')\n  }\n}\n\nfunction ForeverAgentSSL (options) {\n  ForeverAgent.call(this, options)\n}\nutil.inherits(ForeverAgentSSL, ForeverAgent)\n\nForeverAgentSSL.prototype.createConnection = createConnectionSSL\nForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest\n\nfunction createConnectionSSL (port, host, options) {\n  options.port = port\n  options.host = host\n  return tls.connect(options)\n}\n"]},"metadata":{},"sourceType":"script"}