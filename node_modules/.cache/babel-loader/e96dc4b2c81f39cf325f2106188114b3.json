{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ChildLoadBalancerHandler = void 0;\n\nconst load_balancer_1 = require(\"./load-balancer\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst TYPE_NAME = 'child_load_balancer_helper';\n\nclass ChildLoadBalancerHandler {\n  constructor(channelControlHelper) {\n    this.channelControlHelper = channelControlHelper;\n    this.currentChild = null;\n    this.pendingChild = null;\n    this.ChildPolicyHelper = class {\n      constructor(parent) {\n        this.parent = parent;\n        this.child = null;\n      }\n\n      createSubchannel(subchannelAddress, subchannelArgs) {\n        return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs);\n      }\n\n      updateState(connectivityState, picker) {\n        var _a;\n\n        if (this.calledByPendingChild()) {\n          if (connectivityState !== connectivity_state_1.ConnectivityState.READY) {\n            return;\n          }\n\n          (_a = this.parent.currentChild) === null || _a === void 0 ? void 0 : _a.destroy();\n          this.parent.currentChild = this.parent.pendingChild;\n          this.parent.pendingChild = null;\n        } else if (!this.calledByCurrentChild()) {\n          return;\n        }\n\n        this.parent.channelControlHelper.updateState(connectivityState, picker);\n      }\n\n      requestReresolution() {\n        var _a;\n\n        const latestChild = (_a = this.parent.pendingChild) !== null && _a !== void 0 ? _a : this.parent.currentChild;\n\n        if (this.child === latestChild) {\n          this.parent.channelControlHelper.requestReresolution();\n        }\n      }\n\n      setChild(newChild) {\n        this.child = newChild;\n      }\n\n      addChannelzChild(child) {\n        this.parent.channelControlHelper.addChannelzChild(child);\n      }\n\n      removeChannelzChild(child) {\n        this.parent.channelControlHelper.removeChannelzChild(child);\n      }\n\n      calledByPendingChild() {\n        return this.child === this.parent.pendingChild;\n      }\n\n      calledByCurrentChild() {\n        return this.child === this.parent.currentChild;\n      }\n\n    };\n  }\n  /**\n   * Prerequisites: lbConfig !== null and lbConfig.name is registered\n   * @param addressList\n   * @param lbConfig\n   * @param attributes\n   */\n\n\n  updateAddressList(addressList, lbConfig, attributes) {\n    let childToUpdate;\n\n    if (this.currentChild === null || this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()) {\n      const newHelper = new this.ChildPolicyHelper(this);\n      const newChild = load_balancer_1.createLoadBalancer(lbConfig, newHelper);\n      newHelper.setChild(newChild);\n\n      if (this.currentChild === null) {\n        this.currentChild = newChild;\n        childToUpdate = this.currentChild;\n      } else {\n        if (this.pendingChild) {\n          this.pendingChild.destroy();\n        }\n\n        this.pendingChild = newChild;\n        childToUpdate = this.pendingChild;\n      }\n    } else {\n      if (this.pendingChild === null) {\n        childToUpdate = this.currentChild;\n      } else {\n        childToUpdate = this.pendingChild;\n      }\n    }\n\n    childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n  }\n\n  exitIdle() {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n\n  resetBackoff() {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n\n  destroy() {\n    if (this.currentChild) {\n      this.currentChild.destroy();\n      this.currentChild = null;\n    }\n\n    if (this.pendingChild) {\n      this.pendingChild.destroy();\n      this.pendingChild = null;\n    }\n  }\n\n  getTypeName() {\n    return TYPE_NAME;\n  }\n\n}\n\nexports.ChildLoadBalancerHandler = ChildLoadBalancerHandler;","map":{"version":3,"sources":["C:\\react\\quiz\\node_modules\\@grpc\\grpc-js\\src\\load-balancer-child-handler.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;;AAeG;;;;;;;AAEH,MAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AASA,MAAA,oBAAA,GAAA,OAAA,CAAA,sBAAA,CAAA;;AAIA,MAAM,SAAS,GAAG,4BAAlB;;AAEA,MAAa,wBAAb,CAAqC;AAqDnC,EAAA,WAAA,CAA6B,oBAA7B,EAAuE;AAA1C,SAAA,oBAAA,GAAA,oBAAA;AApDrB,SAAA,YAAA,GAAoC,IAApC;AACA,SAAA,YAAA,GAAoC,IAApC;AAEA,SAAA,iBAAA,GAAoB,MAAA;AAE1B,MAAA,WAAA,CAAoB,MAApB,EAAoD;AAAhC,aAAA,MAAA,GAAA,MAAA;AADZ,aAAA,KAAA,GAA6B,IAA7B;AACgD;;AACxD,MAAA,gBAAgB,CACd,iBADc,EAEd,cAFc,EAEgB;AAE9B,eAAO,KAAK,MAAL,CAAY,oBAAZ,CAAiC,gBAAjC,CACL,iBADK,EAEL,cAFK,CAAP;AAID;;AACD,MAAA,WAAW,CAAC,iBAAD,EAAuC,MAAvC,EAAqD;;;AAC9D,YAAI,KAAK,oBAAL,EAAJ,EAAiC;AAC/B,cAAI,iBAAiB,KAAK,oBAAA,CAAA,iBAAA,CAAkB,KAA5C,EAAmD;AACjD;AACD;;AACD,WAAA,EAAA,GAAA,KAAK,MAAL,CAAY,YAAZ,MAAwB,IAAxB,IAAwB,EAAA,KAAA,KAAA,CAAxB,GAAwB,KAAA,CAAxB,GAAwB,EAAA,CAAE,OAAF,EAAxB;AACA,eAAK,MAAL,CAAY,YAAZ,GAA2B,KAAK,MAAL,CAAY,YAAvC;AACA,eAAK,MAAL,CAAY,YAAZ,GAA2B,IAA3B;AACD,SAPD,MAOO,IAAI,CAAC,KAAK,oBAAL,EAAL,EAAkC;AACvC;AACD;;AACD,aAAK,MAAL,CAAY,oBAAZ,CAAiC,WAAjC,CAA6C,iBAA7C,EAAgE,MAAhE;AACD;;AACD,MAAA,mBAAmB,GAAA;;;AACjB,cAAM,WAAW,GAAA,CAAA,EAAA,GAAG,KAAK,MAAL,CAAY,YAAf,MAA2B,IAA3B,IAA2B,EAAA,KAAA,KAAA,CAA3B,GAA2B,EAA3B,GAA+B,KAAK,MAAL,CAAY,YAA5D;;AACA,YAAI,KAAK,KAAL,KAAe,WAAnB,EAAgC;AAC9B,eAAK,MAAL,CAAY,oBAAZ,CAAiC,mBAAjC;AACD;AACF;;AACD,MAAA,QAAQ,CAAC,QAAD,EAAuB;AAC7B,aAAK,KAAL,GAAa,QAAb;AACD;;AACD,MAAA,gBAAgB,CAAC,KAAD,EAAkC;AAChD,aAAK,MAAL,CAAY,oBAAZ,CAAiC,gBAAjC,CAAkD,KAAlD;AACD;;AACD,MAAA,mBAAmB,CAAC,KAAD,EAAkC;AACnD,aAAK,MAAL,CAAY,oBAAZ,CAAiC,mBAAjC,CAAqD,KAArD;AACD;;AAEO,MAAA,oBAAoB,GAAA;AAC1B,eAAO,KAAK,KAAL,KAAe,KAAK,MAAL,CAAY,YAAlC;AACD;;AACO,MAAA,oBAAoB,GAAA;AAC1B,eAAO,KAAK,KAAL,KAAe,KAAK,MAAL,CAAY,YAAlC;AACD;;AA9CyB,KAApB;AAiDmE;AAE3E;;;;;AAKG;;;AACH,EAAA,iBAAiB,CACf,WADe,EAEf,QAFe,EAGf,UAHe,EAGuB;AAEtC,QAAI,aAAJ;;AACA,QACE,KAAK,YAAL,KAAsB,IAAtB,IACA,KAAK,YAAL,CAAkB,WAAlB,OAAoC,QAAQ,CAAC,mBAAT,EAFtC,EAGE;AACA,YAAM,SAAS,GAAG,IAAI,KAAK,iBAAT,CAA2B,IAA3B,CAAlB;AACA,YAAM,QAAQ,GAAG,eAAA,CAAA,kBAAA,CAAmB,QAAnB,EAA6B,SAA7B,CAAjB;AACA,MAAA,SAAS,CAAC,QAAV,CAAmB,QAAnB;;AACA,UAAI,KAAK,YAAL,KAAsB,IAA1B,EAAgC;AAC9B,aAAK,YAAL,GAAoB,QAApB;AACA,QAAA,aAAa,GAAG,KAAK,YAArB;AACD,OAHD,MAGO;AACL,YAAI,KAAK,YAAT,EAAuB;AACrB,eAAK,YAAL,CAAkB,OAAlB;AACD;;AACD,aAAK,YAAL,GAAoB,QAApB;AACA,QAAA,aAAa,GAAG,KAAK,YAArB;AACD;AACF,KAjBD,MAiBO;AACL,UAAI,KAAK,YAAL,KAAsB,IAA1B,EAAgC;AAC9B,QAAA,aAAa,GAAG,KAAK,YAArB;AACD,OAFD,MAEO;AACL,QAAA,aAAa,GAAG,KAAK,YAArB;AACD;AACF;;AACD,IAAA,aAAa,CAAC,iBAAd,CAAgC,WAAhC,EAA6C,QAA7C,EAAuD,UAAvD;AACD;;AACD,EAAA,QAAQ,GAAA;AACN,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,YAAL,CAAkB,YAAlB;;AACA,UAAI,KAAK,YAAT,EAAuB;AACrB,aAAK,YAAL,CAAkB,YAAlB;AACD;AACF;AACF;;AACD,EAAA,YAAY,GAAA;AACV,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,YAAL,CAAkB,YAAlB;;AACA,UAAI,KAAK,YAAT,EAAuB;AACrB,aAAK,YAAL,CAAkB,YAAlB;AACD;AACF;AACF;;AACD,EAAA,OAAO,GAAA;AACL,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,YAAL,CAAkB,OAAlB;AACA,WAAK,YAAL,GAAoB,IAApB;AACD;;AACD,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,YAAL,CAAkB,OAAlB;AACA,WAAK,YAAL,GAAoB,IAApB;AACD;AACF;;AACD,EAAA,WAAW,GAAA;AACT,WAAO,SAAP;AACD;;AAzHkC;;AAArC,OAAA,CAAA,wBAAA,GAAA,wBAAA","sourcesContent":["/*\n * Copyright 2020 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport {\n  LoadBalancer,\n  ChannelControlHelper,\n  LoadBalancingConfig,\n  createLoadBalancer,\n} from './load-balancer';\nimport { Subchannel } from './subchannel';\nimport { SubchannelAddress } from './subchannel-address';\nimport { ChannelOptions } from './channel-options';\nimport { ConnectivityState } from './connectivity-state';\nimport { Picker } from './picker';\nimport { ChannelRef, SubchannelRef } from './channelz';\n\nconst TYPE_NAME = 'child_load_balancer_helper';\n\nexport class ChildLoadBalancerHandler implements LoadBalancer {\n  private currentChild: LoadBalancer | null = null;\n  private pendingChild: LoadBalancer | null = null;\n\n  private ChildPolicyHelper = class {\n    private child: LoadBalancer | null = null;\n    constructor(private parent: ChildLoadBalancerHandler) {}\n    createSubchannel(\n      subchannelAddress: SubchannelAddress,\n      subchannelArgs: ChannelOptions\n    ): Subchannel {\n      return this.parent.channelControlHelper.createSubchannel(\n        subchannelAddress,\n        subchannelArgs\n      );\n    }\n    updateState(connectivityState: ConnectivityState, picker: Picker): void {\n      if (this.calledByPendingChild()) {\n        if (connectivityState !== ConnectivityState.READY) {\n          return;\n        }\n        this.parent.currentChild?.destroy();\n        this.parent.currentChild = this.parent.pendingChild;\n        this.parent.pendingChild = null;\n      } else if (!this.calledByCurrentChild()) {\n        return;\n      }\n      this.parent.channelControlHelper.updateState(connectivityState, picker);\n    }\n    requestReresolution(): void {\n      const latestChild = this.parent.pendingChild ?? this.parent.currentChild;\n      if (this.child === latestChild) {\n        this.parent.channelControlHelper.requestReresolution();\n      }\n    }\n    setChild(newChild: LoadBalancer) {\n      this.child = newChild;\n    }\n    addChannelzChild(child: ChannelRef | SubchannelRef) {\n      this.parent.channelControlHelper.addChannelzChild(child);\n    }\n    removeChannelzChild(child: ChannelRef | SubchannelRef) {\n      this.parent.channelControlHelper.removeChannelzChild(child);\n    }\n    \n    private calledByPendingChild(): boolean {\n      return this.child === this.parent.pendingChild;\n    }\n    private calledByCurrentChild(): boolean {\n      return this.child === this.parent.currentChild;\n    }\n  };\n\n  constructor(private readonly channelControlHelper: ChannelControlHelper) {}\n\n  /**\n   * Prerequisites: lbConfig !== null and lbConfig.name is registered\n   * @param addressList\n   * @param lbConfig\n   * @param attributes\n   */\n  updateAddressList(\n    addressList: SubchannelAddress[],\n    lbConfig: LoadBalancingConfig,\n    attributes: { [key: string]: unknown }\n  ): void {\n    let childToUpdate: LoadBalancer;\n    if (\n      this.currentChild === null ||\n      this.currentChild.getTypeName() !== lbConfig.getLoadBalancerName()\n    ) {\n      const newHelper = new this.ChildPolicyHelper(this);\n      const newChild = createLoadBalancer(lbConfig, newHelper)!;\n      newHelper.setChild(newChild);\n      if (this.currentChild === null) {\n        this.currentChild = newChild;\n        childToUpdate = this.currentChild;\n      } else {\n        if (this.pendingChild) {\n          this.pendingChild.destroy();\n        }\n        this.pendingChild = newChild;\n        childToUpdate = this.pendingChild;\n      }\n    } else {\n      if (this.pendingChild === null) {\n        childToUpdate = this.currentChild;\n      } else {\n        childToUpdate = this.pendingChild;\n      }\n    }\n    childToUpdate.updateAddressList(addressList, lbConfig, attributes);\n  }\n  exitIdle(): void {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n  resetBackoff(): void {\n    if (this.currentChild) {\n      this.currentChild.resetBackoff();\n      if (this.pendingChild) {\n        this.pendingChild.resetBackoff();\n      }\n    }\n  }\n  destroy(): void {\n    if (this.currentChild) {\n      this.currentChild.destroy();\n      this.currentChild = null;\n    }\n    if (this.pendingChild) {\n      this.pendingChild.destroy();\n      this.pendingChild = null;\n    }\n  }\n  getTypeName(): string {\n    return TYPE_NAME;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}