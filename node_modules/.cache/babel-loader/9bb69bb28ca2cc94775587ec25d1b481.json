{"ast":null,"code":"// Copyright 2012 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n'use strict';\n\nvar assert = require('assert');\n\nvar Heap = function (min) {\n  this.length = 0;\n  this.root = undefined;\n\n  if (min) {\n    this._comparator = this._smallest;\n  } else {\n    this._comparator = this._largest;\n  }\n};\n\nHeap.init = function (obj, key) {\n  obj._parent = null;\n  obj._left = null;\n  obj._right = null;\n  obj._key = key;\n  return obj;\n};\n\nHeap.prototype.count = function (node) {\n  if (!node) return 0;\n  var c = 1;\n  c += this.count(node._left);\n  c += this.count(node._right);\n  return c;\n};\n\nHeap.prototype.insert = function (obj, key) {\n  var insert, node;\n  this.length += 1;\n  node = Heap.init(obj, key);\n\n  if (!this.root) {\n    this.root = node;\n  } else {\n    insert = this._last();\n    node._parent = insert;\n    if (!insert._left) insert._left = node;else insert._right = node;\n\n    this._up(node);\n  }\n\n  this._head();\n\n  return node;\n};\n\nHeap.prototype.pop = function () {\n  var ret, last;\n  if (!this.root) return null;\n  return this.remove(this.root);\n};\n\nHeap.prototype.remove = function (node) {\n  var ret, last;\n  ret = node;\n  last = this._last();\n  if (last._right) last = last._right;else last = last._left;\n  this.length -= 1;\n\n  if (!last) {\n    if (ret == this.root) this.root = null;\n    return ret;\n  }\n\n  if (ret == last) {\n    if (ret._parent._left == node) ret._parent._left = null;else ret._parent._right = null;\n    last = ret._parent;\n    ret._parent = null;\n  } else if (!ret._left && !ret._right) {\n    // we're trying to remove an element without any children and its not the last\n    // move the last under its parent and heap-up\n    if (last._parent._left == last) last._parent._left = null;else last._parent._right = null;\n    if (ret._parent._left == ret) ret._parent._left = last;else ret._parent._right = last;\n    last._parent = ret._parent;\n    ret._parent = null; // TODO in this case we shouldn't later also do a down, but it should only visit once\n\n    this._up(last);\n  } else {\n    this._delete_swap(ret, last);\n  }\n\n  if (ret == this.root) this.root = last;\n\n  this._down(last);\n\n  this._head();\n\n  return ret;\n}; // TODO this probably isn't the most efficient way to ensure that we're always\n// at the root of the tree, but it works for now\n\n\nHeap.prototype._head = function () {\n  if (!this.root) return;\n  var tmp = this.root;\n\n  while (tmp._parent) {\n    tmp = tmp._parent;\n  }\n\n  this.root = tmp;\n}; // TODO is there a more efficient way to store this instead of an array?\n\n\nHeap.prototype._last = function () {\n  var path, pos, mod, insert;\n  pos = this.length;\n  path = [];\n\n  while (pos > 1) {\n    mod = pos % 2;\n    pos = Math.floor(pos / 2);\n    path.push(mod);\n  }\n\n  insert = this.root;\n\n  while (path.length > 1) {\n    pos = path.pop();\n    if (pos === 0) insert = insert._left;else insert = insert._right;\n  }\n\n  return insert;\n};\n\nHeap.prototype._swap = function (a, b) {\n  var cleft, cright, tparent;\n  cleft = b._left;\n  cright = b._right;\n\n  if (a._parent) {\n    if (a._parent._left == a) a._parent._left = b;else a._parent._right = b;\n  }\n\n  b._parent = a._parent;\n  a._parent = b; // This assumes direct descendents\n\n  if (a._left == b) {\n    b._left = a;\n    b._right = a._right;\n    if (b._right) b._right._parent = b;\n  } else {\n    b._right = a;\n    b._left = a._left;\n    if (b._left) b._left._parent = b;\n  }\n\n  a._left = cleft;\n  a._right = cright;\n  if (a._left) a._left._parent = a;\n  if (a._right) a._right._parent = a;\n  assert.notEqual(a._parent, a, \"A shouldn't refer to itself\");\n  assert.notEqual(b._parent, b, \"B shouldn't refer to itself\");\n};\n\nHeap.prototype._delete_swap = function (a, b) {\n  if (a._left != b) b._left = a._left;\n  if (a._right != b) b._right = a._right;\n  if (b._parent._left == b) b._parent._left = null;else b._parent._right = null;\n\n  if (a._parent) {\n    if (a._parent._left == a) a._parent._left = b;else a._parent._right = b;\n  }\n\n  b._parent = a._parent;\n  if (b._left) b._left._parent = b;\n  if (b._right) b._right._parent = b;\n  a._parent = null;\n  a._left = null;\n  a._right = null;\n};\n\nHeap.prototype._smallest = function (heap) {\n  var small = heap;\n\n  if (heap._left && heap._key > heap._left._key) {\n    small = heap._left;\n  }\n\n  if (heap._right && small._key > heap._right._key) {\n    small = heap._right;\n  }\n\n  return small;\n};\n\nHeap.prototype._largest = function (heap) {\n  var large = heap;\n\n  if (heap._left && heap._key < heap._left._key) {\n    large = heap._left;\n  }\n\n  if (heap._right && large._key < heap._right._key) {\n    large = heap._right;\n  }\n\n  return large;\n};\n\nHeap.prototype._up = function (node) {\n  if (!node || !node._parent) return;\n\n  var next = this._comparator(node._parent);\n\n  if (next != node._parent) {\n    this._swap(node._parent, node);\n\n    this._up(node);\n  }\n};\n\nHeap.prototype._down = function (node) {\n  if (!node) return;\n\n  var next = this._comparator(node);\n\n  if (next != node) {\n    this._swap(node, next);\n\n    this._down(node);\n  }\n};\n\nvar util = require('util');\n\nHeap.prototype.print = function (stream) {\n  stream.write('digraph {\\n');\n\n  Heap._print(this.root, stream);\n\n  stream.write('}\\n');\n};\n\nHeap._print = function (heap, stream) {\n  if (!heap) return;\n\n  if (heap._left) {\n    stream.write(util.format('' + heap._key, '->', heap._left._key, '\\n'));\n\n    Heap._print(heap._left, stream);\n  }\n\n  if (heap._right) {\n    stream.write(util.format('' + heap._key, '->', heap._right._key, '\\n'));\n\n    Heap._print(heap._right, stream);\n  }\n};\n\nmodule.exports = Heap;","map":{"version":3,"sources":["C:/react/quiz/node_modules/binaryheap/binaryheap.js"],"names":["assert","require","Heap","min","length","root","undefined","_comparator","_smallest","_largest","init","obj","key","_parent","_left","_right","_key","prototype","count","node","c","insert","_last","_up","_head","pop","ret","last","remove","_delete_swap","_down","tmp","path","pos","mod","Math","floor","push","_swap","a","b","cleft","cright","tparent","notEqual","heap","small","large","next","util","print","stream","write","_print","format","module","exports"],"mappings":"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","sourcesContent":["// Copyright 2012 Timothy J Fontaine <tjfontaine@gmail.com>\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE\n\n'use strict';\n\nvar assert = require('assert');\n\nvar Heap = function(min) {\n  this.length = 0;\n  this.root = undefined;\n  if (min) {\n    this._comparator = this._smallest;\n  } else {\n    this._comparator = this._largest;\n  }\n};\n\nHeap.init = function(obj, key) {\n  obj._parent = null;\n  obj._left = null;\n  obj._right = null;\n  obj._key = key;\n  return obj;\n};\n\nHeap.prototype.count = function (node) {\n  if (!node) return 0;\n\n  var c = 1;\n\n  c += this.count(node._left);\n  c += this.count(node._right);\n\n  return c;\n};\n\nHeap.prototype.insert = function(obj, key) {\n  var insert, node;\n\n  this.length += 1;\n\n  node = Heap.init(obj, key);\n\n  if (!this.root) {\n    this.root = node;\n  } else {\n    insert = this._last();\n\n    node._parent = insert;\n\n    if (!insert._left)\n      insert._left = node;\n    else\n      insert._right = node;\n\n    this._up(node);\n  }\n\n  this._head();\n\n  return node;\n};\n\nHeap.prototype.pop = function() {\n  var ret, last;\n\n  if (!this.root)\n    return null;\n\n  return this.remove(this.root);\n};\n\nHeap.prototype.remove = function(node) {\n  var ret, last;\n\n  ret = node;\n  last = this._last();\n\n  if (last._right)\n    last = last._right;\n  else\n    last = last._left;\n\n  this.length -= 1;\n\n  if (!last) {\n    if (ret == this.root)\n      this.root = null;\n    return ret;\n  }\n\n  if (ret == last) {\n    if (ret._parent._left == node)\n      ret._parent._left = null;\n    else\n      ret._parent._right = null;\n    last = ret._parent;\n    ret._parent = null;\n  } else if (!ret._left && !ret._right) {\n    // we're trying to remove an element without any children and its not the last\n    // move the last under its parent and heap-up\n    if (last._parent._left == last) last._parent._left = null;\n    else last._parent._right = null;\n\n    if (ret._parent._left == ret) ret._parent._left = last;\n    else ret._parent._right = last;\n\n    last._parent = ret._parent;\n\n    ret._parent = null;\n\n    // TODO in this case we shouldn't later also do a down, but it should only visit once\n    this._up(last);\n  } else {\n    this._delete_swap(ret, last);\n  }\n\n  if (ret == this.root)\n    this.root = last;\n\n  this._down(last);\n  this._head();\n\n  return ret;\n};\n\n// TODO this probably isn't the most efficient way to ensure that we're always\n// at the root of the tree, but it works for now\nHeap.prototype._head = function() {\n  if (!this.root)\n    return;\n\n  var tmp = this.root;\n  while (tmp._parent) {\n    tmp = tmp._parent;\n  }\n\n  this.root = tmp;\n};\n\n// TODO is there a more efficient way to store this instead of an array?\nHeap.prototype._last = function() {\n  var path, pos, mod, insert;\n\n  pos = this.length;\n  path = [];\n  while (pos > 1) {\n    mod = pos % 2;\n    pos = Math.floor(pos / 2);\n    path.push(mod);\n  }\n\n  insert = this.root;\n\n  while (path.length > 1) {\n    pos = path.pop();\n    if (pos === 0)\n      insert = insert._left;\n    else\n      insert = insert._right;\n  }\n\n  return insert;\n};\n\nHeap.prototype._swap = function(a, b) {\n  var cleft, cright, tparent;\n\n  cleft = b._left;\n  cright = b._right;\n\n  if (a._parent) {\n    if (a._parent._left == a) a._parent._left = b;\n    else a._parent._right = b;\n  }\n\n  b._parent = a._parent;\n  a._parent = b;\n\n  // This assumes direct descendents\n  if (a._left == b) {\n    b._left = a;\n    b._right = a._right;\n    if (b._right) b._right._parent = b;\n  } else {\n    b._right = a;\n    b._left = a._left;\n    if (b._left) b._left._parent = b;\n  }\n\n  a._left = cleft;\n  a._right = cright;\n\n  if (a._left) a._left._parent = a;\n  if (a._right) a._right._parent = a;\n\n  assert.notEqual(a._parent, a, \"A shouldn't refer to itself\");\n  assert.notEqual(b._parent, b, \"B shouldn't refer to itself\");\n};\n\nHeap.prototype._delete_swap = function(a, b) {\n  if (a._left != b) b._left = a._left;\n  if (a._right != b) b._right = a._right;\n\n  if (b._parent._left == b) b._parent._left = null;\n  else b._parent._right = null;\n\n  if (a._parent) {\n    if (a._parent._left == a) a._parent._left = b;\n    else a._parent._right = b;\n  }\n\n  b._parent = a._parent;\n\n  if (b._left) b._left._parent = b;\n  if (b._right) b._right._parent = b;\n\n  a._parent = null;\n  a._left = null;\n  a._right = null;\n};\n\nHeap.prototype._smallest = function(heap) {\n  var small = heap;\n\n  if (heap._left && heap._key > heap._left._key) {\n    small = heap._left;\n  }\n\n  if (heap._right && small._key > heap._right._key) {\n    small = heap._right;\n  }\n\n  return small;\n};\n\nHeap.prototype._largest = function(heap) {\n  var large = heap;\n\n  if (heap._left && heap._key < heap._left._key) {\n    large = heap._left;\n  }\n\n  if (heap._right && large._key < heap._right._key) {\n    large = heap._right;\n  }\n\n  return large;\n};\n\nHeap.prototype._up = function(node) {\n  if (!node || !node._parent)\n    return;\n\n  var next = this._comparator(node._parent);\n\n  if (next != node._parent) {\n    this._swap(node._parent, node);\n    this._up(node);\n  }\n};\n\nHeap.prototype._down = function(node) {\n  if (!node)\n    return;\n\n  var next = this._comparator(node);\n  if (next != node) {\n    this._swap(node, next);\n    this._down(node);\n  }\n};\n\nvar util = require('util');\n\nHeap.prototype.print = function(stream) {\n  stream.write('digraph {\\n');\n  Heap._print(this.root, stream);\n  stream.write('}\\n');\n};\n\nHeap._print = function(heap, stream) {\n  if (!heap) return;\n\n  if (heap._left) {\n    stream.write(util.format('' + heap._key, '->', heap._left._key, '\\n'));\n    Heap._print(heap._left, stream);\n  }\n\n  if (heap._right) {\n    stream.write(util.format('' + heap._key, '->', heap._right._key, '\\n'));\n    Heap._print(heap._right, stream);\n  }\n};\n\nmodule.exports = Heap;\n"]},"metadata":{},"sourceType":"script"}