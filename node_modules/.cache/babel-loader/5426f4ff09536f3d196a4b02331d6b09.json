{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Subchannel = void 0;\n\nconst http2 = require(\"http2\");\n\nconst tls_1 = require(\"tls\");\n\nconst connectivity_state_1 = require(\"./connectivity-state\");\n\nconst backoff_timeout_1 = require(\"./backoff-timeout\");\n\nconst resolver_1 = require(\"./resolver\");\n\nconst logging = require(\"./logging\");\n\nconst constants_1 = require(\"./constants\");\n\nconst http_proxy_1 = require(\"./http_proxy\");\n\nconst net = require(\"net\");\n\nconst uri_parser_1 = require(\"./uri-parser\");\n\nconst subchannel_address_1 = require(\"./subchannel-address\");\n\nconst channelz_1 = require(\"./channelz\");\n\nconst clientVersion = require('../../package.json').version;\n\nconst TRACER_NAME = 'subchannel';\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\n\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT\n} = http2.constants;\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nconst tooManyPingsData = Buffer.from('too_many_pings', 'ascii');\n\nclass Subchannel {\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(channelTarget, subchannelAddress, options, credentials) {\n    this.channelTarget = channelTarget;\n    this.subchannelAddress = subchannelAddress;\n    this.options = options;\n    this.credentials = credentials;\n    /**\n     * The subchannel's current connectivity state. Invariant: `session` === `null`\n     * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n     */\n\n    this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;\n    /**\n     * The underlying http2 session used to make requests.\n     */\n\n    this.session = null;\n    /**\n     * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n     * CONNECTING instead of IDLE when the backoff timeout ends.\n     */\n\n    this.continueConnecting = false;\n    /**\n     * A list of listener functions that will be called whenever the connectivity\n     * state changes. Will be modified by `addConnectivityStateListener` and\n     * `removeConnectivityStateListener`\n     */\n\n    this.stateListeners = [];\n    /**\n     * A list of listener functions that will be called when the underlying\n     * socket disconnects. Used for ending active calls with an UNAVAILABLE\n     * status.\n     */\n\n    this.disconnectListeners = [];\n    /**\n     * The amount of time in between sending pings\n     */\n\n    this.keepaliveTimeMs = KEEPALIVE_MAX_TIME_MS;\n    /**\n     * The amount of time to wait for an acknowledgement after sending a ping\n     */\n\n    this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    /**\n     * Indicates whether keepalive pings should be sent without any active calls\n     */\n\n    this.keepaliveWithoutCalls = false;\n    /**\n     * Tracks calls with references to this subchannel\n     */\n\n    this.callRefcount = 0;\n    /**\n     * Tracks channels and subchannel pools with references to this subchannel\n     */\n\n    this.refcount = 0; // Channelz info\n\n    this.channelzEnabled = true;\n    this.callTracker = new channelz_1.ChannelzCallTracker();\n    this.childrenTracker = new channelz_1.ChannelzChildrenTracker(); // Channelz socket info\n\n    this.channelzSocketRef = null;\n    /**\n     * Name of the remote server, if it is not the same as the subchannel\n     * address, i.e. if connecting through an HTTP CONNECT proxy.\n     */\n\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null; // Build user-agent string.\n\n    this.userAgent = [options['grpc.primary_user_agent'], `grpc-node-js/${clientVersion}`, options['grpc.secondary_user_agent']].filter(e => e).join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms'];\n    }\n\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms'];\n    }\n\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls = options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms']\n    };\n    this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannel_address_1.subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n\n    this.channelzTrace = new channelz_1.ChannelzTrace();\n\n    if (this.channelzEnabled) {\n      this.channelzRef = channelz_1.registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'subchannel',\n        id: -1,\n        name: ''\n      };\n    }\n\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  getChannelzInfo() {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  getChannelzSocketInfo() {\n    var _a, _b, _c;\n\n    if (this.session === null) {\n      return null;\n    }\n\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? subchannel_address_1.stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo;\n\n    if (this.session.encrypted) {\n      const tlsSocket = sessionSocket;\n      const cipherInfo = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: (_a = cipherInfo.standardName) !== null && _a !== void 0 ? _a : null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: certificate && 'raw' in certificate ? certificate.raw : null,\n        remoteCertificate: peerCertificate && 'raw' in peerCertificate ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n\n    const socketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: (_b = this.session.state.localWindowSize) !== null && _b !== void 0 ? _b : null,\n      remoteFlowControlWindow: (_c = this.session.state.remoteWindowSize) !== null && _c !== void 0 ? _c : null\n    };\n    return socketInfo;\n  }\n\n  resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n\n    if (this.channelzSocketRef) {\n      channelz_1.unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n\n    this.remoteName = null;\n    this.streamTracker = new channelz_1.ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n\n  trace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  refTrace(text) {\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n    } else {\n      this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.IDLE);\n    }\n  }\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n\n\n  startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  sendPing() {\n    var _a, _b;\n\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'keepalive', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + 'Sending ping');\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n    }, this.keepaliveTimeoutMs);\n    (_b = (_a = this.keepaliveTimeoutId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    this.session.ping((err, duration, payload) => {\n      clearTimeout(this.keepaliveTimeoutId);\n    });\n  }\n\n  startKeepalivePings() {\n    var _a, _b;\n\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    (_b = (_a = this.keepaliveIntervalId).unref) === null || _b === void 0 ? void 0 : _b.call(_a);\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  createSession(proxyConnectionResult) {\n    var _a, _b, _c;\n\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uri_parser_1.uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n\n    const targetAuthority = resolver_1.getDefaultAuthority((_a = proxyConnectionResult.realTarget) !== null && _a !== void 0 ? _a : this.channelTarget);\n    let connectionOptions = this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options['grpc-node.max_session_memory'];\n    }\n\n    let addressScheme = 'http://';\n\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://'; // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname = (_c = (_b = uri_parser_1.splitHostPort(targetAuthority)) === null || _b === void 0 ? void 0 : _b.host) !== null && _c !== void 0 ? _c : 'localhost'; // We want to always set servername to support SNI\n\n        connectionOptions.servername = authorityHostname;\n      }\n\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n\n    connectionOptions = Object.assign(Object.assign({}, connectionOptions), this.subchannelAddress);\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n\n    const session = http2.connect(addressScheme + targetAuthority, connectionOptions);\n    this.session = session;\n\n    if (this.channelzEnabled) {\n      this.channelzSocketRef = channelz_1.registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo());\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.READY);\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n\n        this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('goaway', (errorCode, lastStreamID, opaqueData) => {\n      if (this.session === session) {\n        /* See the last paragraph of\n         * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n        if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData.equals(tooManyPingsData)) {\n          this.keepaliveTimeMs = Math.min(2 * this.keepaliveTimeMs, KEEPALIVE_MAX_TIME_MS);\n          logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${uri_parser_1.uriToString(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTimeMs} ms`);\n        }\n\n        this.trace('connection closed by GOAWAY with code ' + errorCode);\n        this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.IDLE);\n      }\n    });\n    session.once('error', error => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace('connection closed with error ' + error.message);\n    });\n  }\n\n  startConnectingInternal() {\n    var _a, _b;\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n\n\n    const connectionOptions = this.credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2']; // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n        connectionOptions.checkServerIdentity = (host, cert) => {\n          return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n        };\n\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = resolver_1.getDefaultAuthority((_a = uri_parser_1.parseUri(this.options['grpc.http_connect_target'])) !== null && _a !== void 0 ? _a : {\n            path: 'localhost'\n          });\n          const hostPort = uri_parser_1.splitHostPort(targetPath);\n          connectionOptions.servername = (_b = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _b !== void 0 ? _b : targetPath;\n        }\n      }\n    }\n\n    http_proxy_1.getProxiedConnection(this.subchannelAddress, this.options, connectionOptions).then(result => {\n      this.createSession(result);\n    }, reason => {\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n    });\n  }\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n\n\n  transitionToState(oldStates, newState) {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n\n    this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', connectivity_state_1.ConnectivityState[this.connectivityState] + ' -> ' + connectivity_state_1.ConnectivityState[newState]);\n    }\n\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n\n    switch (newState) {\n      case connectivity_state_1.ConnectivityState.READY:\n        this.stopBackoff();\n        this.session.socket.once('close', () => {\n          for (const listener of this.disconnectListeners) {\n            listener();\n          }\n        });\n\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n\n        break;\n\n      case connectivity_state_1.ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n\n      case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n\n        break;\n\n      case connectivity_state_1.ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n\n\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n\n    return true;\n  }\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n\n\n  checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n\n      this.transitionToState([connectivity_state_1.ConnectivityState.CONNECTING, connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n\n      if (this.channelzEnabled) {\n        channelz_1.unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  callRef() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount + 1));\n\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n\n      this.backoffTimeout.ref();\n\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    this.refTrace('callRefcount ' + this.callRefcount + ' -> ' + (this.callRefcount - 1));\n    this.callRefcount -= 1;\n\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n\n      this.backoffTimeout.unref();\n\n      if (!this.keepaliveWithoutCalls) {\n        this.stopKeepalivePings();\n      }\n\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount + 1));\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace('refcount ' + this.refcount + ' -> ' + (this.refcount - 1));\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef() {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n\n\n  startCallStream(metadata, callStream, extraFilters) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n\n    try {\n      http2Stream = this.session.request(headers);\n    } catch (e) {\n      this.transitionToState([connectivity_state_1.ConnectivityState.READY], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE);\n      throw e;\n    }\n\n    let headersString = '';\n\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n\n    logging.trace(constants_1.LogVerbosity.DEBUG, 'call_stream', 'Starting stream on subchannel ' + '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' with headers\\n' + headersString);\n    const streamSession = this.session;\n    let statsTracker;\n\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === constants_1.Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      };\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      };\n    }\n\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n\n\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (!this.transitionToState([connectivity_state_1.ConnectivityState.IDLE], connectivity_state_1.ConnectivityState.CONNECTING)) {\n      if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n\n\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n\n\n  addConnectivityStateListener(listener) {\n    this.stateListeners.push(listener);\n  }\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n\n\n  removeConnectivityStateListener(listener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener) {\n    this.disconnectListeners.push(listener);\n  }\n\n  removeDisconnectListener(listener) {\n    const listenerIndex = this.disconnectListeners.indexOf(listener);\n\n    if (listenerIndex > -1) {\n      this.disconnectListeners.splice(listenerIndex, 1);\n    }\n  }\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n\n\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState([connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE], connectivity_state_1.ConnectivityState.CONNECTING);\n  }\n\n  getAddress() {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef() {\n    return this.channelzRef;\n  }\n\n}\n\nexports.Subchannel = Subchannel;","map":{"version":3,"sources":["C:\\react\\quiz\\node_modules\\@grpc\\grpc-js\\src\\subchannel.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright 2019 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\nimport * as http2 from 'http2';\nimport { ChannelCredentials } from './channel-credentials';\nimport { Metadata } from './metadata';\nimport { Call, Http2CallStream, WriteObject } from './call-stream';\nimport { ChannelOptions } from './channel-options';\nimport { PeerCertificate, checkServerIdentity, TLSSocket, CipherNameAndProtocol } from 'tls';\nimport { ConnectivityState } from './connectivity-state';\nimport { BackoffTimeout, BackoffOptions } from './backoff-timeout';\nimport { getDefaultAuthority } from './resolver';\nimport * as logging from './logging';\nimport { LogVerbosity, Status } from './constants';\nimport { getProxiedConnection, ProxyConnectionResult } from './http_proxy';\nimport * as net from 'net';\nimport { GrpcUri, parseUri, splitHostPort, uriToString } from './uri-parser';\nimport { ConnectionOptions } from 'tls';\nimport { FilterFactory, Filter, BaseFilter } from './filter';\nimport {\n  stringToSubchannelAddress,\n  SubchannelAddress,\n  subchannelAddressToString,\n} from './subchannel-address';\nimport { SubchannelRef, ChannelzTrace, ChannelzChildrenTracker, SubchannelInfo, registerChannelzSubchannel, ChannelzCallTracker, SocketInfo, SocketRef, unregisterChannelzRef, registerChannelzSocket, TlsInfo } from './channelz';\n\nconst clientVersion = require('../../package.json').version;\n\nconst TRACER_NAME = 'subchannel';\n\nconst MIN_CONNECT_TIMEOUT_MS = 20000;\nconst INITIAL_BACKOFF_MS = 1000;\nconst BACKOFF_MULTIPLIER = 1.6;\nconst MAX_BACKOFF_MS = 120000;\nconst BACKOFF_JITTER = 0.2;\n\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\nconst KEEPALIVE_MAX_TIME_MS = ~(1 << 31);\nconst KEEPALIVE_TIMEOUT_MS = 20000;\n\nexport type ConnectivityStateListener = (\n  subchannel: Subchannel,\n  previousState: ConnectivityState,\n  newState: ConnectivityState\n) => void;\n\nexport interface SubchannelCallStatsTracker {\n  addMessageSent(): void;\n  addMessageReceived(): void;\n}\n\nconst {\n  HTTP2_HEADER_AUTHORITY,\n  HTTP2_HEADER_CONTENT_TYPE,\n  HTTP2_HEADER_METHOD,\n  HTTP2_HEADER_PATH,\n  HTTP2_HEADER_TE,\n  HTTP2_HEADER_USER_AGENT,\n} = http2.constants;\n\n/**\n * Get a number uniformly at random in the range [min, max)\n * @param min\n * @param max\n */\nfunction uniformRandom(min: number, max: number) {\n  return Math.random() * (max - min) + min;\n}\n\nconst tooManyPingsData: Buffer = Buffer.from('too_many_pings', 'ascii');\n\nexport class Subchannel {\n  /**\n   * The subchannel's current connectivity state. Invariant: `session` === `null`\n   * if and only if `connectivityState` is IDLE or TRANSIENT_FAILURE.\n   */\n  private connectivityState: ConnectivityState = ConnectivityState.IDLE;\n  /**\n   * The underlying http2 session used to make requests.\n   */\n  private session: http2.ClientHttp2Session | null = null;\n  /**\n   * Indicates that the subchannel should transition from TRANSIENT_FAILURE to\n   * CONNECTING instead of IDLE when the backoff timeout ends.\n   */\n  private continueConnecting = false;\n  /**\n   * A list of listener functions that will be called whenever the connectivity\n   * state changes. Will be modified by `addConnectivityStateListener` and\n   * `removeConnectivityStateListener`\n   */\n  private stateListeners: ConnectivityStateListener[] = [];\n\n  /**\n   * A list of listener functions that will be called when the underlying\n   * socket disconnects. Used for ending active calls with an UNAVAILABLE\n   * status.\n   */\n  private disconnectListeners: Array<() => void> = [];\n\n  private backoffTimeout: BackoffTimeout;\n\n  /**\n   * The complete user agent string constructed using channel args.\n   */\n  private userAgent: string;\n\n  /**\n   * The amount of time in between sending pings\n   */\n  private keepaliveTimeMs: number = KEEPALIVE_MAX_TIME_MS;\n  /**\n   * The amount of time to wait for an acknowledgement after sending a ping\n   */\n  private keepaliveTimeoutMs: number = KEEPALIVE_TIMEOUT_MS;\n  /**\n   * Timer reference for timeout that indicates when to send the next ping\n   */\n  private keepaliveIntervalId: NodeJS.Timer;\n  /**\n   * Timer reference tracking when the most recent ping will be considered lost\n   */\n  private keepaliveTimeoutId: NodeJS.Timer;\n  /**\n   * Indicates whether keepalive pings should be sent without any active calls\n   */\n  private keepaliveWithoutCalls = false;\n\n  /**\n   * Tracks calls with references to this subchannel\n   */\n  private callRefcount = 0;\n  /**\n   * Tracks channels and subchannel pools with references to this subchannel\n   */\n  private refcount = 0;\n\n  /**\n   * A string representation of the subchannel address, for logging/tracing\n   */\n  private subchannelAddressString: string;\n\n  // Channelz info\n  private readonly channelzEnabled: boolean = true;\n  private channelzRef: SubchannelRef;\n  private channelzTrace: ChannelzTrace;\n  private callTracker = new ChannelzCallTracker();\n  private childrenTracker = new ChannelzChildrenTracker();\n\n  // Channelz socket info\n  private channelzSocketRef: SocketRef | null = null;\n  /**\n   * Name of the remote server, if it is not the same as the subchannel\n   * address, i.e. if connecting through an HTTP CONNECT proxy.\n   */\n  private remoteName: string | null = null;\n  private streamTracker = new ChannelzCallTracker();\n  private keepalivesSent = 0;\n  private messagesSent = 0;\n  private messagesReceived = 0;\n  private lastMessageSentTimestamp: Date | null = null;\n  private lastMessageReceivedTimestamp: Date | null = null;\n\n  /**\n   * A class representing a connection to a single backend.\n   * @param channelTarget The target string for the channel as a whole\n   * @param subchannelAddress The address for the backend that this subchannel\n   *     will connect to\n   * @param options The channel options, plus any specific subchannel options\n   *     for this subchannel\n   * @param credentials The channel credentials used to establish this\n   *     connection\n   */\n  constructor(\n    private channelTarget: GrpcUri,\n    private subchannelAddress: SubchannelAddress,\n    private options: ChannelOptions,\n    private credentials: ChannelCredentials\n  ) {\n    // Build user-agent string.\n    this.userAgent = [\n      options['grpc.primary_user_agent'],\n      `grpc-node-js/${clientVersion}`,\n      options['grpc.secondary_user_agent'],\n    ]\n      .filter((e) => e)\n      .join(' '); // remove falsey values first\n\n    if ('grpc.keepalive_time_ms' in options) {\n      this.keepaliveTimeMs = options['grpc.keepalive_time_ms']!;\n    }\n    if ('grpc.keepalive_timeout_ms' in options) {\n      this.keepaliveTimeoutMs = options['grpc.keepalive_timeout_ms']!;\n    }\n    if ('grpc.keepalive_permit_without_calls' in options) {\n      this.keepaliveWithoutCalls =\n        options['grpc.keepalive_permit_without_calls'] === 1;\n    } else {\n      this.keepaliveWithoutCalls = false;\n    }\n    this.keepaliveIntervalId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveIntervalId);\n    this.keepaliveTimeoutId = setTimeout(() => {}, 0);\n    clearTimeout(this.keepaliveTimeoutId);\n    const backoffOptions: BackoffOptions = {\n      initialDelay: options['grpc.initial_reconnect_backoff_ms'],\n      maxDelay: options['grpc.max_reconnect_backoff_ms'],\n    };\n    this.backoffTimeout = new BackoffTimeout(() => {\n      this.handleBackoffTimer();\n    }, backoffOptions);\n    this.subchannelAddressString = subchannelAddressToString(subchannelAddress);\n\n    if (options['grpc.enable_channelz'] === 0) {\n      this.channelzEnabled = false;\n    }\n    this.channelzTrace = new ChannelzTrace();\n    if (this.channelzEnabled) {\n      this.channelzRef = registerChannelzSubchannel(this.subchannelAddressString, () => this.getChannelzInfo());\n      this.channelzTrace.addTrace('CT_INFO', 'Subchannel created');\n    } else {\n      // Dummy channelz ref that will never be used\n      this.channelzRef = {\n        kind: 'subchannel',\n        id: -1,\n        name: ''\n      };\n    }\n    this.trace('Subchannel constructed with options ' + JSON.stringify(options, undefined, 2));\n  }\n\n  private getChannelzInfo(): SubchannelInfo {\n    return {\n      state: this.connectivityState,\n      trace: this.channelzTrace,\n      callTracker: this.callTracker,\n      children: this.childrenTracker.getChildLists(),\n      target: this.subchannelAddressString\n    };\n  }\n\n  private getChannelzSocketInfo(): SocketInfo | null {\n    if (this.session === null) {\n      return null;\n    }\n    const sessionSocket = this.session.socket;\n    const remoteAddress = sessionSocket.remoteAddress ? stringToSubchannelAddress(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;\n    const localAddress = sessionSocket.localAddress ? stringToSubchannelAddress(sessionSocket.localAddress, sessionSocket.localPort) : null;\n    let tlsInfo: TlsInfo | null;\n    if (this.session.encrypted) {\n      const tlsSocket: TLSSocket = sessionSocket as TLSSocket;\n      const cipherInfo: CipherNameAndProtocol & {standardName?: string} = tlsSocket.getCipher();\n      const certificate = tlsSocket.getCertificate();\n      const peerCertificate = tlsSocket.getPeerCertificate();\n      tlsInfo = {\n        cipherSuiteStandardName: cipherInfo.standardName ?? null,\n        cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,\n        localCertificate: (certificate && 'raw' in certificate) ? certificate.raw : null,\n        remoteCertificate: (peerCertificate && 'raw' in peerCertificate) ? peerCertificate.raw : null\n      };\n    } else {\n      tlsInfo = null;\n    }\n    const socketInfo: SocketInfo = {\n      remoteAddress: remoteAddress,\n      localAddress: localAddress,\n      security: tlsInfo,\n      remoteName: this.remoteName,\n      streamsStarted: this.streamTracker.callsStarted,\n      streamsSucceeded: this.streamTracker.callsSucceeded,\n      streamsFailed: this.streamTracker.callsFailed,\n      messagesSent: this.messagesSent,\n      messagesReceived: this.messagesReceived,\n      keepAlivesSent: this.keepalivesSent,\n      lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,\n      lastRemoteStreamCreatedTimestamp: null,\n      lastMessageSentTimestamp: this.lastMessageSentTimestamp,\n      lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,\n      localFlowControlWindow: this.session.state.localWindowSize ?? null,\n      remoteFlowControlWindow: this.session.state.remoteWindowSize ?? null\n    };\n    return socketInfo;\n  }\n\n  private resetChannelzSocketInfo() {\n    if (!this.channelzEnabled) {\n      return;\n    }\n    if (this.channelzSocketRef) {\n      unregisterChannelzRef(this.channelzSocketRef);\n      this.childrenTracker.unrefChild(this.channelzSocketRef);\n      this.channelzSocketRef = null;\n    }\n    this.remoteName = null;\n    this.streamTracker = new ChannelzCallTracker();\n    this.keepalivesSent = 0;\n    this.messagesSent = 0;\n    this.messagesReceived = 0;\n    this.lastMessageSentTimestamp = null;\n    this.lastMessageReceivedTimestamp = null;\n  }\n\n  private trace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, TRACER_NAME, '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private refTrace(text: string): void {\n    logging.trace(LogVerbosity.DEBUG, 'subchannel_refcount', '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' + text);\n  }\n\n  private handleBackoffTimer() {\n    if (this.continueConnecting) {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.CONNECTING\n      );\n    } else {\n      this.transitionToState(\n        [ConnectivityState.TRANSIENT_FAILURE],\n        ConnectivityState.IDLE\n      );\n    }\n  }\n\n  /**\n   * Start a backoff timer with the current nextBackoff timeout\n   */\n  private startBackoff() {\n    this.backoffTimeout.runOnce();\n  }\n\n  private stopBackoff() {\n    this.backoffTimeout.stop();\n    this.backoffTimeout.reset();\n  }\n\n  private sendPing() {\n    if (this.channelzEnabled) {\n      this.keepalivesSent += 1;\n    }\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'keepalive',\n      '(' + this.channelzRef.id + ') ' + this.subchannelAddressString + ' ' +\n      'Sending ping'\n    );\n    this.keepaliveTimeoutId = setTimeout(() => {\n      this.transitionToState([ConnectivityState.READY], ConnectivityState.IDLE);\n    }, this.keepaliveTimeoutMs);\n    this.keepaliveTimeoutId.unref?.();\n    this.session!.ping(\n      (err: Error | null, duration: number, payload: Buffer) => {\n        clearTimeout(this.keepaliveTimeoutId);\n      }\n    );\n  }\n\n  private startKeepalivePings() {\n    this.keepaliveIntervalId = setInterval(() => {\n      this.sendPing();\n    }, this.keepaliveTimeMs);\n    this.keepaliveIntervalId.unref?.();\n    /* Don't send a ping immediately because whatever caused us to start\n     * sending pings should also involve some network activity. */\n  }\n\n  private stopKeepalivePings() {\n    clearInterval(this.keepaliveIntervalId);\n    clearTimeout(this.keepaliveTimeoutId);\n  }\n\n  private createSession(proxyConnectionResult: ProxyConnectionResult) {\n    if (proxyConnectionResult.realTarget) {\n      this.remoteName = uriToString(proxyConnectionResult.realTarget);\n      this.trace('creating HTTP/2 session through proxy to ' + proxyConnectionResult.realTarget);\n    } else {\n      this.remoteName = null;\n      this.trace('creating HTTP/2 session');\n    }\n    const targetAuthority = getDefaultAuthority(\n      proxyConnectionResult.realTarget ?? this.channelTarget\n    );\n    let connectionOptions: http2.SecureClientSessionOptions =\n      this.credentials._getConnectionOptions() || {};\n    connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;\n    if ('grpc-node.max_session_memory' in this.options) {\n      connectionOptions.maxSessionMemory = this.options[\n        'grpc-node.max_session_memory'\n      ];\n    }\n    let addressScheme = 'http://';\n    if ('secureContext' in connectionOptions) {\n      addressScheme = 'https://';\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        const authorityHostname =\n          splitHostPort(targetAuthority)?.host ?? 'localhost';\n        // We want to always set servername to support SNI\n        connectionOptions.servername = authorityHostname;\n      }\n      if (proxyConnectionResult.socket) {\n        /* This is part of the workaround for\n         * https://github.com/nodejs/node/issues/32922. Without that bug,\n         * proxyConnectionResult.socket would always be a plaintext socket and\n         * this would say\n         * connectionOptions.socket = proxyConnectionResult.socket; */\n        connectionOptions.createConnection = (authority, option) => {\n          return proxyConnectionResult.socket!;\n        };\n      }\n    } else {\n      /* In all but the most recent versions of Node, http2.connect does not use\n       * the options when establishing plaintext connections, so we need to\n       * establish that connection explicitly. */\n      connectionOptions.createConnection = (authority, option) => {\n        if (proxyConnectionResult.socket) {\n          return proxyConnectionResult.socket;\n        } else {\n          /* net.NetConnectOpts is declared in a way that is more restrictive\n           * than what net.connect will actually accept, so we use the type\n           * assertion to work around that. */\n          return net.connect(this.subchannelAddress);\n        }\n      };\n    }\n\n    connectionOptions = {\n      ...connectionOptions,\n      ...this.subchannelAddress,\n    };\n\n    /* http2.connect uses the options here:\n     * https://github.com/nodejs/node/blob/70c32a6d190e2b5d7b9ff9d5b6a459d14e8b7d59/lib/internal/http2/core.js#L3028-L3036\n     * The spread operator overides earlier values with later ones, so any port\n     * or host values in the options will be used rather than any values extracted\n     * from the first argument. In addition, the path overrides the host and port,\n     * as documented for plaintext connections here:\n     * https://nodejs.org/api/net.html#net_socket_connect_options_connectlistener\n     * and for TLS connections here:\n     * https://nodejs.org/api/tls.html#tls_tls_connect_options_callback. In\n     * earlier versions of Node, http2.connect passes these options to\n     * tls.connect but not net.connect, so in the insecure case we still need\n     * to set the createConnection option above to create the connection\n     * explicitly. We cannot do that in the TLS case because http2.connect\n     * passes necessary additional options to tls.connect.\n     * The first argument just needs to be parseable as a URL and the scheme\n     * determines whether the connection will be established over TLS or not.\n     */\n    const session = http2.connect(\n      addressScheme + targetAuthority,\n      connectionOptions\n    );\n    this.session = session;\n    if (this.channelzEnabled) {\n      this.channelzSocketRef = registerChannelzSocket(this.subchannelAddressString, () => this.getChannelzSocketInfo()!);\n      this.childrenTracker.refChild(this.channelzSocketRef);\n    }\n    session.unref();\n    /* For all of these events, check if the session at the time of the event\n     * is the same one currently attached to this subchannel, to ensure that\n     * old events from previous connection attempts cannot cause invalid state\n     * transitions. */\n    session.once('connect', () => {\n      if (this.session === session) {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.READY\n        );\n      }\n    });\n    session.once('close', () => {\n      if (this.session === session) {\n        this.trace('connection closed');\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n        /* Transitioning directly to IDLE here should be OK because we are not\n         * doing any backoff, because a connection was established at some\n         * point */\n        this.transitionToState(\n          [ConnectivityState.READY],\n          ConnectivityState.IDLE\n        );\n      }\n    });\n    session.once(\n      'goaway',\n      (errorCode: number, lastStreamID: number, opaqueData: Buffer) => {\n        if (this.session === session) {\n          /* See the last paragraph of\n           * https://github.com/grpc/proposal/blob/master/A8-client-side-keepalive.md#basic-keepalive */\n          if (\n            errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM &&\n            opaqueData.equals(tooManyPingsData)\n          ) {\n            this.keepaliveTimeMs = Math.min(\n              2 * this.keepaliveTimeMs,\n              KEEPALIVE_MAX_TIME_MS\n            );\n            logging.log(\n              LogVerbosity.ERROR,\n              `Connection to ${uriToString(this.channelTarget)} at ${\n                this.subchannelAddressString\n              } rejected by server because of excess pings. Increasing ping interval to ${\n                this.keepaliveTimeMs\n              } ms`\n            );\n          }\n          this.trace(\n            'connection closed by GOAWAY with code ' +\n              errorCode\n          );\n          this.transitionToState(\n            [ConnectivityState.CONNECTING, ConnectivityState.READY],\n            ConnectivityState.IDLE\n          );\n        }\n      }\n    );\n    session.once('error', (error) => {\n      /* Do nothing here. Any error should also trigger a close event, which is\n       * where we want to handle that.  */\n      this.trace(\n        'connection closed with error ' +\n          (error as Error).message\n      );\n    });\n  }\n\n  private startConnectingInternal() {\n    /* Pass connection options through to the proxy so that it's able to\n     * upgrade it's connection to support tls if needed.\n     * This is a workaround for https://github.com/nodejs/node/issues/32922\n     * See https://github.com/grpc/grpc-node/pull/1369 for more info. */\n    const connectionOptions: ConnectionOptions =\n      this.credentials._getConnectionOptions() || {};\n\n    if ('secureContext' in connectionOptions) {\n      connectionOptions.ALPNProtocols = ['h2'];\n      // If provided, the value of grpc.ssl_target_name_override should be used\n      // to override the target hostname when checking server identity.\n      // This option is used for testing only.\n      if (this.options['grpc.ssl_target_name_override']) {\n        const sslTargetNameOverride = this.options[\n          'grpc.ssl_target_name_override'\n        ]!;\n        connectionOptions.checkServerIdentity = (\n          host: string,\n          cert: PeerCertificate\n        ): Error | undefined => {\n          return checkServerIdentity(sslTargetNameOverride, cert);\n        };\n        connectionOptions.servername = sslTargetNameOverride;\n      } else {\n        if ('grpc.http_connect_target' in this.options) {\n          /* This is more or less how servername will be set in createSession\n           * if a connection is successfully established through the proxy.\n           * If the proxy is not used, these connectionOptions are discarded\n           * anyway */\n          const targetPath = getDefaultAuthority(\n            parseUri(this.options['grpc.http_connect_target'] as string) ?? {\n              path: 'localhost',\n            }\n          );\n          const hostPort = splitHostPort(targetPath);\n          connectionOptions.servername = hostPort?.host ?? targetPath;\n        }\n      }\n    }\n\n    getProxiedConnection(\n      this.subchannelAddress,\n      this.options,\n      connectionOptions\n    ).then(\n      (result) => {\n        this.createSession(result);\n      },\n      (reason) => {\n        this.transitionToState(\n          [ConnectivityState.CONNECTING],\n          ConnectivityState.TRANSIENT_FAILURE\n        );\n      }\n    );\n  }\n\n  /**\n   * Initiate a state transition from any element of oldStates to the new\n   * state. If the current connectivityState is not in oldStates, do nothing.\n   * @param oldStates The set of states to transition from\n   * @param newState The state to transition to\n   * @returns True if the state changed, false otherwise\n   */\n  private transitionToState(\n    oldStates: ConnectivityState[],\n    newState: ConnectivityState\n  ): boolean {\n    if (oldStates.indexOf(this.connectivityState) === -1) {\n      return false;\n    }\n    this.trace(\n      ConnectivityState[this.connectivityState] +\n        ' -> ' +\n        ConnectivityState[newState]\n    );\n    if (this.channelzEnabled) {\n      this.channelzTrace.addTrace('CT_INFO', ConnectivityState[this.connectivityState] + ' -> ' + ConnectivityState[newState]);\n    }\n    const previousState = this.connectivityState;\n    this.connectivityState = newState;\n    switch (newState) {\n      case ConnectivityState.READY:\n        this.stopBackoff();\n        this.session!.socket.once('close', () => {\n          for (const listener of this.disconnectListeners) {\n            listener();\n          }\n        });\n        if (this.keepaliveWithoutCalls) {\n          this.startKeepalivePings();\n        }\n        break;\n      case ConnectivityState.CONNECTING:\n        this.startBackoff();\n        this.startConnectingInternal();\n        this.continueConnecting = false;\n        break;\n      case ConnectivityState.TRANSIENT_FAILURE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        /* If the backoff timer has already ended by the time we get to the\n         * TRANSIENT_FAILURE state, we want to immediately transition out of\n         * TRANSIENT_FAILURE as though the backoff timer is ending right now */\n        if (!this.backoffTimeout.isRunning()) {\n          process.nextTick(() => {\n            this.handleBackoffTimer();\n          });\n        }\n        break;\n      case ConnectivityState.IDLE:\n        if (this.session) {\n          this.session.close();\n        }\n        this.session = null;\n        this.resetChannelzSocketInfo();\n        this.stopKeepalivePings();\n        break;\n      default:\n        throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);\n    }\n    /* We use a shallow copy of the stateListeners array in case a listener\n     * is removed during this iteration */\n    for (const listener of [...this.stateListeners]) {\n      listener(this, previousState, newState);\n    }\n    return true;\n  }\n\n  /**\n   * Check if the subchannel associated with zero calls and with zero channels.\n   * If so, shut it down.\n   */\n  private checkBothRefcounts() {\n    /* If no calls, channels, or subchannel pools have any more references to\n     * this subchannel, we can be sure it will never be used again. */\n    if (this.callRefcount === 0 && this.refcount === 0) {\n      if (this.channelzEnabled) {\n        this.channelzTrace.addTrace('CT_INFO', 'Shutting down');\n      }\n      this.transitionToState(\n        [ConnectivityState.CONNECTING, ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n      if (this.channelzEnabled) {\n        unregisterChannelzRef(this.channelzRef);\n      }\n    }\n  }\n\n  callRef() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount + 1)\n    );\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.ref();\n      }\n      this.backoffTimeout.ref();\n      if (!this.keepaliveWithoutCalls) {\n        this.startKeepalivePings();\n      }\n    }\n    this.callRefcount += 1;\n  }\n\n  callUnref() {\n    this.refTrace(\n      'callRefcount ' +\n        this.callRefcount +\n        ' -> ' +\n        (this.callRefcount - 1)\n    );\n    this.callRefcount -= 1;\n    if (this.callRefcount === 0) {\n      if (this.session) {\n        this.session.unref();\n      }\n      this.backoffTimeout.unref();\n      if (!this.keepaliveWithoutCalls) {\n        this.stopKeepalivePings();\n      }\n      this.checkBothRefcounts();\n    }\n  }\n\n  ref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount + 1)\n    );\n    this.refcount += 1;\n  }\n\n  unref() {\n    this.refTrace(\n      'refcount ' +\n        this.refcount +\n        ' -> ' +\n        (this.refcount - 1)\n    );\n    this.refcount -= 1;\n    this.checkBothRefcounts();\n  }\n\n  unrefIfOneRef(): boolean {\n    if (this.refcount === 1) {\n      this.unref();\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Start a stream on the current session with the given `metadata` as headers\n   * and then attach it to the `callStream`. Must only be called if the\n   * subchannel's current connectivity state is READY.\n   * @param metadata\n   * @param callStream\n   */\n  startCallStream(\n    metadata: Metadata,\n    callStream: Http2CallStream,\n    extraFilters: Filter[]\n  ) {\n    const headers = metadata.toHttp2Headers();\n    headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n    headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n    headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n    headers[HTTP2_HEADER_METHOD] = 'POST';\n    headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n    headers[HTTP2_HEADER_TE] = 'trailers';\n    let http2Stream: http2.ClientHttp2Stream;\n    /* In theory, if an error is thrown by session.request because session has\n     * become unusable (e.g. because it has received a goaway), this subchannel\n     * should soon see the corresponding close or goaway event anyway and leave\n     * READY. But we have seen reports that this does not happen\n     * (https://github.com/googleapis/nodejs-firestore/issues/1023#issuecomment-653204096)\n     * so for defense in depth, we just discard the session when we see an\n     * error here.\n     */\n    try {\n      http2Stream = this.session!.request(headers);\n    } catch (e) {\n      this.transitionToState(\n        [ConnectivityState.READY],\n        ConnectivityState.TRANSIENT_FAILURE\n      );\n      throw e;\n    }\n    let headersString = '';\n    for (const header of Object.keys(headers)) {\n      headersString += '\\t\\t' + header + ': ' + headers[header] + '\\n';\n    }\n    logging.trace(\n      LogVerbosity.DEBUG,\n      'call_stream',\n      'Starting stream on subchannel ' +\n        '(' + this.channelzRef.id + ') ' +\n        this.subchannelAddressString +\n        ' with headers\\n' +\n        headersString\n    );\n    const streamSession = this.session;\n    let statsTracker: SubchannelCallStatsTracker;\n    if (this.channelzEnabled) {\n      this.callTracker.addCallStarted();\n      callStream.addStatusWatcher(status => {\n        if (status.code === Status.OK) {\n          this.callTracker.addCallSucceeded();\n        } else {\n          this.callTracker.addCallFailed();\n        }\n      });\n      this.streamTracker.addCallStarted();\n      callStream.addStreamEndWatcher(success => {\n        if (streamSession === this.session) {\n          if (success) {\n            this.streamTracker.addCallSucceeded();\n          } else {\n            this.streamTracker.addCallFailed();\n          }\n        }\n      });\n      statsTracker = {\n        addMessageSent: () => {\n          this.messagesSent += 1;\n          this.lastMessageSentTimestamp = new Date();\n        },\n        addMessageReceived: () => {\n          this.messagesReceived += 1;\n        }\n      }\n    } else {\n      statsTracker = {\n        addMessageSent: () => {},\n        addMessageReceived: () => {}\n      }\n    }\n    callStream.attachHttp2Stream(http2Stream, this, extraFilters, statsTracker);\n  }\n\n  /**\n   * If the subchannel is currently IDLE, start connecting and switch to the\n   * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,\n   * the next time it would transition to IDLE, start connecting again instead.\n   * Otherwise, do nothing.\n   */\n  startConnecting() {\n    /* First, try to transition from IDLE to connecting. If that doesn't happen\n     * because the state is not currently IDLE, check if it is\n     * TRANSIENT_FAILURE, and if so indicate that it should go back to\n     * connecting after the backoff timer ends. Otherwise do nothing */\n    if (\n      !this.transitionToState(\n        [ConnectivityState.IDLE],\n        ConnectivityState.CONNECTING\n      )\n    ) {\n      if (this.connectivityState === ConnectivityState.TRANSIENT_FAILURE) {\n        this.continueConnecting = true;\n      }\n    }\n  }\n\n  /**\n   * Get the subchannel's current connectivity state.\n   */\n  getConnectivityState() {\n    return this.connectivityState;\n  }\n\n  /**\n   * Add a listener function to be called whenever the subchannel's\n   * connectivity state changes.\n   * @param listener\n   */\n  addConnectivityStateListener(listener: ConnectivityStateListener) {\n    this.stateListeners.push(listener);\n  }\n\n  /**\n   * Remove a listener previously added with `addConnectivityStateListener`\n   * @param listener A reference to a function previously passed to\n   *     `addConnectivityStateListener`\n   */\n  removeConnectivityStateListener(listener: ConnectivityStateListener) {\n    const listenerIndex = this.stateListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.stateListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  addDisconnectListener(listener: () => void) {\n    this.disconnectListeners.push(listener);\n  }\n\n  removeDisconnectListener(listener: () => void) {\n    const listenerIndex = this.disconnectListeners.indexOf(listener);\n    if (listenerIndex > -1) {\n      this.disconnectListeners.splice(listenerIndex, 1);\n    }\n  }\n\n  /**\n   * Reset the backoff timeout, and immediately start connecting if in backoff.\n   */\n  resetBackoff() {\n    this.backoffTimeout.reset();\n    this.transitionToState(\n      [ConnectivityState.TRANSIENT_FAILURE],\n      ConnectivityState.CONNECTING\n    );\n  }\n\n  getAddress(): string {\n    return this.subchannelAddressString;\n  }\n\n  getChannelzRef(): SubchannelRef {\n    return this.channelzRef;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}